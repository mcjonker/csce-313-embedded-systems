
mytest.elf:     file format elf32-littlenios2
mytest.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x10000020

Program Header:
    LOAD off    0x00001000 vaddr 0x10000000 paddr 0x10000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x10000020 paddr 0x10000020 align 2**12
         filesz 0x001c6fc4 memsz 0x001c6fc4 flags r-x
    LOAD off    0x001c7fe4 vaddr 0x101c6fe4 paddr 0x101c7220 align 2**12
         filesz 0x0000023c memsz 0x0000023c flags rw-
    LOAD off    0x001c845c vaddr 0x101c745c paddr 0x101c745c align 2**12
         filesz 0x00000000 memsz 0x00000040 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  10000000  10000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  10000020  10000020  001c8220  2**0
                  CONTENTS
  2 .text         000049ec  10000020  10000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       001c25d8  10004a0c  10004a0c  00005a0c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000023c  101c6fe4  101c7220  001c7fe4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000040  101c745c  101c745c  001c845c  2**2
                  ALLOC, SMALL_DATA
  6 .sdram_controller 00000000  101c749c  101c749c  001c8220  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  001c8220  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000648  00000000  00000000  001c8248  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000090a6  00000000  00000000  001c8890  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00003179  00000000  00000000  001d1936  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000045c5  00000000  00000000  001d4aaf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000a9c  00000000  00000000  001d9074  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00002855  00000000  00000000  001d9b10  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00008eb6  00000000  00000000  001dc365  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000030  00000000  00000000  001e521c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000a08  00000000  00000000  001e5250  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  001e7a1a  2**0
                  CONTENTS, READONLY
 18 .cpu          00000009  00000000  00000000  001e7a1d  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  001e7a26  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  001e7a27  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  001e7a28  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  001e7a2c  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  001e7a30  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000004  00000000  00000000  001e7a34  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000004  00000000  00000000  001e7a38  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000004  00000000  00000000  001e7a3c  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000b  00000000  00000000  001e7a40  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000039  00000000  00000000  001e7a4b  2**0
                  CONTENTS, READONLY
 29 .jdi          00004c50  00000000  00000000  001e7a84  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00074e0d  00000000  00000000  001ec6d4  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
10000000 l    d  .entry	00000000 .entry
10000020 l    d  .exceptions	00000000 .exceptions
10000020 l    d  .text	00000000 .text
10004a0c l    d  .rodata	00000000 .rodata
101c6fe4 l    d  .rwdata	00000000 .rwdata
101c745c l    d  .bss	00000000 .bss
101c749c l    d  .sdram_controller	00000000 .sdram_controller
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../mytest_bsp//obj/HAL/src/crt0.o
10000068 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 myfile.c
00000000 l    df *ABS*	00000000 sf_cos.c
00000000 l    df *ABS*	00000000 sf_sin.c
00000000 l    df *ABS*	00000000 s_round.c
00000000 l    df *ABS*	00000000 ef_rem_pio2.c
101c6a94 l     O .rodata	00000080 npio2_hw
101c6b14 l     O .rodata	00000318 two_over_pi
00000000 l    df *ABS*	00000000 kf_cos.c
00000000 l    df *ABS*	00000000 kf_rem_pio2.c
101c6e58 l     O .rodata	0000000c init_jk
101c6e2c l     O .rodata	0000002c PIo2
00000000 l    df *ABS*	00000000 kf_sin.c
00000000 l    df *ABS*	00000000 sf_fabs.c
00000000 l    df *ABS*	00000000 sf_floor.c
00000000 l    df *ABS*	00000000 sf_scalbn.c
00000000 l    df *ABS*	00000000 sf_copysign.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
100033bc l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
101c6fe4 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
101c715c l     O .rwdata	00000048 video_character_buffer_with_dma_0
101c7108 l     O .rwdata	00000054 dma_buffer
101c70c4 l     O .rwdata	00000044 rgb_resampler
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_performance_counter.c
00000000 l    df *ABS*	00000000 altera_up_avalon_video_character_buffer_with_dma.c
00000000 l    df *ABS*	00000000 altera_up_avalon_video_pixel_buffer_dma.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
10004870 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcmp.c
10003b40 g     F .text	0000002c alt_main
1000441c g     F .text	0000015c alt_up_pixel_buffer_dma_draw_vline
10003314 g     F .text	00000080 _puts_r
101c7220 g       *ABS*	00000000 __flash_rwdata_start
101c745c g     O .bss	00000008 total_cycles
100032d0 g     F .text	00000044 printf
10003e5c g     F .text	0000000c alt_get_cpu_freq
10003f0c g     F .text	0000006c alt_up_char_buffer_string
100004dc g     F .text	000000ec round
10003ebc g     F .text	00000050 alt_up_char_buffer_draw
10003b6c g     F .text	00000038 alt_putstr
10003fa0 g     F .text	00000098 alt_up_pixel_buffer_dma_draw
10004964 g     F .text	00000008 altera_nios2_gen2_irq_init
10003f98 g     F .text	00000008 alt_up_pixel_buffer_dma_open_dev
10000000 g     F .entry	0000001c __reset
100005c8 g     F .text	00000308 __ieee754_rem_pio2f
10000020 g       *ABS*	00000000 __flash_exceptions_start
101c7464 g     O .bss	00000008 end_cycles
101c748c g     O .bss	00000004 errno
10000000 g       *ABS*	00000000 __alt_mem_sdram_controller
101c746c g     O .bss	00000004 shifted_row
101c7494 g     O .bss	00000004 alt_argv
101cf1fc g       *ABS*	00000000 _gp
101c7204 g     O .rwdata	00000004 jtag
10004038 g     F .text	0000001c alt_up_pixel_buffer_dma_change_back_buffer_address
10000224 g     F .text	000000c8 frame_function
101c71a4 g     O .rwdata	00000030 alt_fd_list
100048e4 g     F .text	00000074 alt_find_dev
10003f78 g     F .text	00000020 alt_up_char_buffer_clear
10002ce8 g     F .text	000000dc .hidden __floatsidf
10003394 g     F .text	0000000c puts
101c7470 g     O .bss	00000004 original_row
10004078 g     F .text	00000010 alt_up_pixel_buffer_dma_check_swap_buffers_status
10003294 g     F .text	0000003c _printf_r
100031d8 g     F .text	00000064 .hidden __udivsi3
100042e0 g     F .text	0000013c alt_up_pixel_buffer_dma_draw_hline
1000496c g     F .text	00000038 alt_icache_flush
10003e3c g     F .text	00000014 perf_get_num_starts
101c7474 g     O .bss	00000008 start_cycles
10004644 g     F .text	0000004c helper_plot_pixel
1000124c g     F .text	00000010 fabsf
101c7208 g     O .rwdata	00000004 alt_max_fd
10002dc4 g     F .text	00000110 .hidden __extendsfdf2
1000143c g     F .text	000008ac .hidden __adddf3
10004088 g     F .text	00000090 alt_up_pixel_buffer_dma_clear_screen
101c71fc g     O .rwdata	00000004 _global_impure_ptr
10001184 g     F .text	000000c8 __kernel_sinf
101c749c g       *ABS*	00000000 __bss_end
10004118 g     F .text	000001c8 alt_up_pixel_buffer_dma_draw_box
100003a4 g     F .text	0000009c cosf
10004a93 g     O .rodata	001c2000 myimage
101c71d4 g     O .rwdata	00000028 alt_dev_null
10004858 g     F .text	00000018 alt_dcache_flush_all
10004578 g     F .text	000000cc alt_up_pixel_buffer_dma_draw_rectangle
101c747c g     O .bss	00000004 theta
100008d0 g     F .text	000000f4 __kernel_cosf
101c7220 g       *ABS*	00000000 __ram_rwdata_end
101c720c g     O .rwdata	00000008 alt_dev_list
10003ba4 g     F .text	00000060 write
10004690 g     F .text	000001c8 alt_up_pixel_buffer_dma_draw_line
101c6fe4 g       *ABS*	00000000 __ram_rodata_end
1000323c g     F .text	00000058 .hidden __umodsi3
101c749c g       *ABS*	00000000 end
10003e68 g     F .text	0000004c alt_up_char_buffer_init
18000000 g       *ABS*	00000000 __alt_stack_pointer
1000307c g     F .text	00000064 .hidden __clzsi2
10003de0 g     F .text	00000034 altera_avalon_jtag_uart_write
10003428 g     F .text	00000524 ___vfprintf_internal_r
10000020 g     F .text	0000004c _start
10003c24 g     F .text	000001bc alt_sys_init
101c6fe4 g       *ABS*	00000000 __ram_rwdata_start
10004a0c g       *ABS*	00000000 __ram_rodata_start
10003e14 g     F .text	00000020 perf_get_section_time
100049a4 g     F .text	00000030 memcmp
101c749c g       *ABS*	00000000 __alt_stack_base
10001ce8 g     F .text	000008e8 .hidden __divdf3
10003e34 g     F .text	00000008 perf_get_total_time
101c7480 g     O .bss	00000004 shifted_col
100025d0 g     F .text	00000718 .hidden __muldf3
10004878 g     F .text	0000006c alt_dev_llist_insert
10001314 g     F .text	00000110 scalbnf
10003960 g     F .text	000000b8 __sfvwrite_small_dev
101c745c g       *ABS*	00000000 __bss_start
100002ec g     F .text	000000b8 main
1000006c g     F .text	000001b8 pixel_code
101c7490 g     O .bss	00000004 alt_envp
10004054 g     F .text	00000024 alt_up_pixel_buffer_dma_swap_buffers
10003eb4 g     F .text	00000008 alt_up_char_buffer_open_dev
10002ed4 g     F .text	000001a8 .hidden __truncdfsf2
101c721c g     O .rwdata	00000004 alt_errno
100030e0 g     F .text	00000084 .hidden __divsi3
100049d4 g     F .text	00000038 strcmp
10004a0c g       *ABS*	00000000 __flash_rodata_start
10003c04 g     F .text	00000020 alt_irq_init
10001424 g     F .text	00000018 copysignf
101c6e64 g     O .rodata	00000100 .hidden __clz_tab
101c7484 g     O .bss	00000004 my_pixel_buffer
10003a18 g     F .text	00000048 _write_r
101c7200 g     O .rwdata	00000004 _impure_ptr
101c7498 g     O .bss	00000004 alt_argc
101c7214 g     O .rwdata	00000008 alt_fs_list
10000440 g     F .text	0000009c sinf
10000020 g       *ABS*	00000000 __ram_exceptions_start
101c7220 g       *ABS*	00000000 _edata
101c749c g       *ABS*	00000000 _end
10000020 g       *ABS*	00000000 __ram_exceptions_end
10003e50 g     F .text	0000000c alt_get_performance_counter_base
10003164 g     F .text	00000074 .hidden __modsi3
18000000 g       *ABS*	00000000 __alt_data_end
101c7488 g     O .bss	00000004 original_col
1000001c g       .entry	00000000 _exit
100009c4 g     F .text	000007c0 __kernel_rem_pio2f
100033a0 g     F .text	0000001c strlen
10004958 g     F .text	0000000c alt_icache_flush_all
1000125c g     F .text	000000b8 floorf
1000394c g     F .text	00000014 __vfprintf_internal
10003a60 g     F .text	000000e0 alt_load



Disassembly of section .entry:

10000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
10000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
10000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
10000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
1000000c:	00bffd16 	blt	zero,r2,10000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
10000010:	00440034 	movhi	at,4096
    ori r1, r1, %lo(_start)
10000014:	08400814 	ori	at,at,32
    jmp r1
10000018:	0800683a 	jmp	at

1000001c <_exit>:
1000001c:	00000000 	call	10000000 <__reset>

Disassembly of section .text:

10000020 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
10000020:	00840014 	movui	r2,4096
#endif

0:
    initd 0(r2)
10000024:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
10000028:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
1000002c:	00bffd16 	blt	zero,r2,10000024 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
10000030:	06c60034 	movhi	sp,6144
    ori sp, sp, %lo(__alt_stack_pointer)
10000034:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
10000038:	06840734 	movhi	gp,4124
    ori gp, gp, %lo(_gp)
1000003c:	d6bc7f14 	ori	gp,gp,61948
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
10000040:	00840734 	movhi	r2,4124
    ori r2, r2, %lo(__bss_start)
10000044:	109d1714 	ori	r2,r2,29788

    movhi r3, %hi(__bss_end)
10000048:	00c40734 	movhi	r3,4124
    ori r3, r3, %lo(__bss_end)
1000004c:	18dd2714 	ori	r3,r3,29852

    beq r2, r3, 1f
10000050:	10c00326 	beq	r2,r3,10000060 <_start+0x40>

0:
    stw zero, (r2)
10000054:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
10000058:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
1000005c:	10fffd36 	bltu	r2,r3,10000054 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
10000060:	0003a600 	call	10003a60 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
10000064:	0003b400 	call	10003b40 <alt_main>

10000068 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
10000068:	003fff06 	br	10000068 <alt_after_alt_main>

1000006c <pixel_code>:
float shifted_col;
float original_row, original_col;
alt_up_pixel_buffer_dma_dev *my_pixel_buffer;
unsigned long long start_cycles, end_cycles, total_cycles;

void pixel_code(int i, int j) {
1000006c:	defff804 	addi	sp,sp,-32
10000070:	dc400115 	stw	r17,4(sp)
	shifted_row = i-240/2;
	// calculate shifted_col
	shifted_col = j - 320/2;
	// calculate original_row
	original_row = round((shifted_row*cosf(theta) - shifted_col*sinf(theta)) + 240/2);
10000074:	d460a017 	ldw	r17,-32128(gp)
float shifted_col;
float original_row, original_col;
alt_up_pixel_buffer_dma_dev *my_pixel_buffer;
unsigned long long start_cycles, end_cycles, total_cycles;

void pixel_code(int i, int j) {
10000078:	dcc00315 	stw	r19,12(sp)
1000007c:	dc800215 	stw	r18,8(sp)
	shifted_row = i-240/2;
	// calculate shifted_col
	shifted_col = j - 320/2;
10000080:	2cffd804 	addi	r19,r5,-160
float original_row, original_col;
alt_up_pixel_buffer_dma_dev *my_pixel_buffer;
unsigned long long start_cycles, end_cycles, total_cycles;

void pixel_code(int i, int j) {
	shifted_row = i-240/2;
10000084:	24bfe204 	addi	r18,r4,-120
10000088:	9025feb2 	custom	250,r18,r18,zero
	// calculate shifted_col
	shifted_col = j - 320/2;
1000008c:	9827feb2 	custom	250,r19,r19,zero
float shifted_col;
float original_row, original_col;
alt_up_pixel_buffer_dma_dev *my_pixel_buffer;
unsigned long long start_cycles, end_cycles, total_cycles;

void pixel_code(int i, int j) {
10000090:	dd000415 	stw	r20,16(sp)
10000094:	2029883a 	mov	r20,r4
	shifted_row = i-240/2;
	// calculate shifted_col
	shifted_col = j - 320/2;
	// calculate original_row
	original_row = round((shifted_row*cosf(theta) - shifted_col*sinf(theta)) + 240/2);
10000098:	8809883a 	mov	r4,r17
float shifted_col;
float original_row, original_col;
alt_up_pixel_buffer_dma_dev *my_pixel_buffer;
unsigned long long start_cycles, end_cycles, total_cycles;

void pixel_code(int i, int j) {
1000009c:	dfc00715 	stw	ra,28(sp)
100000a0:	dd800615 	stw	r22,24(sp)
100000a4:	dd400515 	stw	r21,20(sp)
100000a8:	dc000015 	stw	r16,0(sp)
	shifted_row = i-240/2;
100000ac:	d4a09c15 	stw	r18,-32144(gp)
float shifted_col;
float original_row, original_col;
alt_up_pixel_buffer_dma_dev *my_pixel_buffer;
unsigned long long start_cycles, end_cycles, total_cycles;

void pixel_code(int i, int j) {
100000b0:	2821883a 	mov	r16,r5
	shifted_row = i-240/2;
	// calculate shifted_col
	shifted_col = j - 320/2;
100000b4:	d4e0a115 	stw	r19,-32124(gp)
	// calculate original_row
	original_row = round((shifted_row*cosf(theta) - shifted_col*sinf(theta)) + 240/2);
100000b8:	00003a40 	call	100003a4 <cosf>
100000bc:	8809883a 	mov	r4,r17
100000c0:	102b883a 	mov	r21,r2
100000c4:	00004400 	call	10000440 <sinf>
100000c8:	102d883a 	mov	r22,r2
100000cc:	9d89ff32 	custom	252,r4,r19,r22
100000d0:	9545ff32 	custom	252,r2,r18,r21
100000d4:	1105ffb2 	custom	254,r2,r2,r4
100000d8:	0110bc34 	movhi	r4,17136
100000dc:	1109ff72 	custom	253,r4,r2,r4
100000e0:	0002dc40 	call	10002dc4 <__extendsfdf2>
100000e4:	1009883a 	mov	r4,r2
100000e8:	180b883a 	mov	r5,r3
100000ec:	00004dc0 	call	100004dc <round>
100000f0:	180b883a 	mov	r5,r3
100000f4:	1009883a 	mov	r4,r2
100000f8:	0002ed40 	call	10002ed4 <__truncdfsf2>
	//calculate original_col
	original_col = round((shifted_row*sinf(theta) + shifted_col*cosf(theta)) + 320/2);
100000fc:	95a5ff32 	custom	252,r18,r18,r22
10000100:	9d67ff32 	custom	252,r19,r19,r21
10000104:	94e5ff72 	custom	253,r18,r18,r19
10000108:	0110c834 	movhi	r4,17184
1000010c:	9109ff72 	custom	253,r4,r18,r4
void pixel_code(int i, int j) {
	shifted_row = i-240/2;
	// calculate shifted_col
	shifted_col = j - 320/2;
	// calculate original_row
	original_row = round((shifted_row*cosf(theta) - shifted_col*sinf(theta)) + 240/2);
10000110:	1023883a 	mov	r17,r2
10000114:	d0a09d15 	stw	r2,-32140(gp)
	//calculate original_col
	original_col = round((shifted_row*sinf(theta) + shifted_col*cosf(theta)) + 320/2);
10000118:	0002dc40 	call	10002dc4 <__extendsfdf2>
1000011c:	1009883a 	mov	r4,r2
10000120:	180b883a 	mov	r5,r3
10000124:	00004dc0 	call	100004dc <round>
10000128:	180b883a 	mov	r5,r3
1000012c:	1009883a 	mov	r4,r2
10000130:	0002ed40 	call	10002ed4 <__truncdfsf2>
10000134:	d0a0a315 	stw	r2,-32116(gp)
	// check if the image is out of boundary
	if ((i>=240) || (j>=320) || (i<0) || (j<0)) {
10000138:	00c03bc4 	movi	r3,239
1000013c:	1d000236 	bltu	r3,r20,10000148 <pixel_code+0xdc>
10000140:	00c04fc4 	movi	r3,319
10000144:	1c000e2e 	bgeu	r3,r16,10000180 <pixel_code+0x114>
		// if original_row is out of bound
		if (original_row >= 0 && original_row < 1) {
10000148:	0007883a 	mov	r3,zero
1000014c:	88c7f932 	custom	228,r3,r17,r3
10000150:	18000426 	beq	r3,zero,10000164 <pixel_code+0xf8>
10000154:	00cfe034 	movhi	r3,16256
10000158:	88c7f9f2 	custom	231,r3,r17,r3
1000015c:	18000126 	beq	r3,zero,10000164 <pixel_code+0xf8>
			// set i to 0
			i = 0;
10000160:	0029883a 	mov	r20,zero
		}
		// if original_col is out of bound
		if (original_col >=0 && original_col < 1) {
10000164:	0007883a 	mov	r3,zero
10000168:	10c7f932 	custom	228,r3,r2,r3
1000016c:	18000426 	beq	r3,zero,10000180 <pixel_code+0x114>
10000170:	00cfe034 	movhi	r3,16256
10000174:	10c7f9f2 	custom	231,r3,r2,r3
10000178:	18000126 	beq	r3,zero,10000180 <pixel_code+0x114>
			// set j to 0
			j = 0;
1000017c:	0021883a 	mov	r16,zero
		}
	}
	// display the image based on the values of original_row and original_col
	alt_up_pixel_buffer_dma_draw(my_pixel_buffer,
	(myimage[(i*320*3+j*3+2)]) +
10000180:	a500f024 	muli	r20,r20,960
10000184:	8407883a 	add	r3,r16,r16
			// set j to 0
			j = 0;
		}
	}
	// display the image based on the values of original_row and original_col
	alt_up_pixel_buffer_dma_draw(my_pixel_buffer,
10000188:	01d3c034 	movhi	r7,20224
	(myimage[(i*320*3+j*3+2)]) +
1000018c:	1c21883a 	add	r16,r3,r16
			// set j to 0
			j = 0;
		}
	}
	// display the image based on the values of original_row and original_col
	alt_up_pixel_buffer_dma_draw(my_pixel_buffer,
10000190:	89c7f932 	custom	228,r3,r17,r7
	(myimage[(i*320*3+j*3+2)]) +
10000194:	a421883a 	add	r16,r20,r16
			// set j to 0
			j = 0;
		}
	}
	// display the image based on the values of original_row and original_col
	alt_up_pixel_buffer_dma_draw(my_pixel_buffer,
10000198:	1800021e 	bne	r3,zero,100001a4 <pixel_code+0x138>
1000019c:	880ffe72 	custom	249,r7,r17,zero
100001a0:	00000306 	br	100001b0 <pixel_code+0x144>
100001a4:	89e3ffb2 	custom	254,r17,r17,r7
100001a8:	880ffe72 	custom	249,r7,r17,zero
100001ac:	39e0003c 	xorhi	r7,r7,32768
100001b0:	0193c034 	movhi	r6,20224
100001b4:	1187f932 	custom	228,r3,r2,r6
100001b8:	1800021e 	bne	r3,zero,100001c4 <pixel_code+0x158>
100001bc:	100dfe72 	custom	249,r6,r2,zero
100001c0:	00000306 	br	100001d0 <pixel_code+0x164>
100001c4:	1185ffb2 	custom	254,r2,r2,r6
100001c8:	100dfe72 	custom	249,r6,r2,zero
100001cc:	31a0003c 	xorhi	r6,r6,32768
	(myimage[(i*320*3+j*3+2)]) +
	(myimage[(i*320*3+j*3+1)]<<8) +
100001d0:	00840034 	movhi	r2,4096
100001d4:	1092a4c4 	addi	r2,r2,19091
100001d8:	1421883a 	add	r16,r2,r16
			// set j to 0
			j = 0;
		}
	}
	// display the image based on the values of original_row and original_col
	alt_up_pixel_buffer_dma_draw(my_pixel_buffer,
100001dc:	81400043 	ldbu	r5,1(r16)
100001e0:	80800083 	ldbu	r2,2(r16)
100001e4:	d120a217 	ldw	r4,-32120(gp)
100001e8:	280a923a 	slli	r5,r5,8
100001ec:	288b883a 	add	r5,r5,r2
100001f0:	80800003 	ldbu	r2,0(r16)
100001f4:	1004943a 	slli	r2,r2,16
100001f8:	288b883a 	add	r5,r5,r2
	(myimage[(i*320*3+j*3+2)]) +
	(myimage[(i*320*3+j*3+1)]<<8) +
	(myimage[(i*320*3+j*3+0)]<<16),original_col,original_row);

}
100001fc:	dfc00717 	ldw	ra,28(sp)
10000200:	dd800617 	ldw	r22,24(sp)
10000204:	dd400517 	ldw	r21,20(sp)
10000208:	dd000417 	ldw	r20,16(sp)
1000020c:	dcc00317 	ldw	r19,12(sp)
10000210:	dc800217 	ldw	r18,8(sp)
10000214:	dc400117 	ldw	r17,4(sp)
10000218:	dc000017 	ldw	r16,0(sp)
1000021c:	dec00804 	addi	sp,sp,32
			// set j to 0
			j = 0;
		}
	}
	// display the image based on the values of original_row and original_col
	alt_up_pixel_buffer_dma_draw(my_pixel_buffer,
10000220:	0003fa01 	jmpi	10003fa0 <alt_up_pixel_buffer_dma_draw>

10000224 <frame_function>:
	(myimage[(i*320*3+j*3+2)]) +
	(myimage[(i*320*3+j*3+1)]<<8) +
	(myimage[(i*320*3+j*3+0)]<<16),original_col,original_row);

}
void frame_function() {
10000224:	defffb04 	addi	sp,sp,-20
10000228:	dc800215 	stw	r18,8(sp)
	// for loop that rotates over image rows
	for (int i = 0; i < 240; i++) {
	// for loop that rotates over image cols
		for (int j = 0; j < 360; j++) {
			start_cycles = perf_get_total_time((void*) 0x203000); // PERFORMANCE_COUNTER_0_BASE
			PERF_START_MEASURING(0x203000); // PERFORMANCE_COUNTER_0_BASE
1000022c:	04800834 	movhi	r18,32
	(myimage[(i*320*3+j*3+2)]) +
	(myimage[(i*320*3+j*3+1)]<<8) +
	(myimage[(i*320*3+j*3+0)]<<16),original_col,original_row);

}
void frame_function() {
10000230:	dcc00315 	stw	r19,12(sp)
10000234:	dc400115 	stw	r17,4(sp)
10000238:	dfc00415 	stw	ra,16(sp)
1000023c:	dc000015 	stw	r16,0(sp)
	// frame code
	// for loop that rotates over image rows
	for (int i = 0; i < 240; i++) {
10000240:	0023883a 	mov	r17,zero
	// for loop that rotates over image cols
		for (int j = 0; j < 360; j++) {
			start_cycles = perf_get_total_time((void*) 0x203000); // PERFORMANCE_COUNTER_0_BASE
			PERF_START_MEASURING(0x203000); // PERFORMANCE_COUNTER_0_BASE
10000244:	948c0104 	addi	r18,r18,12292
void frame_function() {
	// frame code
	// for loop that rotates over image rows
	for (int i = 0; i < 240; i++) {
	// for loop that rotates over image cols
		for (int j = 0; j < 360; j++) {
10000248:	04c05a04 	movi	r19,360
	(myimage[(i*320*3+j*3+2)]) +
	(myimage[(i*320*3+j*3+1)]<<8) +
	(myimage[(i*320*3+j*3+0)]<<16),original_col,original_row);

}
void frame_function() {
1000024c:	0021883a 	mov	r16,zero
	// frame code
	// for loop that rotates over image rows
	for (int i = 0; i < 240; i++) {
	// for loop that rotates over image cols
		for (int j = 0; j < 360; j++) {
			start_cycles = perf_get_total_time((void*) 0x203000); // PERFORMANCE_COUNTER_0_BASE
10000250:	01000834 	movhi	r4,32
10000254:	210c0004 	addi	r4,r4,12288
10000258:	0003e340 	call	10003e34 <perf_get_total_time>
1000025c:	d0a09e15 	stw	r2,-32136(gp)
10000260:	d0e09f15 	stw	r3,-32132(gp)
			PERF_START_MEASURING(0x203000); // PERFORMANCE_COUNTER_0_BASE
10000264:	90000035 	stwio	zero,0(r18)
			pixel_code(i,j);
10000268:	800b883a 	mov	r5,r16
1000026c:	8809883a 	mov	r4,r17
10000270:	000006c0 	call	1000006c <pixel_code>
			end_cycles = perf_get_total_time((void*) 0x203000); // PERFORMANCE_COUNTER_0_BASE
10000274:	01000834 	movhi	r4,32
10000278:	210c0004 	addi	r4,r4,12288
1000027c:	0003e340 	call	10003e34 <perf_get_total_time>
10000280:	d0a09a15 	stw	r2,-32152(gp)
10000284:	d0e09b15 	stw	r3,-32148(gp)
			PERF_START_MEASURING(0x203000); // PERFORMANCE_COUNTER_0_BASE
10000288:	90000035 	stwio	zero,0(r18)
			total_cycles = end_cycles - start_cycles;
1000028c:	d1a09a17 	ldw	r6,-32152(gp)
10000290:	d1609e17 	ldw	r5,-32136(gp)
10000294:	d0a09f17 	ldw	r2,-32132(gp)
			printf("Estimate performance cycle = %llu \n", total_cycles);
10000298:	01040034 	movhi	r4,4096
			start_cycles = perf_get_total_time((void*) 0x203000); // PERFORMANCE_COUNTER_0_BASE
			PERF_START_MEASURING(0x203000); // PERFORMANCE_COUNTER_0_BASE
			pixel_code(i,j);
			end_cycles = perf_get_total_time((void*) 0x203000); // PERFORMANCE_COUNTER_0_BASE
			PERF_START_MEASURING(0x203000); // PERFORMANCE_COUNTER_0_BASE
			total_cycles = end_cycles - start_cycles;
1000029c:	314bc83a 	sub	r5,r6,r5
100002a0:	314d803a 	cmpltu	r6,r6,r5
100002a4:	1887c83a 	sub	r3,r3,r2
100002a8:	198dc83a 	sub	r6,r3,r6
			printf("Estimate performance cycle = %llu \n", total_cycles);
100002ac:	21128304 	addi	r4,r4,18956
void frame_function() {
	// frame code
	// for loop that rotates over image rows
	for (int i = 0; i < 240; i++) {
	// for loop that rotates over image cols
		for (int j = 0; j < 360; j++) {
100002b0:	84000044 	addi	r16,r16,1
			start_cycles = perf_get_total_time((void*) 0x203000); // PERFORMANCE_COUNTER_0_BASE
			PERF_START_MEASURING(0x203000); // PERFORMANCE_COUNTER_0_BASE
			pixel_code(i,j);
			end_cycles = perf_get_total_time((void*) 0x203000); // PERFORMANCE_COUNTER_0_BASE
			PERF_START_MEASURING(0x203000); // PERFORMANCE_COUNTER_0_BASE
			total_cycles = end_cycles - start_cycles;
100002b4:	d1609815 	stw	r5,-32160(gp)
100002b8:	d1a09915 	stw	r6,-32156(gp)
			printf("Estimate performance cycle = %llu \n", total_cycles);
100002bc:	00032d00 	call	100032d0 <printf>
void frame_function() {
	// frame code
	// for loop that rotates over image rows
	for (int i = 0; i < 240; i++) {
	// for loop that rotates over image cols
		for (int j = 0; j < 360; j++) {
100002c0:	84ffe31e 	bne	r16,r19,10000250 <frame_function+0x2c>

}
void frame_function() {
	// frame code
	// for loop that rotates over image rows
	for (int i = 0; i < 240; i++) {
100002c4:	8c400044 	addi	r17,r17,1
100002c8:	00803c04 	movi	r2,240
100002cc:	88bfdf1e 	bne	r17,r2,1000024c <frame_function+0x28>
			PERF_START_MEASURING(0x203000); // PERFORMANCE_COUNTER_0_BASE
			total_cycles = end_cycles - start_cycles;
			printf("Estimate performance cycle = %llu \n", total_cycles);
		}
	}
}
100002d0:	dfc00417 	ldw	ra,16(sp)
100002d4:	dcc00317 	ldw	r19,12(sp)
100002d8:	dc800217 	ldw	r18,8(sp)
100002dc:	dc400117 	ldw	r17,4(sp)
100002e0:	dc000017 	ldw	r16,0(sp)
100002e4:	dec00504 	addi	sp,sp,20
100002e8:	f800283a 	ret

100002ec <main>:

int main() {
	alt_putstr("Project 6 (Part B) Mitchell Jonker and Hunter Frady\n");
100002ec:	01040034 	movhi	r4,4096
			printf("Estimate performance cycle = %llu \n", total_cycles);
		}
	}
}

int main() {
100002f0:	defffd04 	addi	sp,sp,-12
	alt_putstr("Project 6 (Part B) Mitchell Jonker and Hunter Frady\n");
100002f4:	21128c04 	addi	r4,r4,18992
			printf("Estimate performance cycle = %llu \n", total_cycles);
		}
	}
}

int main() {
100002f8:	dfc00215 	stw	ra,8(sp)
100002fc:	dc400115 	stw	r17,4(sp)
10000300:	dc000015 	stw	r16,0(sp)
	alt_putstr("Project 6 (Part B) Mitchell Jonker and Hunter Frady\n");
10000304:	0003b6c0 	call	10003b6c <alt_putstr>
	//int ticks_per_second, ticks_start, ticks_end, ticks_delta;
	//ticks_per_second = alt_ticks_per_second();
	//printf("TPS: %d \n", ticks_per_second);


	my_pixel_buffer = alt_up_pixel_buffer_dma_open_dev("/dev/dma_buffer");
10000308:	01040034 	movhi	r4,4096
1000030c:	21129a04 	addi	r4,r4,19048
10000310:	0003f980 	call	10003f98 <alt_up_pixel_buffer_dma_open_dev>
10000314:	d0a0a215 	stw	r2,-32120(gp)

	if(!my_pixel_buffer) {
10000318:	1000031e 	bne	r2,zero,10000328 <main+0x3c>
		printf("Error opening pixel buffer\n");
1000031c:	01040034 	movhi	r4,4096
10000320:	21129e04 	addi	r4,r4,19064
10000324:	00033940 	call	10003394 <puts>
	}

	alt_up_pixel_buffer_dma_clear_screen(my_pixel_buffer, 0);
10000328:	d120a217 	ldw	r4,-32120(gp)
1000032c:	000b883a 	mov	r5,zero
	//printf("Current Tic: %d \n", ticks_current);

	while (1) {
		//unsigned long long fps_avg = 0;
		// for loop that rotates over four frames on 0, 90, 180, 270 degree
		for (int t = 0; t > -360; t = t-90) { // -360
10000330:	047fa604 	movi	r17,-360

	if(!my_pixel_buffer) {
		printf("Error opening pixel buffer\n");
	}

	alt_up_pixel_buffer_dma_clear_screen(my_pixel_buffer, 0);
10000334:	00040880 	call	10004088 <alt_up_pixel_buffer_dma_clear_screen>
	//printf("Current Tic: %d \n", ticks_current);

	while (1) {
		//unsigned long long fps_avg = 0;
		// for loop that rotates over four frames on 0, 90, 180, 270 degree
		for (int t = 0; t > -360; t = t-90) { // -360
10000338:	0021883a 	mov	r16,zero
			// calculate theta

			theta = (t*3.14)/180;
1000033c:	8009883a 	mov	r4,r16
10000340:	0002ce80 	call	10002ce8 <__floatsidf>
10000344:	01947b34 	movhi	r6,20972
10000348:	01d00274 	movhi	r7,16393
1000034c:	31a147c4 	addi	r6,r6,-31457
10000350:	39c7ae04 	addi	r7,r7,7864
10000354:	1009883a 	mov	r4,r2
10000358:	180b883a 	mov	r5,r3
1000035c:	00025d00 	call	100025d0 <__muldf3>
10000360:	01d019f4 	movhi	r7,16487
10000364:	000d883a 	mov	r6,zero
10000368:	39e00004 	addi	r7,r7,-32768
1000036c:	1009883a 	mov	r4,r2
10000370:	180b883a 	mov	r5,r3
10000374:	0001ce80 	call	10001ce8 <__divdf3>
10000378:	180b883a 	mov	r5,r3
1000037c:	1009883a 	mov	r4,r2
10000380:	0002ed40 	call	10002ed4 <__truncdfsf2>
			alt_up_pixel_buffer_dma_clear_screen(my_pixel_buffer,0);
10000384:	d120a217 	ldw	r4,-32120(gp)
10000388:	000b883a 	mov	r5,zero
	//printf("Current Tic: %d \n", ticks_current);

	while (1) {
		//unsigned long long fps_avg = 0;
		// for loop that rotates over four frames on 0, 90, 180, 270 degree
		for (int t = 0; t > -360; t = t-90) { // -360
1000038c:	843fe984 	addi	r16,r16,-90
			// calculate theta

			theta = (t*3.14)/180;
10000390:	d0a0a015 	stw	r2,-32128(gp)
			alt_up_pixel_buffer_dma_clear_screen(my_pixel_buffer,0);
10000394:	00040880 	call	10004088 <alt_up_pixel_buffer_dma_clear_screen>

			//
			//ticks_start = alt_nticks(); // starting number of ticks
			//printf("Start Tic: %d \n", ticks_start);
			frame_function();
10000398:	00002240 	call	10000224 <frame_function>
	//printf("Current Tic: %d \n", ticks_current);

	while (1) {
		//unsigned long long fps_avg = 0;
		// for loop that rotates over four frames on 0, 90, 180, 270 degree
		for (int t = 0; t > -360; t = t-90) { // -360
1000039c:	847fe71e 	bne	r16,r17,1000033c <main+0x50>
100003a0:	003fe506 	br	10000338 <main+0x4c>

100003a4 <cosf>:
	__int32_t n,ix;

	GET_FLOAT_WORD(ix,x);

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
100003a4:	00e00034 	movhi	r3,32768
	float cosf(float x)
#else
	float cosf(x)
	float x;
#endif
{
100003a8:	defffd04 	addi	sp,sp,-12
	__int32_t n,ix;

	GET_FLOAT_WORD(ix,x);

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
100003ac:	18ffffc4 	addi	r3,r3,-1
	if(ix <= 0x3f490fd8) return __kernel_cosf(x,z);
100003b0:	014fd274 	movhi	r5,16201
	float cosf(float x)
#else
	float cosf(x)
	float x;
#endif
{
100003b4:	dfc00215 	stw	ra,8(sp)
	__int32_t n,ix;

	GET_FLOAT_WORD(ix,x);

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
100003b8:	1906703a 	and	r3,r3,r4
	if(ix <= 0x3f490fd8) return __kernel_cosf(x,z);
100003bc:	2943f604 	addi	r5,r5,4056
100003c0:	28c00216 	blt	r5,r3,100003cc <cosf+0x28>
100003c4:	000b883a 	mov	r5,zero
100003c8:	00000f06 	br	10000408 <cosf+0x64>

    /* cos(Inf or NaN) is NaN */
	else if (!FLT_UWORD_IS_FINITE(ix)) return x-x;
100003cc:	015fe034 	movhi	r5,32640
100003d0:	297fffc4 	addi	r5,r5,-1
100003d4:	28c0020e 	bge	r5,r3,100003e0 <cosf+0x3c>
100003d8:	2105ffb2 	custom	254,r2,r4,r4
100003dc:	00001506 	br	10000434 <cosf+0x90>

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2f(x,y);
100003e0:	d80b883a 	mov	r5,sp
100003e4:	00005c80 	call	100005c8 <__ieee754_rem_pio2f>
	    switch(n&3) {
100003e8:	108000cc 	andi	r2,r2,3
100003ec:	01800044 	movi	r6,1
100003f0:	11800726 	beq	r2,r6,10000410 <cosf+0x6c>
100003f4:	00c00084 	movi	r3,2
		case 0: return  __kernel_cosf(y[0],y[1]);
		case 1: return -__kernel_sinf(y[0],y[1],1);
		case 2: return -__kernel_cosf(y[0],y[1]);
100003f8:	d9400117 	ldw	r5,4(sp)
100003fc:	d9000017 	ldw	r4,0(sp)
	else if (!FLT_UWORD_IS_FINITE(ix)) return x-x;

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2f(x,y);
	    switch(n&3) {
10000400:	10c00826 	beq	r2,r3,10000424 <cosf+0x80>
10000404:	10000a1e 	bne	r2,zero,10000430 <cosf+0x8c>
		case 0: return  __kernel_cosf(y[0],y[1]);
10000408:	00008d00 	call	100008d0 <__kernel_cosf>
1000040c:	00000906 	br	10000434 <cosf+0x90>
		case 1: return -__kernel_sinf(y[0],y[1],1);
10000410:	d9400117 	ldw	r5,4(sp)
10000414:	d9000017 	ldw	r4,0(sp)
10000418:	100d883a 	mov	r6,r2
1000041c:	00011840 	call	10001184 <__kernel_sinf>
10000420:	00000106 	br	10000428 <cosf+0x84>
		case 2: return -__kernel_cosf(y[0],y[1]);
10000424:	00008d00 	call	100008d0 <__kernel_cosf>
10000428:	1005f872 	custom	225,r2,r2,zero
1000042c:	00000106 	br	10000434 <cosf+0x90>
		default:
		        return  __kernel_sinf(y[0],y[1],1);
10000430:	00011840 	call	10001184 <__kernel_sinf>
	    }
	}
}
10000434:	dfc00217 	ldw	ra,8(sp)
10000438:	dec00304 	addi	sp,sp,12
1000043c:	f800283a 	ret

10000440 <sinf>:
	__int32_t n,ix;

	GET_FLOAT_WORD(ix,x);

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
10000440:	00e00034 	movhi	r3,32768
	float sinf(float x)
#else
	float sinf(x)
	float x;
#endif
{
10000444:	defffd04 	addi	sp,sp,-12
	__int32_t n,ix;

	GET_FLOAT_WORD(ix,x);

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
10000448:	18ffffc4 	addi	r3,r3,-1
	if(ix <= 0x3f490fd8) return __kernel_sinf(x,z,0);
1000044c:	014fd274 	movhi	r5,16201
	float sinf(float x)
#else
	float sinf(x)
	float x;
#endif
{
10000450:	dfc00215 	stw	ra,8(sp)
	__int32_t n,ix;

	GET_FLOAT_WORD(ix,x);

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
10000454:	1906703a 	and	r3,r3,r4
	if(ix <= 0x3f490fd8) return __kernel_sinf(x,z,0);
10000458:	2943f604 	addi	r5,r5,4056
1000045c:	28c00316 	blt	r5,r3,1000046c <sinf+0x2c>
10000460:	000d883a 	mov	r6,zero
10000464:	000b883a 	mov	r5,zero
10000468:	00000f06 	br	100004a8 <sinf+0x68>

    /* sin(Inf or NaN) is NaN */
	else if (!FLT_UWORD_IS_FINITE(ix)) return x-x;
1000046c:	015fe034 	movhi	r5,32640
10000470:	297fffc4 	addi	r5,r5,-1
10000474:	28c0020e 	bge	r5,r3,10000480 <sinf+0x40>
10000478:	2105ffb2 	custom	254,r2,r4,r4
1000047c:	00001406 	br	100004d0 <sinf+0x90>

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2f(x,y);
10000480:	d80b883a 	mov	r5,sp
10000484:	00005c80 	call	100005c8 <__ieee754_rem_pio2f>
	    switch(n&3) {
10000488:	108000cc 	andi	r2,r2,3
1000048c:	01800044 	movi	r6,1
10000490:	11800726 	beq	r2,r6,100004b0 <sinf+0x70>
10000494:	00c00084 	movi	r3,2
		case 0: return  __kernel_sinf(y[0],y[1],1);
		case 1: return  __kernel_cosf(y[0],y[1]);
		case 2: return -__kernel_sinf(y[0],y[1],1);
10000498:	d9400117 	ldw	r5,4(sp)
1000049c:	d9000017 	ldw	r4,0(sp)
	else if (!FLT_UWORD_IS_FINITE(ix)) return x-x;

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2f(x,y);
	    switch(n&3) {
100004a0:	10c00726 	beq	r2,r3,100004c0 <sinf+0x80>
100004a4:	1000081e 	bne	r2,zero,100004c8 <sinf+0x88>
		case 0: return  __kernel_sinf(y[0],y[1],1);
100004a8:	00011840 	call	10001184 <__kernel_sinf>
100004ac:	00000806 	br	100004d0 <sinf+0x90>
		case 1: return  __kernel_cosf(y[0],y[1]);
100004b0:	d9400117 	ldw	r5,4(sp)
100004b4:	d9000017 	ldw	r4,0(sp)
100004b8:	00008d00 	call	100008d0 <__kernel_cosf>
100004bc:	00000406 	br	100004d0 <sinf+0x90>
		case 2: return -__kernel_sinf(y[0],y[1],1);
100004c0:	00011840 	call	10001184 <__kernel_sinf>
100004c4:	00000106 	br	100004cc <sinf+0x8c>
		default:
			return -__kernel_cosf(y[0],y[1]);
100004c8:	00008d00 	call	100008d0 <__kernel_cosf>
100004cc:	1005f872 	custom	225,r2,r2,zero
	    }
	}
}
100004d0:	dfc00217 	ldw	ra,8(sp)
100004d4:	dec00304 	addi	sp,sp,12
100004d8:	f800283a 	ret

100004dc <round>:
  __uint32_t lsw;

  EXTRACT_WORDS(msw, lsw, x);

  /* Extract exponent field. */
  exponent_less_1023 = ((msw & 0x7ff00000) >> 20) - 1023;
100004dc:	289ffc2c 	andhi	r2,r5,32752
100004e0:	1005d53a 	srai	r2,r2,20

  if (exponent_less_1023 < 20)
100004e4:	024004c4 	movi	r9,19
	double round(double x)
#else
	double round(x)
	double x;
#endif
{
100004e8:	200d883a 	mov	r6,r4
  __uint32_t lsw;

  EXTRACT_WORDS(msw, lsw, x);

  /* Extract exponent field. */
  exponent_less_1023 = ((msw & 0x7ff00000) >> 20) - 1023;
100004ec:	123f0044 	addi	r8,r2,-1023
	double round(double x)
#else
	double round(x)
	double x;
#endif
{
100004f0:	280f883a 	mov	r7,r5
  /* Most significant word, least significant word. */
  __int32_t msw, exponent_less_1023;
  __uint32_t lsw;

  EXTRACT_WORDS(msw, lsw, x);
100004f4:	2807883a 	mov	r3,r5

  /* Extract exponent field. */
  exponent_less_1023 = ((msw & 0x7ff00000) >> 20) - 1023;

  if (exponent_less_1023 < 20)
100004f8:	4a001216 	blt	r9,r8,10000544 <round+0x68>
    {
      if (exponent_less_1023 < 0)
100004fc:	4000050e 	bge	r8,zero,10000514 <round+0x38>
        {
          msw &= 0x80000000;
          if (exponent_less_1023 == -1)
10000500:	00bfffc4 	movi	r2,-1

  if (exponent_less_1023 < 20)
    {
      if (exponent_less_1023 < 0)
        {
          msw &= 0x80000000;
10000504:	29e0002c 	andhi	r7,r5,32768
          if (exponent_less_1023 == -1)
10000508:	4080261e 	bne	r8,r2,100005a4 <round+0xc8>
            /* Result is +1.0 or -1.0. */
            msw |= (1023 << 20);
1000050c:	39cffc34 	orhi	r7,r7,16368
10000510:	00002406 	br	100005a4 <round+0xc8>
          lsw = 0;
        }
      else
        {
          __uint32_t exponent_mask = 0x000fffff >> exponent_less_1023;
10000514:	00800434 	movhi	r2,16
10000518:	10bfffc4 	addi	r2,r2,-1
1000051c:	1205d83a 	sra	r2,r2,r8
          if ((msw & exponent_mask) == 0 && lsw == 0)
10000520:	2888703a 	and	r4,r5,r2
10000524:	2000011e 	bne	r4,zero,1000052c <round+0x50>
10000528:	30002026 	beq	r6,zero,100005ac <round+0xd0>
            /* x in an integral value. */
            return x;

          msw += 0x00080000 >> exponent_less_1023;
          msw &= ~exponent_mask;
1000052c:	01c00234 	movhi	r7,8
10000530:	3a0fd83a 	sra	r7,r7,r8
10000534:	38c7883a 	add	r3,r7,r3
10000538:	008e303a 	nor	r7,zero,r2
1000053c:	19ce703a 	and	r7,r3,r7
10000540:	00001806 	br	100005a4 <round+0xc8>
          lsw = 0;
        }
    }
  else if (exponent_less_1023 > 51)
10000544:	02400cc4 	movi	r9,51
10000548:	4a00080e 	bge	r9,r8,1000056c <round+0x90>
    {
      if (exponent_less_1023 == 1024)
1000054c:	00810004 	movi	r2,1024
10000550:	4080181e 	bne	r8,r2,100005b4 <round+0xd8>
	double round(double x)
#else
	double round(x)
	double x;
#endif
{
10000554:	deffff04 	addi	sp,sp,-4
10000558:	dfc00015 	stw	ra,0(sp)
    }
  else if (exponent_less_1023 > 51)
    {
      if (exponent_less_1023 == 1024)
        /* x is NaN or infinite. */
        return x + x;
1000055c:	000143c0 	call	1000143c <__adddf3>
      lsw &= ~exponent_mask;
    }
  INSERT_WORDS(x, msw, lsw);

  return x;
}
10000560:	dfc00017 	ldw	ra,0(sp)
10000564:	dec00104 	addi	sp,sp,4
10000568:	f800283a 	ret
      else
        return x;
    }
  else
    {
      __uint32_t exponent_mask = 0xffffffff >> (exponent_less_1023 - 20);
1000056c:	013fffc4 	movi	r4,-1
10000570:	10befb44 	addi	r2,r2,-1043
10000574:	2084d83a 	srl	r2,r4,r2
      __uint32_t tmp;

      if ((lsw & exponent_mask) == 0)
10000578:	3088703a 	and	r4,r6,r2
1000057c:	20001026 	beq	r4,zero,100005c0 <round+0xe4>
        /* x is an integral value. */
        return x;

      tmp = lsw + (1 << (51 - exponent_less_1023));
10000580:	4a11c83a 	sub	r8,r9,r8
10000584:	01000044 	movi	r4,1
10000588:	2210983a 	sll	r8,r4,r8
1000058c:	4191883a 	add	r8,r8,r6
      if (tmp < lsw)
10000590:	4180012e 	bgeu	r8,r6,10000598 <round+0xbc>
        msw += 1;
10000594:	290f883a 	add	r7,r5,r4
      lsw = tmp;

      lsw &= ~exponent_mask;
10000598:	0084303a 	nor	r2,zero,r2
1000059c:	120c703a 	and	r6,r2,r8
100005a0:	00000406 	br	100005b4 <round+0xd8>
        {
          msw &= 0x80000000;
          if (exponent_less_1023 == -1)
            /* Result is +1.0 or -1.0. */
            msw |= (1023 << 20);
          lsw = 0;
100005a4:	000d883a 	mov	r6,zero
100005a8:	00000206 	br	100005b4 <round+0xd8>
      else
        {
          __uint32_t exponent_mask = 0x000fffff >> exponent_less_1023;
          if ((msw & exponent_mask) == 0 && lsw == 0)
            /* x in an integral value. */
            return x;
100005ac:	0005883a 	mov	r2,zero
100005b0:	00000106 	br	100005b8 <round+0xdc>
100005b4:	3005883a 	mov	r2,r6
100005b8:	3807883a 	mov	r3,r7
100005bc:	f800283a 	ret
100005c0:	3005883a 	mov	r2,r6
100005c4:	f800283a 	ret

100005c8 <__ieee754_rem_pio2f>:
	__int32_t __ieee754_rem_pio2f(float x, float *y)
#else
	__int32_t __ieee754_rem_pio2f(x,y)
	float x,y[];
#endif
{
100005c8:	defff704 	addi	sp,sp,-36
100005cc:	dc000515 	stw	r16,20(sp)
	float tx[3];
	__int32_t i,j,n,ix,hx;
	int e0,nx;

	GET_FLOAT_WORD(hx,x);
	ix = hx&0x7fffffff;
100005d0:	04200034 	movhi	r16,32768
100005d4:	843fffc4 	addi	r16,r16,-1
	if(ix<=0x3f490fd8)   /* |x| ~<= pi/4 , no need for reduction */
100005d8:	00cfd274 	movhi	r3,16201
	__int32_t __ieee754_rem_pio2f(float x, float *y)
#else
	__int32_t __ieee754_rem_pio2f(x,y)
	float x,y[];
#endif
{
100005dc:	dfc00815 	stw	ra,32(sp)
100005e0:	dc800715 	stw	r18,28(sp)
100005e4:	dc400615 	stw	r17,24(sp)
	float tx[3];
	__int32_t i,j,n,ix,hx;
	int e0,nx;

	GET_FLOAT_WORD(hx,x);
	ix = hx&0x7fffffff;
100005e8:	8120703a 	and	r16,r16,r4
	if(ix<=0x3f490fd8)   /* |x| ~<= pi/4 , no need for reduction */
100005ec:	18c3f604 	addi	r3,r3,4056
	__int32_t __ieee754_rem_pio2f(float x, float *y)
#else
	__int32_t __ieee754_rem_pio2f(x,y)
	float x,y[];
#endif
{
100005f0:	2005883a 	mov	r2,r4
	__int32_t i,j,n,ix,hx;
	int e0,nx;

	GET_FLOAT_WORD(hx,x);
	ix = hx&0x7fffffff;
	if(ix<=0x3f490fd8)   /* |x| ~<= pi/4 , no need for reduction */
100005f4:	1c000316 	blt	r3,r16,10000604 <__ieee754_rem_pio2f+0x3c>
	    {y[0] = x; y[1] = 0; return 0;}
100005f8:	29000015 	stw	r4,0(r5)
100005fc:	28000115 	stw	zero,4(r5)
10000600:	00008406 	br	10000814 <__ieee754_rem_pio2f+0x24c>
	if(ix<0x4016cbe4) {  /* |x| < 3pi/4, special case with n=+-1 */
10000604:	00d005f4 	movhi	r3,16407
10000608:	18f2f8c4 	addi	r3,r3,-13341
1000060c:	2025883a 	mov	r18,r4
10000610:	1c002816 	blt	r3,r16,100006b4 <__ieee754_rem_pio2f+0xec>
10000614:	018ff274 	movhi	r6,16329
	    if(hx>0) { 
		z = x - pio2_1;
10000618:	010ff274 	movhi	r4,16329
1000061c:	00fffc04 	movi	r3,-16
10000620:	3183f404 	addi	r6,r6,4048
10000624:	2103e004 	addi	r4,r4,3968
	GET_FLOAT_WORD(hx,x);
	ix = hx&0x7fffffff;
	if(ix<=0x3f490fd8)   /* |x| ~<= pi/4 , no need for reduction */
	    {y[0] = x; y[1] = 0; return 0;}
	if(ix<0x4016cbe4) {  /* |x| < 3pi/4, special case with n=+-1 */
	    if(hx>0) { 
10000628:	0080110e 	bge	zero,r2,10000670 <__ieee754_rem_pio2f+0xa8>
		z = x - pio2_1;
		if((ix&0xfffffff0)!=0x3fc90fd0) { /* 24+24 bit pi OK */
1000062c:	80e0703a 	and	r16,r16,r3
	ix = hx&0x7fffffff;
	if(ix<=0x3f490fd8)   /* |x| ~<= pi/4 , no need for reduction */
	    {y[0] = x; y[1] = 0; return 0;}
	if(ix<0x4016cbe4) {  /* |x| < 3pi/4, special case with n=+-1 */
	    if(hx>0) { 
		z = x - pio2_1;
10000630:	1105ffb2 	custom	254,r2,r2,r4
		if((ix&0xfffffff0)!=0x3fc90fd0) { /* 24+24 bit pi OK */
		    y[0] = z - pio2_1t;
10000634:	00cdcd74 	movhi	r3,14133
	if(ix<=0x3f490fd8)   /* |x| ~<= pi/4 , no need for reduction */
	    {y[0] = x; y[1] = 0; return 0;}
	if(ix<0x4016cbe4) {  /* |x| < 3pi/4, special case with n=+-1 */
	    if(hx>0) { 
		z = x - pio2_1;
		if((ix&0xfffffff0)!=0x3fc90fd0) { /* 24+24 bit pi OK */
10000638:	81800226 	beq	r16,r6,10000644 <__ieee754_rem_pio2f+0x7c>
		    y[0] = z - pio2_1t;
1000063c:	18d110c4 	addi	r3,r3,17475
10000640:	00000406 	br	10000654 <__ieee754_rem_pio2f+0x8c>
		    y[1] = (z-y[0])-pio2_1t;
		} else {		/* near pi/2, use 24+24+24 bit pi */
		    z -= pio2_2;
10000644:	18d10004 	addi	r3,r3,17408
10000648:	10c5ffb2 	custom	254,r2,r2,r3
		    y[0] = z - pio2_2t;
1000064c:	00cba1b4 	movhi	r3,11910
10000650:	18e8c204 	addi	r3,r3,-23800
10000654:	10c9ffb2 	custom	254,r4,r2,r3
		    y[1] = (z-y[0])-pio2_2t;
10000658:	1105ffb2 	custom	254,r2,r2,r4
1000065c:	10c5ffb2 	custom	254,r2,r2,r3
10000660:	28800115 	stw	r2,4(r5)
		if((ix&0xfffffff0)!=0x3fc90fd0) { /* 24+24 bit pi OK */
		    y[0] = z - pio2_1t;
		    y[1] = (z-y[0])-pio2_1t;
		} else {		/* near pi/2, use 24+24+24 bit pi */
		    z -= pio2_2;
		    y[0] = z - pio2_2t;
10000664:	29000015 	stw	r4,0(r5)
		    y[1] = (z-y[0])-pio2_2t;
		}
		return 1;
10000668:	00800044 	movi	r2,1
1000066c:	00009206 	br	100008b8 <__ieee754_rem_pio2f+0x2f0>
	    } else {	/* negative x */
		z = x + pio2_1;
		if((ix&0xfffffff0)!=0x3fc90fd0) { /* 24+24 bit pi OK */
10000670:	80e0703a 	and	r16,r16,r3
		    y[0] = z - pio2_2t;
		    y[1] = (z-y[0])-pio2_2t;
		}
		return 1;
	    } else {	/* negative x */
		z = x + pio2_1;
10000674:	1105ff72 	custom	253,r2,r2,r4
		if((ix&0xfffffff0)!=0x3fc90fd0) { /* 24+24 bit pi OK */
		    y[0] = z + pio2_1t;
10000678:	00cdcd74 	movhi	r3,14133
		    y[1] = (z-y[0])-pio2_2t;
		}
		return 1;
	    } else {	/* negative x */
		z = x + pio2_1;
		if((ix&0xfffffff0)!=0x3fc90fd0) { /* 24+24 bit pi OK */
1000067c:	81800226 	beq	r16,r6,10000688 <__ieee754_rem_pio2f+0xc0>
		    y[0] = z + pio2_1t;
10000680:	18d110c4 	addi	r3,r3,17475
10000684:	00000406 	br	10000698 <__ieee754_rem_pio2f+0xd0>
		    y[1] = (z-y[0])+pio2_1t;
		} else {		/* near pi/2, use 24+24+24 bit pi */
		    z += pio2_2;
10000688:	18d10004 	addi	r3,r3,17408
1000068c:	10c5ff72 	custom	253,r2,r2,r3
		    y[0] = z + pio2_2t;
10000690:	00cba1b4 	movhi	r3,11910
10000694:	18e8c204 	addi	r3,r3,-23800
10000698:	10c9ff72 	custom	253,r4,r2,r3
		    y[1] = (z-y[0])+pio2_2t;
1000069c:	1105ffb2 	custom	254,r2,r2,r4
100006a0:	10c5ff72 	custom	253,r2,r2,r3
100006a4:	28800115 	stw	r2,4(r5)
		if((ix&0xfffffff0)!=0x3fc90fd0) { /* 24+24 bit pi OK */
		    y[0] = z + pio2_1t;
		    y[1] = (z-y[0])+pio2_1t;
		} else {		/* near pi/2, use 24+24+24 bit pi */
		    z += pio2_2;
		    y[0] = z + pio2_2t;
100006a8:	29000015 	stw	r4,0(r5)
		    y[1] = (z-y[0])+pio2_2t;
		}
		return -1;
100006ac:	00bfffc4 	movi	r2,-1
100006b0:	00008106 	br	100008b8 <__ieee754_rem_pio2f+0x2f0>
	    }
	}
	if(ix<=0x43490f80) { /* |x| ~<= 2^7*(pi/2), medium size */
100006b4:	00d0d274 	movhi	r3,17225
100006b8:	18c3e004 	addi	r3,r3,3968
100006bc:	2823883a 	mov	r17,r5
100006c0:	1c004e16 	blt	r3,r16,100007fc <__ieee754_rem_pio2f+0x234>
	    t  = fabsf(x);
100006c4:	000124c0 	call	1000124c <fabsf>
	    n  = (__int32_t) (t*invpio2+half);
100006c8:	010fc8f4 	movhi	r4,16163
100006cc:	213e6104 	addi	r4,r4,-1660
		}
		return -1;
	    }
	}
	if(ix<=0x43490f80) { /* |x| ~<= 2^7*(pi/2), medium size */
	    t  = fabsf(x);
100006d0:	1007883a 	mov	r3,r2
	    n  = (__int32_t) (t*invpio2+half);
100006d4:	1109ff32 	custom	252,r4,r2,r4
100006d8:	008fc034 	movhi	r2,16128
100006dc:	2089ff72 	custom	253,r4,r4,r2
100006e0:	2005fe72 	custom	249,r2,r4,zero
	    fn = (float)n;
	    r  = t-fn*pio2_1;
100006e4:	010ff274 	movhi	r4,16329
	    }
	}
	if(ix<=0x43490f80) { /* |x| ~<= 2^7*(pi/2), medium size */
	    t  = fabsf(x);
	    n  = (__int32_t) (t*invpio2+half);
	    fn = (float)n;
100006e8:	1011feb2 	custom	250,r8,r2,zero
	    r  = t-fn*pio2_1;
100006ec:	2103e004 	addi	r4,r4,3968
100006f0:	4109ff32 	custom	252,r4,r8,r4
100006f4:	1907ffb2 	custom	254,r3,r3,r4
	    w  = fn*pio2_1t;	/* 1st round good to 40 bit */
100006f8:	010dcd74 	movhi	r4,14133
100006fc:	211110c4 	addi	r4,r4,17475
10000700:	4109ff32 	custom	252,r4,r8,r4
	    if(n<32&&(ix&0xffffff00)!=npio2_hw[n-1]) {	
10000704:	014007c4 	movi	r5,31
10000708:	190dffb2 	custom	254,r6,r3,r4
1000070c:	28800a16 	blt	r5,r2,10000738 <__ieee754_rem_pio2f+0x170>
10000710:	117fffc4 	addi	r5,r2,-1
10000714:	294b883a 	add	r5,r5,r5
10000718:	02440734 	movhi	r9,4124
1000071c:	294b883a 	add	r5,r5,r5
10000720:	4a5aa504 	addi	r9,r9,27284
10000724:	494b883a 	add	r5,r9,r5
10000728:	29400017 	ldw	r5,0(r5)
1000072c:	01ffc004 	movi	r7,-256
10000730:	81ce703a 	and	r7,r16,r7
10000734:	3940061e 	bne	r7,r5,10000750 <__ieee754_rem_pio2f+0x188>
	        __uint32_t high;
	        j  = ix>>23;
	        y[0] = r-w; 
		GET_FLOAT_WORD(high,y[0]);
	        i = j-((high>>23)&0xff);
	        if(i>8) {  /* 2nd iteration needed, good to 57 */
10000738:	300ad5fa 	srli	r5,r6,23
	    } else {
	        __uint32_t high;
	        j  = ix>>23;
	        y[0] = r-w; 
		GET_FLOAT_WORD(high,y[0]);
	        i = j-((high>>23)&0xff);
1000073c:	8021d5fa 	srai	r16,r16,23
	        if(i>8) {  /* 2nd iteration needed, good to 57 */
10000740:	01c00204 	movi	r7,8
10000744:	29403fcc 	andi	r5,r5,255
10000748:	814bc83a 	sub	r5,r16,r5
1000074c:	39400216 	blt	r7,r5,10000758 <__ieee754_rem_pio2f+0x190>
	    if(n<32&&(ix&0xffffff00)!=npio2_hw[n-1]) {	
		y[0] = r-w;	/* quick check no cancellation */
	    } else {
	        __uint32_t high;
	        j  = ix>>23;
	        y[0] = r-w; 
10000750:	89800015 	stw	r6,0(r17)
10000754:	00001f06 	br	100007d4 <__ieee754_rem_pio2f+0x20c>
		GET_FLOAT_WORD(high,y[0]);
	        i = j-((high>>23)&0xff);
	        if(i>8) {  /* 2nd iteration needed, good to 57 */
		    t  = r;
		    w  = fn*pio2_2;	
10000758:	014dcd74 	movhi	r5,14133
1000075c:	29510004 	addi	r5,r5,17408
10000760:	414dff32 	custom	252,r6,r8,r5
		    r  = t-w;
10000764:	198bffb2 	custom	254,r5,r3,r6
		    w  = fn*pio2_2t-((t-r)-w);	
10000768:	01cba1b4 	movhi	r7,11910
1000076c:	1949ffb2 	custom	254,r4,r3,r5
10000770:	39e8c204 	addi	r7,r7,-23800
10000774:	2189ffb2 	custom	254,r4,r4,r6
10000778:	41cfff32 	custom	252,r7,r8,r7
1000077c:	3909ffb2 	custom	254,r4,r7,r4
		    y[0] = r-w;
10000780:	290dffb2 	custom	254,r6,r5,r4
		    GET_FLOAT_WORD(high,y[0]);
		    i = j-((high>>23)&0xff);
		    if(i>25)  {	/* 3rd iteration need, 74 bits acc */
10000784:	3006d5fa 	srli	r3,r6,23
10000788:	18c03fcc 	andi	r3,r3,255
1000078c:	80e1c83a 	sub	r16,r16,r3
10000790:	00c00644 	movi	r3,25
10000794:	1c000316 	blt	r3,r16,100007a4 <__ieee754_rem_pio2f+0x1dc>
	        if(i>8) {  /* 2nd iteration needed, good to 57 */
		    t  = r;
		    w  = fn*pio2_2;	
		    r  = t-w;
		    w  = fn*pio2_2t-((t-r)-w);	
		    y[0] = r-w;
10000798:	89800015 	stw	r6,0(r17)
		GET_FLOAT_WORD(high,y[0]);
	        i = j-((high>>23)&0xff);
	        if(i>8) {  /* 2nd iteration needed, good to 57 */
		    t  = r;
		    w  = fn*pio2_2;	
		    r  = t-w;
1000079c:	2807883a 	mov	r3,r5
100007a0:	00000c06 	br	100007d4 <__ieee754_rem_pio2f+0x20c>
		    y[0] = r-w;
		    GET_FLOAT_WORD(high,y[0]);
		    i = j-((high>>23)&0xff);
		    if(i>25)  {	/* 3rd iteration need, 74 bits acc */
		    	t  = r;	/* will cover all possible cases */
		    	w  = fn*pio2_3;	
100007a4:	018ba1b4 	movhi	r6,11910
100007a8:	31a8c004 	addi	r6,r6,-23808
100007ac:	418dff32 	custom	252,r6,r8,r6
		    	r  = t-w;
100007b0:	2987ffb2 	custom	254,r3,r5,r6
		    	w  = fn*pio2_3t-((t-r)-w);	
100007b4:	01092374 	movhi	r4,9357
100007b8:	28cbffb2 	custom	254,r5,r5,r3
100007bc:	210c4c84 	addi	r4,r4,12594
100007c0:	298bffb2 	custom	254,r5,r5,r6
100007c4:	4109ff32 	custom	252,r4,r8,r4
100007c8:	2149ffb2 	custom	254,r4,r4,r5
		    	y[0] = r-w;
100007cc:	190bffb2 	custom	254,r5,r3,r4
100007d0:	89400015 	stw	r5,0(r17)
		    }
		}
	    }
	    y[1] = (r-y[0])-w;
100007d4:	89400017 	ldw	r5,0(r17)
100007d8:	1947ffb2 	custom	254,r3,r3,r5
100007dc:	1909ffb2 	custom	254,r4,r3,r4
100007e0:	89000115 	stw	r4,4(r17)
	    if(hx<0) 	{y[0] = -y[0]; y[1] = -y[1]; return -n;}
100007e4:	9000340e 	bge	r18,zero,100008b8 <__ieee754_rem_pio2f+0x2f0>
100007e8:	280bf872 	custom	225,r5,r5,zero
100007ec:	2009f872 	custom	225,r4,r4,zero
100007f0:	89400015 	stw	r5,0(r17)
100007f4:	89000115 	stw	r4,4(r17)
100007f8:	00002e06 	br	100008b4 <__ieee754_rem_pio2f+0x2ec>
	    else	 return n;
	}
    /* 
     * all other (large) arguments
     */
	if(!FLT_UWORD_IS_FINITE(ix)) {
100007fc:	00dfe034 	movhi	r3,32640
10000800:	18ffffc4 	addi	r3,r3,-1
10000804:	1c00050e 	bge	r3,r16,1000081c <__ieee754_rem_pio2f+0x254>
	    y[0]=y[1]=x-x; return 0;
10000808:	2105ffb2 	custom	254,r2,r4,r4
1000080c:	28800115 	stw	r2,4(r5)
10000810:	28800015 	stw	r2,0(r5)
10000814:	0005883a 	mov	r2,zero
10000818:	00002706 	br	100008b8 <__ieee754_rem_pio2f+0x2f0>
	}
    /* set z = scalbn(|x|,ilogb(x)-7) */
	e0 	= (int)((ix>>23)-134);	/* e0 = ilogb(z)-7; */
1000081c:	800dd5fa 	srai	r6,r16,23
		tx[i] = (float)((__int32_t)(z));
		z     = (z-tx[i])*two8;
	}
	tx[2] = z;
	nx = 3;
	while(tx[nx-1]==zero) nx--;	/* skip zero term */
10000820:	0007883a 	mov	r3,zero
     */
	if(!FLT_UWORD_IS_FINITE(ix)) {
	    y[0]=y[1]=x-x; return 0;
	}
    /* set z = scalbn(|x|,ilogb(x)-7) */
	e0 	= (int)((ix>>23)-134);	/* e0 = ilogb(z)-7; */
10000824:	31bfde84 	addi	r6,r6,-134
	SET_FLOAT_WORD(z, ix - ((__int32_t)e0<<23));
10000828:	300495fa 	slli	r2,r6,23
1000082c:	80a1c83a 	sub	r16,r16,r2
	for(i=0;i<2;i++) {
		tx[i] = (float)((__int32_t)(z));
10000830:	8005fe72 	custom	249,r2,r16,zero
10000834:	1005feb2 	custom	250,r2,r2,zero
		z     = (z-tx[i])*two8;
10000838:	80a1ffb2 	custom	254,r16,r16,r2
	}
    /* set z = scalbn(|x|,ilogb(x)-7) */
	e0 	= (int)((ix>>23)-134);	/* e0 = ilogb(z)-7; */
	SET_FLOAT_WORD(z, ix - ((__int32_t)e0<<23));
	for(i=0;i<2;i++) {
		tx[i] = (float)((__int32_t)(z));
1000083c:	d8800215 	stw	r2,8(sp)
		z     = (z-tx[i])*two8;
10000840:	0090e034 	movhi	r2,17280
10000844:	80a1ff32 	custom	252,r16,r16,r2
	}
    /* set z = scalbn(|x|,ilogb(x)-7) */
	e0 	= (int)((ix>>23)-134);	/* e0 = ilogb(z)-7; */
	SET_FLOAT_WORD(z, ix - ((__int32_t)e0<<23));
	for(i=0;i<2;i++) {
		tx[i] = (float)((__int32_t)(z));
10000848:	800ffe72 	custom	249,r7,r16,zero
1000084c:	380ffeb2 	custom	250,r7,r7,zero
		z     = (z-tx[i])*two8;
10000850:	81e1ffb2 	custom	254,r16,r16,r7
10000854:	8085ff32 	custom	252,r2,r16,r2
	}
	tx[2] = z;
10000858:	d8800415 	stw	r2,16(sp)
	}
    /* set z = scalbn(|x|,ilogb(x)-7) */
	e0 	= (int)((ix>>23)-134);	/* e0 = ilogb(z)-7; */
	SET_FLOAT_WORD(z, ix - ((__int32_t)e0<<23));
	for(i=0;i<2;i++) {
		tx[i] = (float)((__int32_t)(z));
1000085c:	d9c00315 	stw	r7,12(sp)
		z     = (z-tx[i])*two8;
	}
	tx[2] = z;
	nx = 3;
	while(tx[nx-1]==zero) nx--;	/* skip zero term */
10000860:	10c5f8b2 	custom	226,r2,r2,r3
10000864:	1000031e 	bne	r2,zero,10000874 <__ieee754_rem_pio2f+0x2ac>
10000868:	388ff8b2 	custom	226,r7,r7,r2
1000086c:	39c00044 	addi	r7,r7,1
10000870:	00000106 	br	10000878 <__ieee754_rem_pio2f+0x2b0>
	for(i=0;i<2;i++) {
		tx[i] = (float)((__int32_t)(z));
		z     = (z-tx[i])*two8;
	}
	tx[2] = z;
	nx = 3;
10000874:	01c000c4 	movi	r7,3
	while(tx[nx-1]==zero) nx--;	/* skip zero term */
	n  =  __kernel_rem_pio2f(tx,y,e0,nx,2,two_over_pi);
10000878:	00840734 	movhi	r2,4124
1000087c:	109ac504 	addi	r2,r2,27412
10000880:	d8800115 	stw	r2,4(sp)
10000884:	00800084 	movi	r2,2
10000888:	d8800015 	stw	r2,0(sp)
1000088c:	880b883a 	mov	r5,r17
10000890:	d9000204 	addi	r4,sp,8
10000894:	00009c40 	call	100009c4 <__kernel_rem_pio2f>
	if(hx<0) {y[0] = -y[0]; y[1] = -y[1]; return -n;}
10000898:	9000070e 	bge	r18,zero,100008b8 <__ieee754_rem_pio2f+0x2f0>
1000089c:	88c00017 	ldw	r3,0(r17)
100008a0:	1807f872 	custom	225,r3,r3,zero
100008a4:	88c00015 	stw	r3,0(r17)
100008a8:	88c00117 	ldw	r3,4(r17)
100008ac:	1807f872 	custom	225,r3,r3,zero
100008b0:	88c00115 	stw	r3,4(r17)
100008b4:	0085c83a 	sub	r2,zero,r2
	return n;
}
100008b8:	dfc00817 	ldw	ra,32(sp)
100008bc:	dc800717 	ldw	r18,28(sp)
100008c0:	dc400617 	ldw	r17,24(sp)
100008c4:	dc000517 	ldw	r16,20(sp)
100008c8:	dec00904 	addi	sp,sp,36
100008cc:	f800283a 	ret

100008d0 <__kernel_cosf>:
#endif
{
	float a,hz,z,r,qx;
	__int32_t ix;
	GET_FLOAT_WORD(ix,x);
	ix &= 0x7fffffff;			/* ix = |x|'s high word*/
100008d0:	02200034 	movhi	r8,32768
100008d4:	423fffc4 	addi	r8,r8,-1
	if(ix<0x32000000) {			/* if x < 2**27 */
100008d8:	008c8034 	movhi	r2,12800
#endif
{
	float a,hz,z,r,qx;
	__int32_t ix;
	GET_FLOAT_WORD(ix,x);
	ix &= 0x7fffffff;			/* ix = |x|'s high word*/
100008dc:	4110703a 	and	r8,r8,r4
	if(ix<0x32000000) {			/* if x < 2**27 */
100008e0:	10bfffc4 	addi	r2,r2,-1
100008e4:	12000216 	blt	r2,r8,100008f0 <__kernel_cosf+0x20>
	    if(((int)x)==0) return one;		/* generate inexact */
100008e8:	2005fe72 	custom	249,r2,r4,zero
100008ec:	10003326 	beq	r2,zero,100009bc <__kernel_cosf+0xec>
	}
	z  = x*x;
	r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));
100008f0:	00eb5234 	movhi	r3,44360
	GET_FLOAT_WORD(ix,x);
	ix &= 0x7fffffff;			/* ix = |x|'s high word*/
	if(ix<0x32000000) {			/* if x < 2**27 */
	    if(((int)x)==0) return one;		/* generate inexact */
	}
	z  = x*x;
100008f4:	210fff32 	custom	252,r7,r4,r4
	r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));
100008f8:	18f5d384 	addi	r3,r3,-10418
100008fc:	024c43f4 	movhi	r9,12559
10000900:	38cdff32 	custom	252,r6,r7,r3
10000904:	4a5d3d84 	addi	r9,r9,29942
10000908:	324dff72 	custom	253,r6,r6,r9
1000090c:	008d2534 	movhi	r2,13460
10000910:	10bc9f04 	addi	r2,r2,-3460
10000914:	31cdff32 	custom	252,r6,r6,r7
10000918:	308dffb2 	custom	254,r6,r6,r2
1000091c:	008df434 	movhi	r2,14288
10000920:	10834044 	addi	r2,r2,3329
10000924:	31cdff32 	custom	252,r6,r6,r7
10000928:	308dff72 	custom	253,r6,r6,r2
1000092c:	008eadb4 	movhi	r2,15030
10000930:	31cdff32 	custom	252,r6,r6,r7
10000934:	1082d844 	addi	r2,r2,2913
10000938:	3085ffb2 	custom	254,r2,r6,r2
1000093c:	11cdff32 	custom	252,r6,r2,r7
10000940:	008f4af4 	movhi	r2,15659
10000944:	10aaaac4 	addi	r2,r2,-21845
10000948:	3085ff72 	custom	253,r2,r6,r2
1000094c:	11c5ff32 	custom	252,r2,r2,r7
10000950:	3887ff32 	custom	252,r3,r7,r2
	if(ix < 0x3e99999a) 			/* if |x| < 0.3 */ 
10000954:	008fa6b4 	movhi	r2,16026
10000958:	10a66644 	addi	r2,r2,-26215
1000095c:	2149ff32 	custom	252,r4,r4,r5
10000960:	12000716 	blt	r2,r8,10000980 <__kernel_cosf+0xb0>
	    return one - ((float)0.5*z - (z*r - x*y));
10000964:	008fc034 	movhi	r2,16128
10000968:	3885ff32 	custom	252,r2,r7,r2
1000096c:	1907ffb2 	custom	254,r3,r3,r4
10000970:	10c7ffb2 	custom	254,r3,r2,r3
10000974:	018fe034 	movhi	r6,16256
10000978:	30c5ffb2 	custom	254,r2,r6,r3
1000097c:	f800283a 	ret
	else {
	    if(ix > 0x3f480000) {		/* x > 0.78125 */
10000980:	008fd234 	movhi	r2,16200
10000984:	12000316 	blt	r2,r8,10000994 <__kernel_cosf+0xc4>
		qx = (float)0.28125;
	    } else {
	        SET_FLOAT_WORD(qx,ix-0x01000000);	/* x/4 */
10000988:	00bfc034 	movhi	r2,65280
1000098c:	4091883a 	add	r8,r8,r2
10000990:	00000106 	br	10000998 <__kernel_cosf+0xc8>
	r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));
	if(ix < 0x3e99999a) 			/* if |x| < 0.3 */ 
	    return one - ((float)0.5*z - (z*r - x*y));
	else {
	    if(ix > 0x3f480000) {		/* x > 0.78125 */
		qx = (float)0.28125;
10000994:	020fa434 	movhi	r8,16016
	    } else {
	        SET_FLOAT_WORD(qx,ix-0x01000000);	/* x/4 */
	    }
	    hz = (float)0.5*z-qx;
	    a  = one-qx;
	    return a - (hz - (z*r-x*y));
10000998:	014fc034 	movhi	r5,16128
1000099c:	394fff32 	custom	252,r7,r7,r5
100009a0:	3a0fffb2 	custom	254,r7,r7,r8
100009a4:	1907ffb2 	custom	254,r3,r3,r4
100009a8:	008fe034 	movhi	r2,16256
100009ac:	1205ffb2 	custom	254,r2,r2,r8
100009b0:	38c7ffb2 	custom	254,r3,r7,r3
100009b4:	10c5ffb2 	custom	254,r2,r2,r3
100009b8:	f800283a 	ret
	float a,hz,z,r,qx;
	__int32_t ix;
	GET_FLOAT_WORD(ix,x);
	ix &= 0x7fffffff;			/* ix = |x|'s high word*/
	if(ix<0x32000000) {			/* if x < 2**27 */
	    if(((int)x)==0) return one;		/* generate inexact */
100009bc:	008fe034 	movhi	r2,16256
	    }
	    hz = (float)0.5*z-qx;
	    a  = one-qx;
	    return a - (hz - (z*r-x*y));
	}
}
100009c0:	f800283a 	ret

100009c4 <__kernel_rem_pio2f>:
	int __kernel_rem_pio2f(float *x, float *y, int e0, int nx, int prec, const __int32_t *ipio2) 
#else
	int __kernel_rem_pio2f(x,y,e0,nx,prec,ipio2) 	
	float x[], y[]; int e0,nx,prec; __int32_t ipio2[];
#endif
{
100009c4:	deff9e04 	addi	sp,sp,-392
100009c8:	dcc05b15 	stw	r19,364(sp)
100009cc:	dcc06217 	ldw	r19,392(sp)
	__int32_t jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
	float z,fw,f[20],fq[20],q[20];

    /* initialize jk*/
	jk = init_jk[prec];
100009d0:	00c40734 	movhi	r3,4124
100009d4:	18db9604 	addi	r3,r3,28248
100009d8:	9cc5883a 	add	r2,r19,r19
100009dc:	1085883a 	add	r2,r2,r2
	int __kernel_rem_pio2f(float *x, float *y, int e0, int nx, int prec, const __int32_t *ipio2) 
#else
	int __kernel_rem_pio2f(x,y,e0,nx,prec,ipio2) 	
	float x[], y[]; int e0,nx,prec; __int32_t ipio2[];
#endif
{
100009e0:	ddc05f15 	stw	r23,380(sp)
100009e4:	dd805e15 	stw	r22,376(sp)
	__int32_t jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
	float z,fw,f[20],fq[20],q[20];

    /* initialize jk*/
	jk = init_jk[prec];
100009e8:	1885883a 	add	r2,r3,r2
	int __kernel_rem_pio2f(float *x, float *y, int e0, int nx, int prec, const __int32_t *ipio2) 
#else
	int __kernel_rem_pio2f(x,y,e0,nx,prec,ipio2) 	
	float x[], y[]; int e0,nx,prec; __int32_t ipio2[];
#endif
{
100009ec:	dfc06115 	stw	ra,388(sp)
100009f0:	df006015 	stw	fp,384(sp)
100009f4:	dd405d15 	stw	r21,372(sp)
100009f8:	dd005c15 	stw	r20,368(sp)
100009fc:	dc805a15 	stw	r18,360(sp)
10000a00:	dc405915 	stw	r17,356(sp)
10000a04:	dc005815 	stw	r16,352(sp)
10000a08:	d9005015 	stw	r4,320(sp)
	jk = init_jk[prec];
	jp = jk;

    /* determine jx,jv,q0, note that 3>q0 */
	jx =  nx-1;
	jv = (e0-3)/8; if(jv<0) jv=0;
10000a0c:	327fff44 	addi	r9,r6,-3
	int __kernel_rem_pio2f(float *x, float *y, int e0, int nx, int prec, const __int32_t *ipio2) 
#else
	int __kernel_rem_pio2f(x,y,e0,nx,prec,ipio2) 	
	float x[], y[]; int e0,nx,prec; __int32_t ipio2[];
#endif
{
10000a10:	282f883a 	mov	r23,r5
	__int32_t jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
	float z,fw,f[20],fq[20],q[20];

    /* initialize jk*/
	jk = init_jk[prec];
10000a14:	15800017 	ldw	r22,0(r2)
	jp = jk;

    /* determine jx,jv,q0, note that 3>q0 */
	jx =  nx-1;
10000a18:	3b3fffc4 	addi	r12,r7,-1
	jv = (e0-3)/8; if(jv<0) jv=0;
10000a1c:	4800010e 	bge	r9,zero,10000a24 <__kernel_rem_pio2f+0x60>
10000a20:	32400104 	addi	r9,r6,4
10000a24:	4813d0fa 	srai	r9,r9,3
10000a28:	4800010e 	bge	r9,zero,10000a30 <__kernel_rem_pio2f+0x6c>
10000a2c:	0013883a 	mov	r9,zero
	q0 =  e0-8*(jv+1);
10000a30:	48800044 	addi	r2,r9,1
10000a34:	100490fa 	slli	r2,r2,3

    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
10000a38:	b317883a 	add	r11,r22,r12
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (float) ipio2[j];
10000a3c:	0007883a 	mov	r3,zero
	jp = jk;

    /* determine jx,jv,q0, note that 3>q0 */
	jx =  nx-1;
	jv = (e0-3)/8; if(jv<0) jv=0;
	q0 =  e0-8*(jv+1);
10000a40:	30a3c83a 	sub	r17,r6,r2
10000a44:	4b0dc83a 	sub	r6,r9,r12
10000a48:	3185883a 	add	r2,r6,r6
10000a4c:	108b883a 	add	r5,r2,r2

    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (float) ipio2[j];
10000a50:	58c01116 	blt	r11,r3,10000a98 <__kernel_rem_pio2f+0xd4>
10000a54:	30c9883a 	add	r4,r6,r3
10000a58:	18c5883a 	add	r2,r3,r3
10000a5c:	20000716 	blt	r4,zero,10000a7c <__kernel_rem_pio2f+0xb8>
10000a60:	da006317 	ldw	r8,396(sp)
10000a64:	1089883a 	add	r4,r2,r2
10000a68:	2149883a 	add	r4,r4,r5
10000a6c:	4109883a 	add	r4,r8,r4
10000a70:	21000017 	ldw	r4,0(r4)
10000a74:	2009feb2 	custom	250,r4,r4,zero
10000a78:	00000106 	br	10000a80 <__kernel_rem_pio2f+0xbc>
10000a7c:	0009883a 	mov	r4,zero
10000a80:	1085883a 	add	r2,r2,r2
10000a84:	da002804 	addi	r8,sp,160
10000a88:	4085883a 	add	r2,r8,r2
10000a8c:	11000015 	stw	r4,0(r2)
10000a90:	18c00044 	addi	r3,r3,1
10000a94:	003fee06 	br	10000a50 <__kernel_rem_pio2f+0x8c>
10000a98:	0007883a 	mov	r3,zero

    /* compute q[0],q[1],...q[jk] */
	for (i=0;i<=jk;i++) {
10000a9c:	b0c01916 	blt	r22,r3,10000b04 <__kernel_rem_pio2f+0x140>
10000aa0:	38c5883a 	add	r2,r7,r3
10000aa4:	dac05017 	ldw	r11,320(sp)
10000aa8:	1085883a 	add	r2,r2,r2
10000aac:	1085883a 	add	r2,r2,r2
10000ab0:	000d883a 	mov	r6,zero
10000ab4:	000b883a 	mov	r5,zero
10000ab8:	0009883a 	mov	r4,zero
10000abc:	31bfff04 	addi	r6,r6,-4
	    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
10000ac0:	61000a16 	blt	r12,r4,10000aec <__kernel_rem_pio2f+0x128>
10000ac4:	309b883a 	add	r13,r6,r2
10000ac8:	da002804 	addi	r8,sp,160
10000acc:	435b883a 	add	r13,r8,r13
10000ad0:	5b800017 	ldw	r14,0(r11)
10000ad4:	6b400017 	ldw	r13,0(r13)
10000ad8:	21000044 	addi	r4,r4,1
10000adc:	5ac00104 	addi	r11,r11,4
10000ae0:	6b9bff32 	custom	252,r13,r13,r14
10000ae4:	2b4bff72 	custom	253,r5,r5,r13
10000ae8:	003ff406 	br	10000abc <__kernel_rem_pio2f+0xf8>
10000aec:	18c5883a 	add	r2,r3,r3
10000af0:	1085883a 	add	r2,r2,r2
10000af4:	d885883a 	add	r2,sp,r2
10000af8:	11400015 	stw	r5,0(r2)
    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (float) ipio2[j];

    /* compute q[0],q[1],...q[jk] */
	for (i=0;i<=jk;i++) {
10000afc:	18c00044 	addi	r3,r3,1
10000b00:	003fe606 	br	10000a9c <__kernel_rem_pio2f+0xd8>
10000b04:	b5a9883a 	add	r20,r22,r22
	z -= (float)8.0*floorf(z*(float)0.125);	/* trim off integer >= 8 */
	n  = (__int32_t) z;
	z -= (float)n;
	ih = 0;
	if(q0>0) {	/* need iq[jz-1] to determine n */
	    i  = (iq[jz-1]>>(8-q0)); n += i;
10000b08:	05400204 	movi	r21,8
	    iq[jz-1] -= i<<(8-q0);
	    ih = iq[jz-1]>>(7-q0);
10000b0c:	008001c4 	movi	r2,7
10000b10:	a529883a 	add	r20,r20,r20
	z -= (float)8.0*floorf(z*(float)0.125);	/* trim off integer >= 8 */
	n  = (__int32_t) z;
	z -= (float)n;
	ih = 0;
	if(q0>0) {	/* need iq[jz-1] to determine n */
	    i  = (iq[jz-1]>>(8-q0)); n += i;
10000b14:	ac6bc83a 	sub	r21,r21,r17
	    iq[jz-1] -= i<<(8-q0);
	    ih = iq[jz-1]>>(7-q0);
10000b18:	1445c83a 	sub	r2,r2,r17
10000b1c:	dd005215 	stw	r20,328(sp)
    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (float) ipio2[j];

    /* compute q[0],q[1],...q[jk] */
	for (i=0;i<=jk;i++) {
10000b20:	b021883a 	mov	r16,r22
	z -= (float)8.0*floorf(z*(float)0.125);	/* trim off integer >= 8 */
	n  = (__int32_t) z;
	z -= (float)n;
	ih = 0;
	if(q0>0) {	/* need iq[jz-1] to determine n */
	    i  = (iq[jz-1]>>(8-q0)); n += i;
10000b24:	dd405115 	stw	r21,324(sp)
	    iq[jz-1] -= i<<(8-q0);
	    ih = iq[jz-1]>>(7-q0);
10000b28:	d8805315 	stw	r2,332(sp)
	}

	jz = jk;
recompute:
    /* distill q[] into iq[] reversingly */
	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
10000b2c:	8429883a 	add	r20,r16,r16
10000b30:	a52b883a 	add	r21,r20,r20
10000b34:	dd45883a 	add	r2,sp,r21
10000b38:	11000017 	ldw	r4,0(r2)
10000b3c:	800d883a 	mov	r6,r16
10000b40:	0180140e 	bge	zero,r6,10000b94 <__kernel_rem_pio2f+0x1d0>
	    fw    =  (float)((__int32_t)(twon8* z));
10000b44:	008ee034 	movhi	r2,15232
10000b48:	2085ff32 	custom	252,r2,r4,r2
	    iq[i] =  (__int32_t)(z-two8*fw);
10000b4c:	32ffff24 	muli	r11,r6,-4

	jz = jk;
recompute:
    /* distill q[] into iq[] reversingly */
	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
	    fw    =  (float)((__int32_t)(twon8* z));
10000b50:	1005fe72 	custom	249,r2,r2,zero
10000b54:	1005feb2 	custom	250,r2,r2,zero
	    iq[i] =  (__int32_t)(z-two8*fw);
10000b58:	0150e034 	movhi	r5,17280
10000b5c:	114bff32 	custom	252,r5,r2,r5
10000b60:	5d57883a 	add	r11,r11,r21
10000b64:	d8c03c04 	addi	r3,sp,240
10000b68:	2149ffb2 	custom	254,r4,r4,r5
10000b6c:	2009fe72 	custom	249,r4,r4,zero
10000b70:	1ad7883a 	add	r11,r3,r11
	    z     =  q[j-1]+fw;
10000b74:	31bfffc4 	addi	r6,r6,-1
	jz = jk;
recompute:
    /* distill q[] into iq[] reversingly */
	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
	    fw    =  (float)((__int32_t)(twon8* z));
	    iq[i] =  (__int32_t)(z-two8*fw);
10000b78:	59000015 	stw	r4,0(r11)
	    z     =  q[j-1]+fw;
10000b7c:	3189883a 	add	r4,r6,r6
10000b80:	2109883a 	add	r4,r4,r4
10000b84:	d909883a 	add	r4,sp,r4
10000b88:	21000017 	ldw	r4,0(r4)
10000b8c:	1109ff72 	custom	253,r4,r2,r4
10000b90:	003feb06 	br	10000b40 <__kernel_rem_pio2f+0x17c>
	}

    /* compute n */
	z  = scalbnf(z,(int)q0);	/* actual value of z */
10000b94:	880b883a 	mov	r5,r17
10000b98:	d9c05715 	stw	r7,348(sp)
10000b9c:	da405615 	stw	r9,344(sp)
10000ba0:	db005515 	stw	r12,340(sp)
10000ba4:	00013140 	call	10001314 <scalbnf>
	z -= (float)8.0*floorf(z*(float)0.125);	/* trim off integer >= 8 */
10000ba8:	010f8034 	movhi	r4,15872
10000bac:	1109ff32 	custom	252,r4,r2,r4
	    iq[i] =  (__int32_t)(z-two8*fw);
	    z     =  q[j-1]+fw;
	}

    /* compute n */
	z  = scalbnf(z,(int)q0);	/* actual value of z */
10000bb0:	1025883a 	mov	r18,r2
	z -= (float)8.0*floorf(z*(float)0.125);	/* trim off integer >= 8 */
10000bb4:	000125c0 	call	1000125c <floorf>
10000bb8:	01904034 	movhi	r6,16640
10000bbc:	1185ff32 	custom	252,r2,r2,r6
10000bc0:	90a5ffb2 	custom	254,r18,r18,r2
	n  = (__int32_t) z;
10000bc4:	9039fe72 	custom	249,fp,r18,zero
	z -= (float)n;
10000bc8:	e00dfeb2 	custom	250,r6,fp,zero
10000bcc:	918dffb2 	custom	254,r6,r18,r6
	ih = 0;
	if(q0>0) {	/* need iq[jz-1] to determine n */
10000bd0:	d9c05717 	ldw	r7,348(sp)
10000bd4:	da405617 	ldw	r9,344(sp)
10000bd8:	db005517 	ldw	r12,340(sp)
10000bdc:	04400f0e 	bge	zero,r17,10000c1c <__kernel_rem_pio2f+0x258>
	    i  = (iq[jz-1]>>(8-q0)); n += i;
10000be0:	80bfffc4 	addi	r2,r16,-1
10000be4:	1085883a 	add	r2,r2,r2
10000be8:	1085883a 	add	r2,r2,r2
10000bec:	d885883a 	add	r2,sp,r2
10000bf0:	10803c04 	addi	r2,r2,240
10000bf4:	11000017 	ldw	r4,0(r2)
10000bf8:	da005117 	ldw	r8,324(sp)
	    iq[jz-1] -= i<<(8-q0);
	    ih = iq[jz-1]>>(7-q0);
10000bfc:	d8c05317 	ldw	r3,332(sp)
	z -= (float)8.0*floorf(z*(float)0.125);	/* trim off integer >= 8 */
	n  = (__int32_t) z;
	z -= (float)n;
	ih = 0;
	if(q0>0) {	/* need iq[jz-1] to determine n */
	    i  = (iq[jz-1]>>(8-q0)); n += i;
10000c00:	2225d83a 	sra	r18,r4,r8
10000c04:	e4b9883a 	add	fp,fp,r18
	    iq[jz-1] -= i<<(8-q0);
10000c08:	9224983a 	sll	r18,r18,r8
10000c0c:	24a5c83a 	sub	r18,r4,r18
10000c10:	14800015 	stw	r18,0(r2)
	    ih = iq[jz-1]>>(7-q0);
10000c14:	90e5d83a 	sra	r18,r18,r3
10000c18:	00000d06 	br	10000c50 <__kernel_rem_pio2f+0x28c>
	} 
	else if(q0==0) ih = iq[jz-1]>>8;
10000c1c:	8800071e 	bne	r17,zero,10000c3c <__kernel_rem_pio2f+0x278>
10000c20:	80bfffc4 	addi	r2,r16,-1
10000c24:	1085883a 	add	r2,r2,r2
10000c28:	1085883a 	add	r2,r2,r2
10000c2c:	d885883a 	add	r2,sp,r2
10000c30:	14803c17 	ldw	r18,240(r2)
10000c34:	9025d23a 	srai	r18,r18,8
10000c38:	00000506 	br	10000c50 <__kernel_rem_pio2f+0x28c>
	else if(z>=(float)0.5) ih=2;
10000c3c:	008fc034 	movhi	r2,16128
10000c40:	3085f932 	custom	228,r2,r6,r2
10000c44:	1000041e 	bne	r2,zero,10000c58 <__kernel_rem_pio2f+0x294>
    /* compute n */
	z  = scalbnf(z,(int)q0);	/* actual value of z */
	z -= (float)8.0*floorf(z*(float)0.125);	/* trim off integer >= 8 */
	n  = (__int32_t) z;
	z -= (float)n;
	ih = 0;
10000c48:	0025883a 	mov	r18,zero
10000c4c:	00003a06 	br	10000d38 <__kernel_rem_pio2f+0x374>
	    ih = iq[jz-1]>>(7-q0);
	} 
	else if(q0==0) ih = iq[jz-1]>>8;
	else if(z>=(float)0.5) ih=2;

	if(ih>0) {	/* q > 0.5 */
10000c50:	04800216 	blt	zero,r18,10000c5c <__kernel_rem_pio2f+0x298>
10000c54:	00003806 	br	10000d38 <__kernel_rem_pio2f+0x374>
	    i  = (iq[jz-1]>>(8-q0)); n += i;
	    iq[jz-1] -= i<<(8-q0);
	    ih = iq[jz-1]>>(7-q0);
	} 
	else if(q0==0) ih = iq[jz-1]>>8;
	else if(z>=(float)0.5) ih=2;
10000c58:	04800084 	movi	r18,2

	if(ih>0) {	/* q > 0.5 */
	    n += 1; carry = 0;
10000c5c:	e7000044 	addi	fp,fp,1
10000c60:	d9003c04 	addi	r4,sp,240
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
10000c64:	001d883a 	mov	r14,zero
	} 
	else if(q0==0) ih = iq[jz-1]>>8;
	else if(z>=(float)0.5) ih=2;

	if(ih>0) {	/* q > 0.5 */
	    n += 1; carry = 0;
10000c68:	000b883a 	mov	r5,zero
		j = iq[i];
		if(carry==0) {
		    if(j!=0) {
			carry = 1; iq[i] = 0x100- j;
		    }
		} else  iq[i] = 0xff - j;
10000c6c:	03c03fc4 	movi	r15,255
	    n += 1; carry = 0;
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
		j = iq[i];
		if(carry==0) {
		    if(j!=0) {
			carry = 1; iq[i] = 0x100- j;
10000c70:	07c04004 	movi	ra,256
	else if(q0==0) ih = iq[jz-1]>>8;
	else if(z>=(float)0.5) ih=2;

	if(ih>0) {	/* q > 0.5 */
	    n += 1; carry = 0;
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
10000c74:	74000b0e 	bge	r14,r16,10000ca4 <__kernel_rem_pio2f+0x2e0>
		j = iq[i];
10000c78:	20800017 	ldw	r2,0(r4)
		if(carry==0) {
10000c7c:	2800031e 	bne	r5,zero,10000c8c <__kernel_rem_pio2f+0x2c8>
		    if(j!=0) {
10000c80:	10000526 	beq	r2,zero,10000c98 <__kernel_rem_pio2f+0x2d4>
			carry = 1; iq[i] = 0x100- j;
10000c84:	f885c83a 	sub	r2,ra,r2
10000c88:	00000106 	br	10000c90 <__kernel_rem_pio2f+0x2cc>
		    }
		} else  iq[i] = 0xff - j;
10000c8c:	7885c83a 	sub	r2,r15,r2
10000c90:	20800015 	stw	r2,0(r4)
10000c94:	01400044 	movi	r5,1
	else if(q0==0) ih = iq[jz-1]>>8;
	else if(z>=(float)0.5) ih=2;

	if(ih>0) {	/* q > 0.5 */
	    n += 1; carry = 0;
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
10000c98:	73800044 	addi	r14,r14,1
10000c9c:	21000104 	addi	r4,r4,4
10000ca0:	003ff406 	br	10000c74 <__kernel_rem_pio2f+0x2b0>
		    if(j!=0) {
			carry = 1; iq[i] = 0x100- j;
		    }
		} else  iq[i] = 0xff - j;
	    }
	    if(q0>0) {		/* rare case: chance is 1 in 12 */
10000ca4:	0440140e 	bge	zero,r17,10000cf8 <__kernel_rem_pio2f+0x334>
	        switch(q0) {
10000ca8:	00800044 	movi	r2,1
10000cac:	88800a26 	beq	r17,r2,10000cd8 <__kernel_rem_pio2f+0x314>
10000cb0:	00800084 	movi	r2,2
10000cb4:	8880101e 	bne	r17,r2,10000cf8 <__kernel_rem_pio2f+0x334>
	        case 1:
	    	   iq[jz-1] &= 0x7f; break;
	    	case 2:
	    	   iq[jz-1] &= 0x3f; break;
10000cb8:	80bfffc4 	addi	r2,r16,-1
10000cbc:	1085883a 	add	r2,r2,r2
10000cc0:	1085883a 	add	r2,r2,r2
10000cc4:	d885883a 	add	r2,sp,r2
10000cc8:	10803c04 	addi	r2,r2,240
10000ccc:	11000017 	ldw	r4,0(r2)
10000cd0:	21000fcc 	andi	r4,r4,63
10000cd4:	00000706 	br	10000cf4 <__kernel_rem_pio2f+0x330>
		} else  iq[i] = 0xff - j;
	    }
	    if(q0>0) {		/* rare case: chance is 1 in 12 */
	        switch(q0) {
	        case 1:
	    	   iq[jz-1] &= 0x7f; break;
10000cd8:	80bfffc4 	addi	r2,r16,-1
10000cdc:	1085883a 	add	r2,r2,r2
10000ce0:	1085883a 	add	r2,r2,r2
10000ce4:	d885883a 	add	r2,sp,r2
10000ce8:	10803c04 	addi	r2,r2,240
10000cec:	11000017 	ldw	r4,0(r2)
10000cf0:	21001fcc 	andi	r4,r4,127
	    	case 2:
	    	   iq[jz-1] &= 0x3f; break;
10000cf4:	11000015 	stw	r4,0(r2)
	        }
	    }
	    if(ih==2) {
10000cf8:	00800084 	movi	r2,2
10000cfc:	90800e1e 	bne	r18,r2,10000d38 <__kernel_rem_pio2f+0x374>
		z = one - z;
10000d00:	010fe034 	movhi	r4,16256
10000d04:	218dffb2 	custom	254,r6,r4,r6
		if(carry!=0) z -= scalbnf(one,(int)q0);
10000d08:	28000b26 	beq	r5,zero,10000d38 <__kernel_rem_pio2f+0x374>
10000d0c:	880b883a 	mov	r5,r17
10000d10:	d9805415 	stw	r6,336(sp)
10000d14:	d9c05715 	stw	r7,348(sp)
10000d18:	da405615 	stw	r9,344(sp)
10000d1c:	db005515 	stw	r12,340(sp)
10000d20:	00013140 	call	10001314 <scalbnf>
10000d24:	d9805417 	ldw	r6,336(sp)
10000d28:	db005517 	ldw	r12,340(sp)
10000d2c:	da405617 	ldw	r9,344(sp)
10000d30:	d9c05717 	ldw	r7,348(sp)
10000d34:	308dffb2 	custom	254,r6,r6,r2
	    }
	}

    /* check if recomputation is needed */
	if(z==zero) {
10000d38:	0005883a 	mov	r2,zero
10000d3c:	3085f8b2 	custom	226,r2,r6,r2
10000d40:	10004a1e 	bne	r2,zero,10000e6c <__kernel_rem_pio2f+0x4a8>
	    j = 0;
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
10000d44:	817fffc4 	addi	r5,r16,-1
10000d48:	8007883a 	mov	r3,r16
	    }
	}

    /* check if recomputation is needed */
	if(z==zero) {
	    j = 0;
10000d4c:	0009883a 	mov	r4,zero
10000d50:	18ffffc4 	addi	r3,r3,-1
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
10000d54:	1d800716 	blt	r3,r22,10000d74 <__kernel_rem_pio2f+0x3b0>
10000d58:	18c5883a 	add	r2,r3,r3
10000d5c:	1085883a 	add	r2,r2,r2
10000d60:	d9803c04 	addi	r6,sp,240
10000d64:	3085883a 	add	r2,r6,r2
10000d68:	10800017 	ldw	r2,0(r2)
10000d6c:	2088b03a 	or	r4,r4,r2
10000d70:	003ff706 	br	10000d50 <__kernel_rem_pio2f+0x38c>
	    if(j==0) { /* need recomputation */
10000d74:	2000321e 	bne	r4,zero,10000e40 <__kernel_rem_pio2f+0x47c>
10000d78:	01400044 	movi	r5,1
		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */
10000d7c:	28bfff24 	muli	r2,r5,-4
10000d80:	da005217 	ldw	r8,328(sp)
10000d84:	d8c03c04 	addi	r3,sp,240
10000d88:	1205883a 	add	r2,r2,r8
10000d8c:	1885883a 	add	r2,r3,r2
10000d90:	10800017 	ldw	r2,0(r2)
10000d94:	1000021e 	bne	r2,zero,10000da0 <__kernel_rem_pio2f+0x3dc>
10000d98:	29400044 	addi	r5,r5,1
10000d9c:	003ff706 	br	10000d7c <__kernel_rem_pio2f+0x3b8>
10000da0:	4c05883a 	add	r2,r9,r16
10000da4:	3c07883a 	add	r3,r7,r16
10000da8:	1085883a 	add	r2,r2,r2
10000dac:	18c7883a 	add	r3,r3,r3

		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
10000db0:	82c00044 	addi	r11,r16,1
10000db4:	1085883a 	add	r2,r2,r2
10000db8:	18c7883a 	add	r3,r3,r3
10000dbc:	0009883a 	mov	r4,zero
10000dc0:	8161883a 	add	r16,r16,r5
10000dc4:	82ff5916 	blt	r16,r11,10000b2c <__kernel_rem_pio2f+0x168>
		    f[jx+i] = (float) ipio2[jv+i];
10000dc8:	da006317 	ldw	r8,396(sp)
10000dcc:	d9402804 	addi	r5,sp,160
10000dd0:	20e5883a 	add	r18,r4,r3
10000dd4:	2c8d883a 	add	r6,r5,r18
10000dd8:	208b883a 	add	r5,r4,r2
10000ddc:	414b883a 	add	r5,r8,r5
10000de0:	29400117 	ldw	r5,4(r5)
10000de4:	dbc05017 	ldw	r15,320(sp)
		    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
10000de8:	001d883a 	mov	r14,zero
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
	    if(j==0) { /* need recomputation */
		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */

		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
		    f[jx+i] = (float) ipio2[jv+i];
10000dec:	280bfeb2 	custom	250,r5,r5,zero
10000df0:	31400015 	stw	r5,0(r6)
		    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
10000df4:	000d883a 	mov	r6,zero
10000df8:	61800b16 	blt	r12,r6,10000e28 <__kernel_rem_pio2f+0x464>
10000dfc:	317fff24 	muli	r5,r6,-4
10000e00:	da002804 	addi	r8,sp,160
10000e04:	7fc00017 	ldw	ra,0(r15)
10000e08:	2c8b883a 	add	r5,r5,r18
10000e0c:	414b883a 	add	r5,r8,r5
10000e10:	29400017 	ldw	r5,0(r5)
10000e14:	31800044 	addi	r6,r6,1
10000e18:	7bc00104 	addi	r15,r15,4
10000e1c:	2fcbff32 	custom	252,r5,r5,ra
10000e20:	715dff72 	custom	253,r14,r14,r5
10000e24:	003ff406 	br	10000df8 <__kernel_rem_pio2f+0x434>
		    q[i] = fw;
10000e28:	254b883a 	add	r5,r4,r21
10000e2c:	d94b883a 	add	r5,sp,r5
10000e30:	2b800115 	stw	r14,4(r5)
	    j = 0;
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
	    if(j==0) { /* need recomputation */
		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */

		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
10000e34:	5ac00044 	addi	r11,r11,1
10000e38:	21000104 	addi	r4,r4,4
10000e3c:	003fe106 	br	10000dc4 <__kernel_rem_pio2f+0x400>
	    }
	}

    /* chop off zero terms */
	if(z==(float)0.0) {
	    jz -= 1; q0 -= 8;
10000e40:	8c7ffe04 	addi	r17,r17,-8
	}

    /* check if recomputation is needed */
	if(z==zero) {
	    j = 0;
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
10000e44:	2821883a 	mov	r16,r5
	}

    /* chop off zero terms */
	if(z==(float)0.0) {
	    jz -= 1; q0 -= 8;
	    while(iq[jz]==0) { jz--; q0-=8;}
10000e48:	8405883a 	add	r2,r16,r16
10000e4c:	1085883a 	add	r2,r2,r2
10000e50:	d8c03c04 	addi	r3,sp,240
10000e54:	1885883a 	add	r2,r3,r2
10000e58:	10800017 	ldw	r2,0(r2)
10000e5c:	10001f1e 	bne	r2,zero,10000edc <__kernel_rem_pio2f+0x518>
10000e60:	843fffc4 	addi	r16,r16,-1
10000e64:	8c7ffe04 	addi	r17,r17,-8
10000e68:	003ff706 	br	10000e48 <__kernel_rem_pio2f+0x484>
	} else { /* break z into 8-bit if necessary */
	    z = scalbnf(z,-(int)q0);
10000e6c:	044bc83a 	sub	r5,zero,r17
10000e70:	3009883a 	mov	r4,r6
10000e74:	00013140 	call	10001314 <scalbnf>
	    if(z>=two8) { 
10000e78:	0150e034 	movhi	r5,17280
10000e7c:	1149f932 	custom	228,r4,r2,r5
10000e80:	20001226 	beq	r4,zero,10000ecc <__kernel_rem_pio2f+0x508>
		fw = (float)((__int32_t)(twon8*z));
10000e84:	010ee034 	movhi	r4,15232
10000e88:	1109ff32 	custom	252,r4,r2,r4
10000e8c:	2009fe72 	custom	249,r4,r4,zero
10000e90:	2009feb2 	custom	250,r4,r4,zero
		iq[jz] = (__int32_t)(z-two8*fw);
10000e94:	214bff32 	custom	252,r5,r4,r5
10000e98:	a507883a 	add	r3,r20,r20
10000e9c:	1145ffb2 	custom	254,r2,r2,r5
10000ea0:	1005fe72 	custom	249,r2,r2,zero
10000ea4:	d8c7883a 	add	r3,sp,r3
		jz += 1; q0 += 8;
10000ea8:	84000044 	addi	r16,r16,1
	    while(iq[jz]==0) { jz--; q0-=8;}
	} else { /* break z into 8-bit if necessary */
	    z = scalbnf(z,-(int)q0);
	    if(z>=two8) { 
		fw = (float)((__int32_t)(twon8*z));
		iq[jz] = (__int32_t)(z-two8*fw);
10000eac:	18803c15 	stw	r2,240(r3)
		jz += 1; q0 += 8;
		iq[jz] = (__int32_t) fw;
10000eb0:	8405883a 	add	r2,r16,r16
10000eb4:	1085883a 	add	r2,r2,r2
10000eb8:	d885883a 	add	r2,sp,r2
10000ebc:	2009fe72 	custom	249,r4,r4,zero
	} else { /* break z into 8-bit if necessary */
	    z = scalbnf(z,-(int)q0);
	    if(z>=two8) { 
		fw = (float)((__int32_t)(twon8*z));
		iq[jz] = (__int32_t)(z-two8*fw);
		jz += 1; q0 += 8;
10000ec0:	8c400204 	addi	r17,r17,8
		iq[jz] = (__int32_t) fw;
10000ec4:	11003c15 	stw	r4,240(r2)
10000ec8:	00000406 	br	10000edc <__kernel_rem_pio2f+0x518>
	    } else iq[jz] = (__int32_t) z ;
10000ecc:	a507883a 	add	r3,r20,r20
10000ed0:	d8c7883a 	add	r3,sp,r3
10000ed4:	1005fe72 	custom	249,r2,r2,zero
10000ed8:	18803c15 	stw	r2,240(r3)
	}

    /* convert integer "bit" chunk to floating-point value */
	fw = scalbnf(one,(int)q0);
10000edc:	880b883a 	mov	r5,r17
10000ee0:	010fe034 	movhi	r4,16256
10000ee4:	00013140 	call	10001314 <scalbnf>
10000ee8:	8407883a 	add	r3,r16,r16
10000eec:	18c7883a 	add	r3,r3,r3
	for(i=jz;i>=0;i--) {
10000ef0:	800b883a 	mov	r5,r16
10000ef4:	000d883a 	mov	r6,zero
10000ef8:	28000d16 	blt	r5,zero,10000f30 <__kernel_rem_pio2f+0x56c>
	    q[i] = fw*(float)iq[i]; fw*=twon8;
10000efc:	30c9883a 	add	r4,r6,r3
10000f00:	da003c04 	addi	r8,sp,240
10000f04:	d90f883a 	add	r7,sp,r4
10000f08:	4109883a 	add	r4,r8,r4
10000f0c:	21000017 	ldw	r4,0(r4)
	    } else iq[jz] = (__int32_t) z ;
	}

    /* convert integer "bit" chunk to floating-point value */
	fw = scalbnf(one,(int)q0);
	for(i=jz;i>=0;i--) {
10000f10:	297fffc4 	addi	r5,r5,-1
10000f14:	31bfff04 	addi	r6,r6,-4
	    q[i] = fw*(float)iq[i]; fw*=twon8;
10000f18:	2009feb2 	custom	250,r4,r4,zero
10000f1c:	2089ff32 	custom	252,r4,r4,r2
10000f20:	39000015 	stw	r4,0(r7)
10000f24:	010ee034 	movhi	r4,15232
10000f28:	1105ff32 	custom	252,r2,r2,r4
10000f2c:	003ff206 	br	10000ef8 <__kernel_rem_pio2f+0x534>
	}

    /* compute PIo2[0,...,jp]*q[jz,...,0] */
	for(i=jz;i>=0;i--) {
	    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
10000f30:	03040734 	movhi	r12,4124
10000f34:	000d883a 	mov	r6,zero
10000f38:	631b8b04 	addi	r12,r12,28204
10000f3c:	8185c83a 	sub	r2,r16,r6
	for(i=jz;i>=0;i--) {
	    q[i] = fw*(float)iq[i]; fw*=twon8;
	}

    /* compute PIo2[0,...,jp]*q[jz,...,0] */
	for(i=jz;i>=0;i--) {
10000f40:	10001816 	blt	r2,zero,10000fa4 <__kernel_rem_pio2f+0x5e0>
10000f44:	1085883a 	add	r2,r2,r2
10000f48:	1085883a 	add	r2,r2,r2
10000f4c:	000f883a 	mov	r7,zero
10000f50:	000b883a 	mov	r5,zero
	    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
10000f54:	b1400c16 	blt	r22,r5,10000f88 <__kernel_rem_pio2f+0x5c4>
10000f58:	31400b16 	blt	r6,r5,10000f88 <__kernel_rem_pio2f+0x5c4>
10000f5c:	2949883a 	add	r4,r5,r5
10000f60:	2109883a 	add	r4,r4,r4
10000f64:	2093883a 	add	r9,r4,r2
10000f68:	da53883a 	add	r9,sp,r9
10000f6c:	2309883a 	add	r4,r4,r12
10000f70:	4a400017 	ldw	r9,0(r9)
10000f74:	21000017 	ldw	r4,0(r4)
10000f78:	29400044 	addi	r5,r5,1
10000f7c:	4909ff32 	custom	252,r4,r9,r4
10000f80:	390fff72 	custom	253,r7,r7,r4
10000f84:	003ff306 	br	10000f54 <__kernel_rem_pio2f+0x590>
	    fq[jz-i] = fw;
10000f88:	3185883a 	add	r2,r6,r6
10000f8c:	1085883a 	add	r2,r2,r2
10000f90:	d9001404 	addi	r4,sp,80
10000f94:	2085883a 	add	r2,r4,r2
10000f98:	11c00015 	stw	r7,0(r2)
10000f9c:	31800044 	addi	r6,r6,1
10000fa0:	003fe606 	br	10000f3c <__kernel_rem_pio2f+0x578>
	}

    /* compress fq[] into y[] */
	switch(prec) {
10000fa4:	00800084 	movi	r2,2
10000fa8:	14c00416 	blt	r2,r19,10000fbc <__kernel_rem_pio2f+0x5f8>
10000fac:	04c00a16 	blt	zero,r19,10000fd8 <__kernel_rem_pio2f+0x614>
10000fb0:	9800671e 	bne	r19,zero,10001150 <__kernel_rem_pio2f+0x78c>
10000fb4:	0005883a 	mov	r2,zero
10000fb8:	00000a06 	br	10000fe4 <__kernel_rem_pio2f+0x620>
10000fbc:	008000c4 	movi	r2,3
10000fc0:	9880631e 	bne	r19,r2,10001150 <__kernel_rem_pio2f+0x78c>
10000fc4:	d9401404 	addi	r5,sp,80
10000fc8:	28c5883a 	add	r2,r5,r3
10000fcc:	1007883a 	mov	r3,r2
10000fd0:	800b883a 	mov	r5,r16
10000fd4:	00002e06 	br	10001090 <__kernel_rem_pio2f+0x6cc>
10000fd8:	8005883a 	mov	r2,r16
10000fdc:	0009883a 	mov	r4,zero
10000fe0:	00000d06 	br	10001018 <__kernel_rem_pio2f+0x654>
	    case 0:
		fw = 0.0;
		for (i=jz;i>=0;i--) fw += fq[i];
10000fe4:	80000816 	blt	r16,zero,10001008 <__kernel_rem_pio2f+0x644>
10000fe8:	8407883a 	add	r3,r16,r16
10000fec:	18c7883a 	add	r3,r3,r3
10000ff0:	d9801404 	addi	r6,sp,80
10000ff4:	30c7883a 	add	r3,r6,r3
10000ff8:	18c00017 	ldw	r3,0(r3)
10000ffc:	843fffc4 	addi	r16,r16,-1
10001000:	10c5ff72 	custom	253,r2,r2,r3
10001004:	003ff706 	br	10000fe4 <__kernel_rem_pio2f+0x620>
		y[0] = (ih==0)? fw: -fw; 
10001008:	90000126 	beq	r18,zero,10001010 <__kernel_rem_pio2f+0x64c>
1000100c:	1005f872 	custom	225,r2,r2,zero
10001010:	b8800015 	stw	r2,0(r23)
		break;
10001014:	00004e06 	br	10001150 <__kernel_rem_pio2f+0x78c>
	    case 1:
	    case 2:
		fw = 0.0;
		for (i=jz;i>=0;i--) fw += fq[i]; 
10001018:	10000816 	blt	r2,zero,1000103c <__kernel_rem_pio2f+0x678>
1000101c:	1087883a 	add	r3,r2,r2
10001020:	18c7883a 	add	r3,r3,r3
10001024:	da001404 	addi	r8,sp,80
10001028:	40c7883a 	add	r3,r8,r3
1000102c:	18c00017 	ldw	r3,0(r3)
10001030:	10bfffc4 	addi	r2,r2,-1
10001034:	20c9ff72 	custom	253,r4,r4,r3
10001038:	003ff706 	br	10001018 <__kernel_rem_pio2f+0x654>
		y[0] = (ih==0)? fw: -fw; 
1000103c:	90000226 	beq	r18,zero,10001048 <__kernel_rem_pio2f+0x684>
10001040:	2005f872 	custom	225,r2,r4,zero
10001044:	00000106 	br	1000104c <__kernel_rem_pio2f+0x688>
10001048:	2005883a 	mov	r2,r4
1000104c:	b8800015 	stw	r2,0(r23)
		fw = fq[0]-fw;
10001050:	d8801417 	ldw	r2,80(sp)
10001054:	1105ffb2 	custom	254,r2,r2,r4
		for (i=1;i<=jz;i++) fw += fq[i];
10001058:	01000044 	movi	r4,1
1000105c:	81000816 	blt	r16,r4,10001080 <__kernel_rem_pio2f+0x6bc>
10001060:	2107883a 	add	r3,r4,r4
10001064:	18c7883a 	add	r3,r3,r3
10001068:	d9401404 	addi	r5,sp,80
1000106c:	28c7883a 	add	r3,r5,r3
10001070:	18c00017 	ldw	r3,0(r3)
10001074:	21000044 	addi	r4,r4,1
10001078:	10c5ff72 	custom	253,r2,r2,r3
1000107c:	003ff706 	br	1000105c <__kernel_rem_pio2f+0x698>
		y[1] = (ih==0)? fw: -fw; 
10001080:	90000126 	beq	r18,zero,10001088 <__kernel_rem_pio2f+0x6c4>
10001084:	1005f872 	custom	225,r2,r2,zero
10001088:	b8800115 	stw	r2,4(r23)
		break;
1000108c:	00003006 	br	10001150 <__kernel_rem_pio2f+0x78c>
10001090:	18ffff04 	addi	r3,r3,-4
	    case 3:	/* painful */
		for (i=jz;i>0;i--) {
10001094:	0140090e 	bge	zero,r5,100010bc <__kernel_rem_pio2f+0x6f8>
		    fw      = fq[i-1]+fq[i]; 
10001098:	19000017 	ldw	r4,0(r3)
1000109c:	19c00117 	ldw	r7,4(r3)
100010a0:	297fffc4 	addi	r5,r5,-1
100010a4:	21cdff72 	custom	253,r6,r4,r7
		    fq[i]  += fq[i-1]-fw;
100010a8:	2189ffb2 	custom	254,r4,r4,r6
100010ac:	21c9ff72 	custom	253,r4,r4,r7
100010b0:	19000115 	stw	r4,4(r3)
		    fq[i-1] = fw;
100010b4:	19800015 	stw	r6,0(r3)
100010b8:	003ff506 	br	10001090 <__kernel_rem_pio2f+0x6cc>
100010bc:	8009883a 	mov	r4,r16
		}
		for (i=jz;i>1;i--) {
100010c0:	01c00044 	movi	r7,1
100010c4:	10bfff04 	addi	r2,r2,-4
100010c8:	3900090e 	bge	r7,r4,100010f0 <__kernel_rem_pio2f+0x72c>
		    fw      = fq[i-1]+fq[i]; 
100010cc:	10c00017 	ldw	r3,0(r2)
100010d0:	11800117 	ldw	r6,4(r2)
100010d4:	213fffc4 	addi	r4,r4,-1
100010d8:	198bff72 	custom	253,r5,r3,r6
		    fq[i]  += fq[i-1]-fw;
100010dc:	1947ffb2 	custom	254,r3,r3,r5
100010e0:	1987ff72 	custom	253,r3,r3,r6
100010e4:	10c00115 	stw	r3,4(r2)
		    fq[i-1] = fw;
100010e8:	11400015 	stw	r5,0(r2)
100010ec:	003ff506 	br	100010c4 <__kernel_rem_pio2f+0x700>
100010f0:	0005883a 	mov	r2,zero
		}
		for (fw=0.0,i=jz;i>=2;i--) fw += fq[i]; 
100010f4:	01000044 	movi	r4,1
100010f8:	2400080e 	bge	r4,r16,1000111c <__kernel_rem_pio2f+0x758>
100010fc:	8407883a 	add	r3,r16,r16
10001100:	18c7883a 	add	r3,r3,r3
10001104:	d9801404 	addi	r6,sp,80
10001108:	30c7883a 	add	r3,r6,r3
1000110c:	18c00017 	ldw	r3,0(r3)
10001110:	843fffc4 	addi	r16,r16,-1
10001114:	10c5ff72 	custom	253,r2,r2,r3
10001118:	003ff706 	br	100010f8 <__kernel_rem_pio2f+0x734>
		if(ih==0) {
		    y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;
1000111c:	d8c01417 	ldw	r3,80(sp)
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (fw=0.0,i=jz;i>=2;i--) fw += fq[i]; 
		if(ih==0) {
10001120:	9000041e 	bne	r18,zero,10001134 <__kernel_rem_pio2f+0x770>
		    y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;
10001124:	b8c00015 	stw	r3,0(r23)
10001128:	d8c01517 	ldw	r3,84(sp)
1000112c:	b8c00115 	stw	r3,4(r23)
10001130:	00000606 	br	1000114c <__kernel_rem_pio2f+0x788>
		} else {
		    y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;
10001134:	1807f872 	custom	225,r3,r3,zero
10001138:	b8c00015 	stw	r3,0(r23)
1000113c:	d8c01517 	ldw	r3,84(sp)
10001140:	1005f872 	custom	225,r2,r2,zero
10001144:	1807f872 	custom	225,r3,r3,zero
10001148:	b8c00115 	stw	r3,4(r23)
1000114c:	b8800215 	stw	r2,8(r23)
		}
	}
	return n&7;
}
10001150:	e08001cc 	andi	r2,fp,7
10001154:	dfc06117 	ldw	ra,388(sp)
10001158:	df006017 	ldw	fp,384(sp)
1000115c:	ddc05f17 	ldw	r23,380(sp)
10001160:	dd805e17 	ldw	r22,376(sp)
10001164:	dd405d17 	ldw	r21,372(sp)
10001168:	dd005c17 	ldw	r20,368(sp)
1000116c:	dcc05b17 	ldw	r19,364(sp)
10001170:	dc805a17 	ldw	r18,360(sp)
10001174:	dc405917 	ldw	r17,356(sp)
10001178:	dc005817 	ldw	r16,352(sp)
1000117c:	dec06204 	addi	sp,sp,392
10001180:	f800283a 	ret

10001184 <__kernel_sinf>:
{
	float z,r,v;
	__int32_t ix;
	GET_FLOAT_WORD(ix,x);
	ix &= 0x7fffffff;			/* high word of x */
	if(ix<0x32000000)			/* |x| < 2**-27 */
10001184:	01e00034 	movhi	r7,32768
10001188:	39ffffc4 	addi	r7,r7,-1
1000118c:	008c8034 	movhi	r2,12800
10001190:	390e703a 	and	r7,r7,r4
10001194:	10bfffc4 	addi	r2,r2,-1
10001198:	11c00216 	blt	r2,r7,100011a4 <__kernel_sinf+0x20>
	   {if((int)x==0) return x;}		/* generate inexact */
1000119c:	2005fe72 	custom	249,r2,r4,zero
100011a0:	10002826 	beq	r2,zero,10001244 <__kernel_sinf+0xc0>
	z	=  x*x;
	v	=  z*x;
	r	=  S2+z*(S3+z*(S4+z*(S5+z*S6)));
100011a4:	00cbcbf4 	movhi	r3,12079
	__int32_t ix;
	GET_FLOAT_WORD(ix,x);
	ix &= 0x7fffffff;			/* high word of x */
	if(ix<0x32000000)			/* |x| < 2**-27 */
	   {if((int)x==0) return x;}		/* generate inexact */
	z	=  x*x;
100011a8:	2111ff32 	custom	252,r8,r4,r4
	v	=  z*x;
	r	=  S2+z*(S3+z*(S4+z*(S5+z*S6)));
100011ac:	18f274c4 	addi	r3,r3,-13869
100011b0:	01ccb5f4 	movhi	r7,13015
100011b4:	40c7ff32 	custom	252,r3,r8,r3
100011b8:	39cbcd04 	addi	r7,r7,12084
100011bc:	19cfffb2 	custom	254,r7,r3,r7
100011c0:	028d8e74 	movhi	r10,13881
100011c4:	52bbc6c4 	addi	r10,r10,-4325
100011c8:	3a0fff32 	custom	252,r7,r7,r8
100011cc:	3a8fff72 	custom	253,r7,r7,r10
100011d0:	028e5434 	movhi	r10,14672
100011d4:	52834044 	addi	r10,r10,3329
100011d8:	3a0fff32 	custom	252,r7,r7,r8
100011dc:	3a8fffb2 	custom	254,r7,r7,r10
100011e0:	028f0274 	movhi	r10,15369
100011e4:	3a0fff32 	custom	252,r7,r7,r8
100011e8:	52a22244 	addi	r10,r10,-30583
	GET_FLOAT_WORD(ix,x);
	ix &= 0x7fffffff;			/* high word of x */
	if(ix<0x32000000)			/* |x| < 2**-27 */
	   {if((int)x==0) return x;}		/* generate inexact */
	z	=  x*x;
	v	=  z*x;
100011ec:	2213ff32 	custom	252,r9,r4,r8
	r	=  S2+z*(S3+z*(S4+z*(S5+z*S6)));
100011f0:	3a87ff72 	custom	253,r3,r7,r10
	if(iy==0) return x+v*(S1+z*r);
100011f4:	3000071e 	bne	r6,zero,10001214 <__kernel_sinf+0x90>
100011f8:	40d1ff32 	custom	252,r8,r8,r3
100011fc:	00cf8af4 	movhi	r3,15915
10001200:	18eaaac4 	addi	r3,r3,-21845
10001204:	40d1ffb2 	custom	254,r8,r8,r3
10001208:	4247ff32 	custom	252,r3,r8,r9
1000120c:	1905ff72 	custom	253,r2,r3,r4
10001210:	f800283a 	ret
	else      return x-((z*(half*y-v*r)-y)-v*S1);
10001214:	018fc034 	movhi	r6,16128
10001218:	298dff32 	custom	252,r6,r5,r6
1000121c:	48c7ff32 	custom	252,r3,r9,r3
10001220:	30c7ffb2 	custom	254,r3,r6,r3
10001224:	1a11ff32 	custom	252,r8,r3,r8
10001228:	00cf8af4 	movhi	r3,15915
1000122c:	18eaaac4 	addi	r3,r3,-21845
10001230:	414bffb2 	custom	254,r5,r8,r5
10001234:	48c7ff32 	custom	252,r3,r9,r3
10001238:	28c7ff72 	custom	253,r3,r5,r3
1000123c:	20c5ffb2 	custom	254,r2,r4,r3
10001240:	f800283a 	ret
	float z,r,v;
	__int32_t ix;
	GET_FLOAT_WORD(ix,x);
	ix &= 0x7fffffff;			/* high word of x */
	if(ix<0x32000000)			/* |x| < 2**-27 */
	   {if((int)x==0) return x;}		/* generate inexact */
10001244:	2005883a 	mov	r2,r4
	z	=  x*x;
	v	=  z*x;
	r	=  S2+z*(S3+z*(S4+z*(S5+z*S6)));
	if(iy==0) return x+v*(S1+z*r);
	else      return x-((z*(half*y-v*r)-y)-v*S1);
}
10001248:	f800283a 	ret

1000124c <fabsf>:
{
	__uint32_t ix;
	GET_FLOAT_WORD(ix,x);
	SET_FLOAT_WORD(x,ix&0x7fffffff);
        return x;
}
1000124c:	00a00034 	movhi	r2,32768
10001250:	10bfffc4 	addi	r2,r2,-1
10001254:	2084703a 	and	r2,r4,r2
10001258:	f800283a 	ret

1000125c <floorf>:
#endif
{
	__int32_t i0,j0;
	__uint32_t i,ix;
	GET_FLOAT_WORD(i0,x);
	ix = (i0&0x7fffffff);
1000125c:	01600034 	movhi	r5,32768
10001260:	297fffc4 	addi	r5,r5,-1
10001264:	290a703a 	and	r5,r5,r4
	j0 = (ix>>23)-0x7f;
10001268:	2804d5fa 	srli	r2,r5,23
1000126c:	11bfe044 	addi	r6,r2,-127
	if(j0<23) {
10001270:	00800584 	movi	r2,22
10001274:	11801e16 	blt	r2,r6,100012f0 <floorf+0x94>
	float x;
#endif
{
	__int32_t i0,j0;
	__uint32_t i,ix;
	GET_FLOAT_WORD(i0,x);
10001278:	2005883a 	mov	r2,r4
	ix = (i0&0x7fffffff);
	j0 = (ix>>23)-0x7f;
	if(j0<23) {
	    if(j0<0) { 	/* raise inexact if x != 0 */
1000127c:	30000a0e 	bge	r6,zero,100012a8 <floorf+0x4c>
		if(huge+x>(float)0.0) {/* return 0*sign(x) if |x|<1 */
10001280:	00dc52b4 	movhi	r3,29002
10001284:	18fcb284 	addi	r3,r3,-3382
10001288:	20c7ff72 	custom	253,r3,r4,r3
1000128c:	0009883a 	mov	r4,zero
10001290:	1907f972 	custom	229,r3,r3,r4
10001294:	18001e26 	beq	r3,zero,10001310 <floorf+0xb4>
		    if(i0>=0) {i0=0;} 
10001298:	10001a0e 	bge	r2,zero,10001304 <floorf+0xa8>
		    else if(!FLT_UWORD_IS_ZERO(ix))
1000129c:	28001c26 	beq	r5,zero,10001310 <floorf+0xb4>
			{ i0=0xbf800000;}
100012a0:	00afe034 	movhi	r2,49024
100012a4:	f800283a 	ret
		}
	    } else {
		i = (0x007fffff)>>j0;
100012a8:	01402034 	movhi	r5,128
100012ac:	297fffc4 	addi	r5,r5,-1
100012b0:	298bd83a 	sra	r5,r5,r6
		if((i0&i)==0) return x; /* x is integral */
100012b4:	2906703a 	and	r3,r5,r4
100012b8:	18001426 	beq	r3,zero,1000130c <floorf+0xb0>
		if(huge+x>(float)0.0) {	/* raise inexact flag */
100012bc:	00dc52b4 	movhi	r3,29002
100012c0:	18fcb284 	addi	r3,r3,-3382
100012c4:	20c7ff72 	custom	253,r3,r4,r3
100012c8:	000f883a 	mov	r7,zero
100012cc:	19c7f972 	custom	229,r3,r3,r7
100012d0:	18000f26 	beq	r3,zero,10001310 <floorf+0xb4>
		    if(i0<0) i0 += (0x00800000)>>j0;
100012d4:	2000030e 	bge	r4,zero,100012e4 <floorf+0x88>
100012d8:	00c02034 	movhi	r3,128
100012dc:	1985d83a 	sra	r2,r3,r6
100012e0:	1105883a 	add	r2,r2,r4
		    i0 &= (~i);
100012e4:	014a303a 	nor	r5,zero,r5
100012e8:	2884703a 	and	r2,r5,r2
100012ec:	f800283a 	ret
		}
	    }
	} else {
	    if(!FLT_UWORD_IS_FINITE(ix)) return x+x;	/* inf or NaN */
100012f0:	009fe034 	movhi	r2,32640
100012f4:	10bfffc4 	addi	r2,r2,-1
100012f8:	1140042e 	bgeu	r2,r5,1000130c <floorf+0xb0>
100012fc:	2105ff72 	custom	253,r2,r4,r4
10001300:	f800283a 	ret
	ix = (i0&0x7fffffff);
	j0 = (ix>>23)-0x7f;
	if(j0<23) {
	    if(j0<0) { 	/* raise inexact if x != 0 */
		if(huge+x>(float)0.0) {/* return 0*sign(x) if |x|<1 */
		    if(i0>=0) {i0=0;} 
10001304:	0005883a 	mov	r2,zero
	} else {
	    if(!FLT_UWORD_IS_FINITE(ix)) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	}
	SET_FLOAT_WORD(x,i0);
	return x;
10001308:	f800283a 	ret
		    else if(!FLT_UWORD_IS_ZERO(ix))
			{ i0=0xbf800000;}
		}
	    } else {
		i = (0x007fffff)>>j0;
		if((i0&i)==0) return x; /* x is integral */
1000130c:	2005883a 	mov	r2,r4
	    if(!FLT_UWORD_IS_FINITE(ix)) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	}
	SET_FLOAT_WORD(x,i0);
	return x;
}
10001310:	f800283a 	ret

10001314 <scalbnf>:
{
	__int32_t  k,ix;
	__uint32_t hx;

	GET_FLOAT_WORD(ix,x);
	hx = ix&0x7fffffff;
10001314:	01a00034 	movhi	r6,32768
	float scalbnf (float x, int n)
#else
	float scalbnf (x,n)
	float x; int n;
#endif
{
10001318:	defffe04 	addi	sp,sp,-8
	__int32_t  k,ix;
	__uint32_t hx;

	GET_FLOAT_WORD(ix,x);
	hx = ix&0x7fffffff;
1000131c:	31bfffc4 	addi	r6,r6,-1
	float scalbnf (float x, int n)
#else
	float scalbnf (x,n)
	float x; int n;
#endif
{
10001320:	dfc00115 	stw	ra,4(sp)
10001324:	dc000015 	stw	r16,0(sp)
	__int32_t  k,ix;
	__uint32_t hx;

	GET_FLOAT_WORD(ix,x);
	hx = ix&0x7fffffff;
10001328:	310c703a 	and	r6,r6,r4
        k = hx>>23;		/* extract exponent */
	if (FLT_UWORD_IS_ZERO(hx))
1000132c:	30003826 	beq	r6,zero,10001410 <scalbnf+0xfc>
	    return x;
        if (!FLT_UWORD_IS_FINITE(hx))
10001330:	009fe034 	movhi	r2,32640
10001334:	10bfffc4 	addi	r2,r2,-1
10001338:	1180022e 	bgeu	r2,r6,10001344 <scalbnf+0x30>
	    return x+x;		/* NaN or Inf */
1000133c:	2105ff72 	custom	253,r2,r4,r4
10001340:	00003406 	br	10001414 <scalbnf+0x100>
        if (FLT_UWORD_IS_SUBNORMAL(hx)) {
10001344:	00802034 	movhi	r2,128
10001348:	10bfffc4 	addi	r2,r2,-1
1000134c:	11800d36 	bltu	r2,r6,10001384 <scalbnf+0x70>
	    x *= two25;
10001350:	00930034 	movhi	r2,19456
10001354:	2089ff32 	custom	252,r4,r4,r2
	    GET_FLOAT_WORD(ix,x);
	    k = ((ix&0x7f800000)>>23) - 25; 
            if (n< -50000) return tiny*x; 	/*underflow*/
10001358:	00bffff4 	movhi	r2,65535
1000135c:	108f2c04 	addi	r2,r2,15536
10001360:	28800516 	blt	r5,r2,10001378 <scalbnf+0x64>
        if (!FLT_UWORD_IS_FINITE(hx))
	    return x+x;		/* NaN or Inf */
        if (FLT_UWORD_IS_SUBNORMAL(hx)) {
	    x *= two25;
	    GET_FLOAT_WORD(ix,x);
	    k = ((ix&0x7f800000)>>23) - 25; 
10001364:	219fe02c 	andhi	r6,r4,32640
10001368:	300dd5fa 	srai	r6,r6,23
	    return x;
        if (!FLT_UWORD_IS_FINITE(hx))
	    return x+x;		/* NaN or Inf */
        if (FLT_UWORD_IS_SUBNORMAL(hx)) {
	    x *= two25;
	    GET_FLOAT_WORD(ix,x);
1000136c:	2005883a 	mov	r2,r4
	    k = ((ix&0x7f800000)>>23) - 25; 
10001370:	31bff9c4 	addi	r6,r6,-25
10001374:	00000506 	br	1000138c <scalbnf+0x78>
            if (n< -50000) return tiny*x; 	/*underflow*/
10001378:	008368b4 	movhi	r2,3490
1000137c:	10909804 	addi	r2,r2,16992
10001380:	00002106 	br	10001408 <scalbnf+0xf4>
	__int32_t  k,ix;
	__uint32_t hx;

	GET_FLOAT_WORD(ix,x);
	hx = ix&0x7fffffff;
        k = hx>>23;		/* extract exponent */
10001384:	300cd5fa 	srli	r6,r6,23
#endif
{
	__int32_t  k,ix;
	__uint32_t hx;

	GET_FLOAT_WORD(ix,x);
10001388:	2005883a 	mov	r2,r4
	    x *= two25;
	    GET_FLOAT_WORD(ix,x);
	    k = ((ix&0x7f800000)>>23) - 25; 
            if (n< -50000) return tiny*x; 	/*underflow*/
        }
        k = k+n; 
1000138c:	314d883a 	add	r6,r6,r5
        if (k > FLT_LARGEST_EXP) return huge*copysignf(huge,x); /* overflow  */
10001390:	00c03f84 	movi	r3,254
10001394:	19800b16 	blt	r3,r6,100013c4 <scalbnf+0xb0>
        if (k > 0) 				/* normal result */
10001398:	0180060e 	bge	zero,r6,100013b4 <scalbnf+0xa0>
	    {SET_FLOAT_WORD(x,(ix&0x807fffff)|(k<<23)); return x;}
1000139c:	00e02034 	movhi	r3,32896
100013a0:	300895fa 	slli	r4,r6,23
100013a4:	18ffffc4 	addi	r3,r3,-1
100013a8:	10c4703a 	and	r2,r2,r3
100013ac:	1104b03a 	or	r2,r2,r4
100013b0:	00001806 	br	10001414 <scalbnf+0x100>
        if (k < FLT_SMALLEST_EXP) {
100013b4:	00fffa84 	movi	r3,-22
100013b8:	30c00c0e 	bge	r6,r3,100013ec <scalbnf+0xd8>
            if (n > OVERFLOW_INT) 	/* in case integer overflow in n+k */
100013bc:	00b0d414 	movui	r2,50000
100013c0:	1140030e 	bge	r2,r5,100013d0 <scalbnf+0xbc>
		return huge*copysignf(huge,x);	/*overflow*/
100013c4:	041c52b4 	movhi	r16,29002
100013c8:	843cb284 	addi	r16,r16,-3382
100013cc:	00000206 	br	100013d8 <scalbnf+0xc4>
	    else return tiny*copysignf(tiny,x);	/*underflow*/
100013d0:	040368b4 	movhi	r16,3490
100013d4:	84109804 	addi	r16,r16,16992
100013d8:	200b883a 	mov	r5,r4
100013dc:	8009883a 	mov	r4,r16
100013e0:	00014240 	call	10001424 <copysignf>
100013e4:	1405ff32 	custom	252,r2,r2,r16
100013e8:	00000a06 	br	10001414 <scalbnf+0x100>
        }
        k += 25;				/* subnormal result */
	SET_FLOAT_WORD(x,(ix&0x807fffff)|(k<<23));
100013ec:	31800644 	addi	r6,r6,25
100013f0:	300c95fa 	slli	r6,r6,23
100013f4:	00e02034 	movhi	r3,32896
100013f8:	18ffffc4 	addi	r3,r3,-1
100013fc:	10c4703a 	and	r2,r2,r3
10001400:	3084b03a 	or	r2,r6,r2
        return x*twom25;
10001404:	010cc034 	movhi	r4,13056
10001408:	1105ff32 	custom	252,r2,r2,r4
1000140c:	00000106 	br	10001414 <scalbnf+0x100>

	GET_FLOAT_WORD(ix,x);
	hx = ix&0x7fffffff;
        k = hx>>23;		/* extract exponent */
	if (FLT_UWORD_IS_ZERO(hx))
	    return x;
10001410:	2005883a 	mov	r2,r4
	    else return tiny*copysignf(tiny,x);	/*underflow*/
        }
        k += 25;				/* subnormal result */
	SET_FLOAT_WORD(x,(ix&0x807fffff)|(k<<23));
        return x*twom25;
}
10001414:	dfc00117 	ldw	ra,4(sp)
10001418:	dc000017 	ldw	r16,0(sp)
1000141c:	dec00204 	addi	sp,sp,8
10001420:	f800283a 	ret

10001424 <copysignf>:
#endif
{
	__uint32_t ix,iy;
	GET_FLOAT_WORD(ix,x);
	GET_FLOAT_WORD(iy,y);
	SET_FLOAT_WORD(x,(ix&0x7fffffff)|(iy&0x80000000));
10001424:	00a00034 	movhi	r2,32768
10001428:	10bfffc4 	addi	r2,r2,-1
1000142c:	2084703a 	and	r2,r4,r2
10001430:	2960002c 	andhi	r5,r5,32768
        return x;
}
10001434:	1144b03a 	or	r2,r2,r5
10001438:	f800283a 	ret

1000143c <__adddf3>:
1000143c:	02c00434 	movhi	r11,16
10001440:	5affffc4 	addi	r11,r11,-1
10001444:	2806d7fa 	srli	r3,r5,31
10001448:	2ad4703a 	and	r10,r5,r11
1000144c:	3ad2703a 	and	r9,r7,r11
10001450:	3804d53a 	srli	r2,r7,20
10001454:	3018d77a 	srli	r12,r6,29
10001458:	280ad53a 	srli	r5,r5,20
1000145c:	501490fa 	slli	r10,r10,3
10001460:	2010d77a 	srli	r8,r4,29
10001464:	481290fa 	slli	r9,r9,3
10001468:	380ed7fa 	srli	r7,r7,31
1000146c:	defffb04 	addi	sp,sp,-20
10001470:	dc800215 	stw	r18,8(sp)
10001474:	dc400115 	stw	r17,4(sp)
10001478:	dc000015 	stw	r16,0(sp)
1000147c:	dfc00415 	stw	ra,16(sp)
10001480:	dcc00315 	stw	r19,12(sp)
10001484:	1c803fcc 	andi	r18,r3,255
10001488:	2c01ffcc 	andi	r16,r5,2047
1000148c:	5210b03a 	or	r8,r10,r8
10001490:	202290fa 	slli	r17,r4,3
10001494:	1081ffcc 	andi	r2,r2,2047
10001498:	4b12b03a 	or	r9,r9,r12
1000149c:	300c90fa 	slli	r6,r6,3
100014a0:	91c07526 	beq	r18,r7,10001678 <__adddf3+0x23c>
100014a4:	8087c83a 	sub	r3,r16,r2
100014a8:	00c0ab0e 	bge	zero,r3,10001758 <__adddf3+0x31c>
100014ac:	10002a1e 	bne	r2,zero,10001558 <__adddf3+0x11c>
100014b0:	4984b03a 	or	r2,r9,r6
100014b4:	1000961e 	bne	r2,zero,10001710 <__adddf3+0x2d4>
100014b8:	888001cc 	andi	r2,r17,7
100014bc:	10000726 	beq	r2,zero,100014dc <__adddf3+0xa0>
100014c0:	888003cc 	andi	r2,r17,15
100014c4:	00c00104 	movi	r3,4
100014c8:	10c00426 	beq	r2,r3,100014dc <__adddf3+0xa0>
100014cc:	88c7883a 	add	r3,r17,r3
100014d0:	1c63803a 	cmpltu	r17,r3,r17
100014d4:	4451883a 	add	r8,r8,r17
100014d8:	1823883a 	mov	r17,r3
100014dc:	4080202c 	andhi	r2,r8,128
100014e0:	10005926 	beq	r2,zero,10001648 <__adddf3+0x20c>
100014e4:	84000044 	addi	r16,r16,1
100014e8:	0081ffc4 	movi	r2,2047
100014ec:	8080ba26 	beq	r16,r2,100017d8 <__adddf3+0x39c>
100014f0:	00bfe034 	movhi	r2,65408
100014f4:	10bfffc4 	addi	r2,r2,-1
100014f8:	4090703a 	and	r8,r8,r2
100014fc:	4004977a 	slli	r2,r8,29
10001500:	4010927a 	slli	r8,r8,9
10001504:	8822d0fa 	srli	r17,r17,3
10001508:	8401ffcc 	andi	r16,r16,2047
1000150c:	4010d33a 	srli	r8,r8,12
10001510:	9007883a 	mov	r3,r18
10001514:	1444b03a 	or	r2,r2,r17
10001518:	8401ffcc 	andi	r16,r16,2047
1000151c:	8020953a 	slli	r16,r16,20
10001520:	18c03fcc 	andi	r3,r3,255
10001524:	01000434 	movhi	r4,16
10001528:	213fffc4 	addi	r4,r4,-1
1000152c:	180697fa 	slli	r3,r3,31
10001530:	4110703a 	and	r8,r8,r4
10001534:	4410b03a 	or	r8,r8,r16
10001538:	40c6b03a 	or	r3,r8,r3
1000153c:	dfc00417 	ldw	ra,16(sp)
10001540:	dcc00317 	ldw	r19,12(sp)
10001544:	dc800217 	ldw	r18,8(sp)
10001548:	dc400117 	ldw	r17,4(sp)
1000154c:	dc000017 	ldw	r16,0(sp)
10001550:	dec00504 	addi	sp,sp,20
10001554:	f800283a 	ret
10001558:	0081ffc4 	movi	r2,2047
1000155c:	80bfd626 	beq	r16,r2,100014b8 <__adddf3+0x7c>
10001560:	4a402034 	orhi	r9,r9,128
10001564:	00800e04 	movi	r2,56
10001568:	10c09f16 	blt	r2,r3,100017e8 <__adddf3+0x3ac>
1000156c:	008007c4 	movi	r2,31
10001570:	10c0c216 	blt	r2,r3,1000187c <__adddf3+0x440>
10001574:	00800804 	movi	r2,32
10001578:	10c5c83a 	sub	r2,r2,r3
1000157c:	488a983a 	sll	r5,r9,r2
10001580:	30c8d83a 	srl	r4,r6,r3
10001584:	3084983a 	sll	r2,r6,r2
10001588:	48c6d83a 	srl	r3,r9,r3
1000158c:	290cb03a 	or	r6,r5,r4
10001590:	1004c03a 	cmpne	r2,r2,zero
10001594:	308cb03a 	or	r6,r6,r2
10001598:	898dc83a 	sub	r6,r17,r6
1000159c:	89a3803a 	cmpltu	r17,r17,r6
100015a0:	40d1c83a 	sub	r8,r8,r3
100015a4:	4451c83a 	sub	r8,r8,r17
100015a8:	3023883a 	mov	r17,r6
100015ac:	4080202c 	andhi	r2,r8,128
100015b0:	10002326 	beq	r2,zero,10001640 <__adddf3+0x204>
100015b4:	04c02034 	movhi	r19,128
100015b8:	9cffffc4 	addi	r19,r19,-1
100015bc:	44e6703a 	and	r19,r8,r19
100015c0:	98007626 	beq	r19,zero,1000179c <__adddf3+0x360>
100015c4:	9809883a 	mov	r4,r19
100015c8:	000307c0 	call	1000307c <__clzsi2>
100015cc:	10fffe04 	addi	r3,r2,-8
100015d0:	010007c4 	movi	r4,31
100015d4:	20c07716 	blt	r4,r3,100017b4 <__adddf3+0x378>
100015d8:	00800804 	movi	r2,32
100015dc:	10c5c83a 	sub	r2,r2,r3
100015e0:	8884d83a 	srl	r2,r17,r2
100015e4:	98d0983a 	sll	r8,r19,r3
100015e8:	88e2983a 	sll	r17,r17,r3
100015ec:	1204b03a 	or	r2,r2,r8
100015f0:	1c007416 	blt	r3,r16,100017c4 <__adddf3+0x388>
100015f4:	1c21c83a 	sub	r16,r3,r16
100015f8:	82000044 	addi	r8,r16,1
100015fc:	00c007c4 	movi	r3,31
10001600:	1a009116 	blt	r3,r8,10001848 <__adddf3+0x40c>
10001604:	00c00804 	movi	r3,32
10001608:	1a07c83a 	sub	r3,r3,r8
1000160c:	8a08d83a 	srl	r4,r17,r8
10001610:	88e2983a 	sll	r17,r17,r3
10001614:	10c6983a 	sll	r3,r2,r3
10001618:	1210d83a 	srl	r8,r2,r8
1000161c:	8804c03a 	cmpne	r2,r17,zero
10001620:	1906b03a 	or	r3,r3,r4
10001624:	18a2b03a 	or	r17,r3,r2
10001628:	0021883a 	mov	r16,zero
1000162c:	003fa206 	br	100014b8 <__adddf3+0x7c>
10001630:	1890b03a 	or	r8,r3,r2
10001634:	40017d26 	beq	r8,zero,10001c2c <__adddf3+0x7f0>
10001638:	1011883a 	mov	r8,r2
1000163c:	1823883a 	mov	r17,r3
10001640:	888001cc 	andi	r2,r17,7
10001644:	103f9e1e 	bne	r2,zero,100014c0 <__adddf3+0x84>
10001648:	4004977a 	slli	r2,r8,29
1000164c:	8822d0fa 	srli	r17,r17,3
10001650:	4010d0fa 	srli	r8,r8,3
10001654:	9007883a 	mov	r3,r18
10001658:	1444b03a 	or	r2,r2,r17
1000165c:	0101ffc4 	movi	r4,2047
10001660:	81002426 	beq	r16,r4,100016f4 <__adddf3+0x2b8>
10001664:	8120703a 	and	r16,r16,r4
10001668:	01000434 	movhi	r4,16
1000166c:	213fffc4 	addi	r4,r4,-1
10001670:	4110703a 	and	r8,r8,r4
10001674:	003fa806 	br	10001518 <__adddf3+0xdc>
10001678:	8089c83a 	sub	r4,r16,r2
1000167c:	01005e0e 	bge	zero,r4,100017f8 <__adddf3+0x3bc>
10001680:	10002b26 	beq	r2,zero,10001730 <__adddf3+0x2f4>
10001684:	0081ffc4 	movi	r2,2047
10001688:	80bf8b26 	beq	r16,r2,100014b8 <__adddf3+0x7c>
1000168c:	4a402034 	orhi	r9,r9,128
10001690:	00800e04 	movi	r2,56
10001694:	1100a40e 	bge	r2,r4,10001928 <__adddf3+0x4ec>
10001698:	498cb03a 	or	r6,r9,r6
1000169c:	300ac03a 	cmpne	r5,r6,zero
100016a0:	0013883a 	mov	r9,zero
100016a4:	2c4b883a 	add	r5,r5,r17
100016a8:	2c63803a 	cmpltu	r17,r5,r17
100016ac:	4a11883a 	add	r8,r9,r8
100016b0:	8a11883a 	add	r8,r17,r8
100016b4:	2823883a 	mov	r17,r5
100016b8:	4080202c 	andhi	r2,r8,128
100016bc:	103fe026 	beq	r2,zero,10001640 <__adddf3+0x204>
100016c0:	84000044 	addi	r16,r16,1
100016c4:	0081ffc4 	movi	r2,2047
100016c8:	8080d226 	beq	r16,r2,10001a14 <__adddf3+0x5d8>
100016cc:	00bfe034 	movhi	r2,65408
100016d0:	10bfffc4 	addi	r2,r2,-1
100016d4:	4090703a 	and	r8,r8,r2
100016d8:	880ad07a 	srli	r5,r17,1
100016dc:	400897fa 	slli	r4,r8,31
100016e0:	88c0004c 	andi	r3,r17,1
100016e4:	28e2b03a 	or	r17,r5,r3
100016e8:	4010d07a 	srli	r8,r8,1
100016ec:	2462b03a 	or	r17,r4,r17
100016f0:	003f7106 	br	100014b8 <__adddf3+0x7c>
100016f4:	4088b03a 	or	r4,r8,r2
100016f8:	20014526 	beq	r4,zero,10001c10 <__adddf3+0x7d4>
100016fc:	01000434 	movhi	r4,16
10001700:	42000234 	orhi	r8,r8,8
10001704:	213fffc4 	addi	r4,r4,-1
10001708:	4110703a 	and	r8,r8,r4
1000170c:	003f8206 	br	10001518 <__adddf3+0xdc>
10001710:	18ffffc4 	addi	r3,r3,-1
10001714:	1800491e 	bne	r3,zero,1000183c <__adddf3+0x400>
10001718:	898bc83a 	sub	r5,r17,r6
1000171c:	8963803a 	cmpltu	r17,r17,r5
10001720:	4251c83a 	sub	r8,r8,r9
10001724:	4451c83a 	sub	r8,r8,r17
10001728:	2823883a 	mov	r17,r5
1000172c:	003f9f06 	br	100015ac <__adddf3+0x170>
10001730:	4984b03a 	or	r2,r9,r6
10001734:	103f6026 	beq	r2,zero,100014b8 <__adddf3+0x7c>
10001738:	213fffc4 	addi	r4,r4,-1
1000173c:	2000931e 	bne	r4,zero,1000198c <__adddf3+0x550>
10001740:	898d883a 	add	r6,r17,r6
10001744:	3463803a 	cmpltu	r17,r6,r17
10001748:	4251883a 	add	r8,r8,r9
1000174c:	8a11883a 	add	r8,r17,r8
10001750:	3023883a 	mov	r17,r6
10001754:	003fd806 	br	100016b8 <__adddf3+0x27c>
10001758:	1800541e 	bne	r3,zero,100018ac <__adddf3+0x470>
1000175c:	80800044 	addi	r2,r16,1
10001760:	1081ffcc 	andi	r2,r2,2047
10001764:	00c00044 	movi	r3,1
10001768:	1880a00e 	bge	r3,r2,100019ec <__adddf3+0x5b0>
1000176c:	8989c83a 	sub	r4,r17,r6
10001770:	8905803a 	cmpltu	r2,r17,r4
10001774:	4267c83a 	sub	r19,r8,r9
10001778:	98a7c83a 	sub	r19,r19,r2
1000177c:	9880202c 	andhi	r2,r19,128
10001780:	10006326 	beq	r2,zero,10001910 <__adddf3+0x4d4>
10001784:	3463c83a 	sub	r17,r6,r17
10001788:	4a07c83a 	sub	r3,r9,r8
1000178c:	344d803a 	cmpltu	r6,r6,r17
10001790:	19a7c83a 	sub	r19,r3,r6
10001794:	3825883a 	mov	r18,r7
10001798:	983f8a1e 	bne	r19,zero,100015c4 <__adddf3+0x188>
1000179c:	8809883a 	mov	r4,r17
100017a0:	000307c0 	call	1000307c <__clzsi2>
100017a4:	10800804 	addi	r2,r2,32
100017a8:	10fffe04 	addi	r3,r2,-8
100017ac:	010007c4 	movi	r4,31
100017b0:	20ff890e 	bge	r4,r3,100015d8 <__adddf3+0x19c>
100017b4:	10bff604 	addi	r2,r2,-40
100017b8:	8884983a 	sll	r2,r17,r2
100017bc:	0023883a 	mov	r17,zero
100017c0:	1c3f8c0e 	bge	r3,r16,100015f4 <__adddf3+0x1b8>
100017c4:	023fe034 	movhi	r8,65408
100017c8:	423fffc4 	addi	r8,r8,-1
100017cc:	80e1c83a 	sub	r16,r16,r3
100017d0:	1210703a 	and	r8,r2,r8
100017d4:	003f3806 	br	100014b8 <__adddf3+0x7c>
100017d8:	9007883a 	mov	r3,r18
100017dc:	0011883a 	mov	r8,zero
100017e0:	0005883a 	mov	r2,zero
100017e4:	003f4c06 	br	10001518 <__adddf3+0xdc>
100017e8:	498cb03a 	or	r6,r9,r6
100017ec:	300cc03a 	cmpne	r6,r6,zero
100017f0:	0007883a 	mov	r3,zero
100017f4:	003f6806 	br	10001598 <__adddf3+0x15c>
100017f8:	20009c1e 	bne	r4,zero,10001a6c <__adddf3+0x630>
100017fc:	80800044 	addi	r2,r16,1
10001800:	1141ffcc 	andi	r5,r2,2047
10001804:	01000044 	movi	r4,1
10001808:	2140670e 	bge	r4,r5,100019a8 <__adddf3+0x56c>
1000180c:	0101ffc4 	movi	r4,2047
10001810:	11007f26 	beq	r2,r4,10001a10 <__adddf3+0x5d4>
10001814:	898d883a 	add	r6,r17,r6
10001818:	4247883a 	add	r3,r8,r9
1000181c:	3451803a 	cmpltu	r8,r6,r17
10001820:	40d1883a 	add	r8,r8,r3
10001824:	402297fa 	slli	r17,r8,31
10001828:	300cd07a 	srli	r6,r6,1
1000182c:	4010d07a 	srli	r8,r8,1
10001830:	1021883a 	mov	r16,r2
10001834:	89a2b03a 	or	r17,r17,r6
10001838:	003f1f06 	br	100014b8 <__adddf3+0x7c>
1000183c:	0081ffc4 	movi	r2,2047
10001840:	80bf481e 	bne	r16,r2,10001564 <__adddf3+0x128>
10001844:	003f1c06 	br	100014b8 <__adddf3+0x7c>
10001848:	843ff844 	addi	r16,r16,-31
1000184c:	01000804 	movi	r4,32
10001850:	1406d83a 	srl	r3,r2,r16
10001854:	41005026 	beq	r8,r4,10001998 <__adddf3+0x55c>
10001858:	01001004 	movi	r4,64
1000185c:	2211c83a 	sub	r8,r4,r8
10001860:	1204983a 	sll	r2,r2,r8
10001864:	88a2b03a 	or	r17,r17,r2
10001868:	8822c03a 	cmpne	r17,r17,zero
1000186c:	1c62b03a 	or	r17,r3,r17
10001870:	0011883a 	mov	r8,zero
10001874:	0021883a 	mov	r16,zero
10001878:	003f7106 	br	10001640 <__adddf3+0x204>
1000187c:	193ff804 	addi	r4,r3,-32
10001880:	00800804 	movi	r2,32
10001884:	4908d83a 	srl	r4,r9,r4
10001888:	18804526 	beq	r3,r2,100019a0 <__adddf3+0x564>
1000188c:	00801004 	movi	r2,64
10001890:	10c5c83a 	sub	r2,r2,r3
10001894:	4886983a 	sll	r3,r9,r2
10001898:	198cb03a 	or	r6,r3,r6
1000189c:	300cc03a 	cmpne	r6,r6,zero
100018a0:	218cb03a 	or	r6,r4,r6
100018a4:	0007883a 	mov	r3,zero
100018a8:	003f3b06 	br	10001598 <__adddf3+0x15c>
100018ac:	80002a26 	beq	r16,zero,10001958 <__adddf3+0x51c>
100018b0:	0101ffc4 	movi	r4,2047
100018b4:	11006826 	beq	r2,r4,10001a58 <__adddf3+0x61c>
100018b8:	00c7c83a 	sub	r3,zero,r3
100018bc:	42002034 	orhi	r8,r8,128
100018c0:	01000e04 	movi	r4,56
100018c4:	20c07c16 	blt	r4,r3,10001ab8 <__adddf3+0x67c>
100018c8:	010007c4 	movi	r4,31
100018cc:	20c0da16 	blt	r4,r3,10001c38 <__adddf3+0x7fc>
100018d0:	01000804 	movi	r4,32
100018d4:	20c9c83a 	sub	r4,r4,r3
100018d8:	4114983a 	sll	r10,r8,r4
100018dc:	88cad83a 	srl	r5,r17,r3
100018e0:	8908983a 	sll	r4,r17,r4
100018e4:	40c6d83a 	srl	r3,r8,r3
100018e8:	5162b03a 	or	r17,r10,r5
100018ec:	2008c03a 	cmpne	r4,r4,zero
100018f0:	8922b03a 	or	r17,r17,r4
100018f4:	3463c83a 	sub	r17,r6,r17
100018f8:	48c7c83a 	sub	r3,r9,r3
100018fc:	344d803a 	cmpltu	r6,r6,r17
10001900:	1991c83a 	sub	r8,r3,r6
10001904:	1021883a 	mov	r16,r2
10001908:	3825883a 	mov	r18,r7
1000190c:	003f2706 	br	100015ac <__adddf3+0x170>
10001910:	24d0b03a 	or	r8,r4,r19
10001914:	40001b1e 	bne	r8,zero,10001984 <__adddf3+0x548>
10001918:	0005883a 	mov	r2,zero
1000191c:	0007883a 	mov	r3,zero
10001920:	0021883a 	mov	r16,zero
10001924:	003f4d06 	br	1000165c <__adddf3+0x220>
10001928:	008007c4 	movi	r2,31
1000192c:	11003c16 	blt	r2,r4,10001a20 <__adddf3+0x5e4>
10001930:	00800804 	movi	r2,32
10001934:	1105c83a 	sub	r2,r2,r4
10001938:	488e983a 	sll	r7,r9,r2
1000193c:	310ad83a 	srl	r5,r6,r4
10001940:	3084983a 	sll	r2,r6,r2
10001944:	4912d83a 	srl	r9,r9,r4
10001948:	394ab03a 	or	r5,r7,r5
1000194c:	1004c03a 	cmpne	r2,r2,zero
10001950:	288ab03a 	or	r5,r5,r2
10001954:	003f5306 	br	100016a4 <__adddf3+0x268>
10001958:	4448b03a 	or	r4,r8,r17
1000195c:	20003e26 	beq	r4,zero,10001a58 <__adddf3+0x61c>
10001960:	00c6303a 	nor	r3,zero,r3
10001964:	18003a1e 	bne	r3,zero,10001a50 <__adddf3+0x614>
10001968:	3463c83a 	sub	r17,r6,r17
1000196c:	4a07c83a 	sub	r3,r9,r8
10001970:	344d803a 	cmpltu	r6,r6,r17
10001974:	1991c83a 	sub	r8,r3,r6
10001978:	1021883a 	mov	r16,r2
1000197c:	3825883a 	mov	r18,r7
10001980:	003f0a06 	br	100015ac <__adddf3+0x170>
10001984:	2023883a 	mov	r17,r4
10001988:	003f0d06 	br	100015c0 <__adddf3+0x184>
1000198c:	0081ffc4 	movi	r2,2047
10001990:	80bf3f1e 	bne	r16,r2,10001690 <__adddf3+0x254>
10001994:	003ec806 	br	100014b8 <__adddf3+0x7c>
10001998:	0005883a 	mov	r2,zero
1000199c:	003fb106 	br	10001864 <__adddf3+0x428>
100019a0:	0007883a 	mov	r3,zero
100019a4:	003fbc06 	br	10001898 <__adddf3+0x45c>
100019a8:	4444b03a 	or	r2,r8,r17
100019ac:	8000871e 	bne	r16,zero,10001bcc <__adddf3+0x790>
100019b0:	1000ba26 	beq	r2,zero,10001c9c <__adddf3+0x860>
100019b4:	4984b03a 	or	r2,r9,r6
100019b8:	103ebf26 	beq	r2,zero,100014b8 <__adddf3+0x7c>
100019bc:	8985883a 	add	r2,r17,r6
100019c0:	4247883a 	add	r3,r8,r9
100019c4:	1451803a 	cmpltu	r8,r2,r17
100019c8:	40d1883a 	add	r8,r8,r3
100019cc:	40c0202c 	andhi	r3,r8,128
100019d0:	1023883a 	mov	r17,r2
100019d4:	183f1a26 	beq	r3,zero,10001640 <__adddf3+0x204>
100019d8:	00bfe034 	movhi	r2,65408
100019dc:	10bfffc4 	addi	r2,r2,-1
100019e0:	2021883a 	mov	r16,r4
100019e4:	4090703a 	and	r8,r8,r2
100019e8:	003eb306 	br	100014b8 <__adddf3+0x7c>
100019ec:	4444b03a 	or	r2,r8,r17
100019f0:	8000291e 	bne	r16,zero,10001a98 <__adddf3+0x65c>
100019f4:	10004b1e 	bne	r2,zero,10001b24 <__adddf3+0x6e8>
100019f8:	4990b03a 	or	r8,r9,r6
100019fc:	40008b26 	beq	r8,zero,10001c2c <__adddf3+0x7f0>
10001a00:	4811883a 	mov	r8,r9
10001a04:	3023883a 	mov	r17,r6
10001a08:	3825883a 	mov	r18,r7
10001a0c:	003eaa06 	br	100014b8 <__adddf3+0x7c>
10001a10:	1021883a 	mov	r16,r2
10001a14:	0011883a 	mov	r8,zero
10001a18:	0005883a 	mov	r2,zero
10001a1c:	003f0f06 	br	1000165c <__adddf3+0x220>
10001a20:	217ff804 	addi	r5,r4,-32
10001a24:	00800804 	movi	r2,32
10001a28:	494ad83a 	srl	r5,r9,r5
10001a2c:	20807d26 	beq	r4,r2,10001c24 <__adddf3+0x7e8>
10001a30:	00801004 	movi	r2,64
10001a34:	1109c83a 	sub	r4,r2,r4
10001a38:	4912983a 	sll	r9,r9,r4
10001a3c:	498cb03a 	or	r6,r9,r6
10001a40:	300cc03a 	cmpne	r6,r6,zero
10001a44:	298ab03a 	or	r5,r5,r6
10001a48:	0013883a 	mov	r9,zero
10001a4c:	003f1506 	br	100016a4 <__adddf3+0x268>
10001a50:	0101ffc4 	movi	r4,2047
10001a54:	113f9a1e 	bne	r2,r4,100018c0 <__adddf3+0x484>
10001a58:	4811883a 	mov	r8,r9
10001a5c:	3023883a 	mov	r17,r6
10001a60:	1021883a 	mov	r16,r2
10001a64:	3825883a 	mov	r18,r7
10001a68:	003e9306 	br	100014b8 <__adddf3+0x7c>
10001a6c:	8000161e 	bne	r16,zero,10001ac8 <__adddf3+0x68c>
10001a70:	444ab03a 	or	r5,r8,r17
10001a74:	28005126 	beq	r5,zero,10001bbc <__adddf3+0x780>
10001a78:	0108303a 	nor	r4,zero,r4
10001a7c:	20004d1e 	bne	r4,zero,10001bb4 <__adddf3+0x778>
10001a80:	89a3883a 	add	r17,r17,r6
10001a84:	4253883a 	add	r9,r8,r9
10001a88:	898d803a 	cmpltu	r6,r17,r6
10001a8c:	3251883a 	add	r8,r6,r9
10001a90:	1021883a 	mov	r16,r2
10001a94:	003f0806 	br	100016b8 <__adddf3+0x27c>
10001a98:	1000301e 	bne	r2,zero,10001b5c <__adddf3+0x720>
10001a9c:	4984b03a 	or	r2,r9,r6
10001aa0:	10007126 	beq	r2,zero,10001c68 <__adddf3+0x82c>
10001aa4:	4811883a 	mov	r8,r9
10001aa8:	3023883a 	mov	r17,r6
10001aac:	3825883a 	mov	r18,r7
10001ab0:	0401ffc4 	movi	r16,2047
10001ab4:	003e8006 	br	100014b8 <__adddf3+0x7c>
10001ab8:	4462b03a 	or	r17,r8,r17
10001abc:	8822c03a 	cmpne	r17,r17,zero
10001ac0:	0007883a 	mov	r3,zero
10001ac4:	003f8b06 	br	100018f4 <__adddf3+0x4b8>
10001ac8:	0141ffc4 	movi	r5,2047
10001acc:	11403b26 	beq	r2,r5,10001bbc <__adddf3+0x780>
10001ad0:	0109c83a 	sub	r4,zero,r4
10001ad4:	42002034 	orhi	r8,r8,128
10001ad8:	01400e04 	movi	r5,56
10001adc:	29006716 	blt	r5,r4,10001c7c <__adddf3+0x840>
10001ae0:	014007c4 	movi	r5,31
10001ae4:	29007016 	blt	r5,r4,10001ca8 <__adddf3+0x86c>
10001ae8:	01400804 	movi	r5,32
10001aec:	290bc83a 	sub	r5,r5,r4
10001af0:	4154983a 	sll	r10,r8,r5
10001af4:	890ed83a 	srl	r7,r17,r4
10001af8:	894a983a 	sll	r5,r17,r5
10001afc:	4108d83a 	srl	r4,r8,r4
10001b00:	51e2b03a 	or	r17,r10,r7
10001b04:	280ac03a 	cmpne	r5,r5,zero
10001b08:	8962b03a 	or	r17,r17,r5
10001b0c:	89a3883a 	add	r17,r17,r6
10001b10:	2253883a 	add	r9,r4,r9
10001b14:	898d803a 	cmpltu	r6,r17,r6
10001b18:	3251883a 	add	r8,r6,r9
10001b1c:	1021883a 	mov	r16,r2
10001b20:	003ee506 	br	100016b8 <__adddf3+0x27c>
10001b24:	4984b03a 	or	r2,r9,r6
10001b28:	103e6326 	beq	r2,zero,100014b8 <__adddf3+0x7c>
10001b2c:	8987c83a 	sub	r3,r17,r6
10001b30:	88c9803a 	cmpltu	r4,r17,r3
10001b34:	4245c83a 	sub	r2,r8,r9
10001b38:	1105c83a 	sub	r2,r2,r4
10001b3c:	1100202c 	andhi	r4,r2,128
10001b40:	203ebb26 	beq	r4,zero,10001630 <__adddf3+0x1f4>
10001b44:	3463c83a 	sub	r17,r6,r17
10001b48:	4a07c83a 	sub	r3,r9,r8
10001b4c:	344d803a 	cmpltu	r6,r6,r17
10001b50:	1991c83a 	sub	r8,r3,r6
10001b54:	3825883a 	mov	r18,r7
10001b58:	003e5706 	br	100014b8 <__adddf3+0x7c>
10001b5c:	4984b03a 	or	r2,r9,r6
10001b60:	10002e26 	beq	r2,zero,10001c1c <__adddf3+0x7e0>
10001b64:	4004d0fa 	srli	r2,r8,3
10001b68:	8822d0fa 	srli	r17,r17,3
10001b6c:	4010977a 	slli	r8,r8,29
10001b70:	10c0022c 	andhi	r3,r2,8
10001b74:	4462b03a 	or	r17,r8,r17
10001b78:	18000826 	beq	r3,zero,10001b9c <__adddf3+0x760>
10001b7c:	4808d0fa 	srli	r4,r9,3
10001b80:	20c0022c 	andhi	r3,r4,8
10001b84:	1800051e 	bne	r3,zero,10001b9c <__adddf3+0x760>
10001b88:	300cd0fa 	srli	r6,r6,3
10001b8c:	4806977a 	slli	r3,r9,29
10001b90:	2005883a 	mov	r2,r4
10001b94:	3825883a 	mov	r18,r7
10001b98:	19a2b03a 	or	r17,r3,r6
10001b9c:	8810d77a 	srli	r8,r17,29
10001ba0:	100490fa 	slli	r2,r2,3
10001ba4:	882290fa 	slli	r17,r17,3
10001ba8:	0401ffc4 	movi	r16,2047
10001bac:	4090b03a 	or	r8,r8,r2
10001bb0:	003e4106 	br	100014b8 <__adddf3+0x7c>
10001bb4:	0141ffc4 	movi	r5,2047
10001bb8:	117fc71e 	bne	r2,r5,10001ad8 <__adddf3+0x69c>
10001bbc:	4811883a 	mov	r8,r9
10001bc0:	3023883a 	mov	r17,r6
10001bc4:	1021883a 	mov	r16,r2
10001bc8:	003e3b06 	br	100014b8 <__adddf3+0x7c>
10001bcc:	10002f26 	beq	r2,zero,10001c8c <__adddf3+0x850>
10001bd0:	4984b03a 	or	r2,r9,r6
10001bd4:	10001126 	beq	r2,zero,10001c1c <__adddf3+0x7e0>
10001bd8:	4004d0fa 	srli	r2,r8,3
10001bdc:	8822d0fa 	srli	r17,r17,3
10001be0:	4010977a 	slli	r8,r8,29
10001be4:	10c0022c 	andhi	r3,r2,8
10001be8:	4462b03a 	or	r17,r8,r17
10001bec:	183feb26 	beq	r3,zero,10001b9c <__adddf3+0x760>
10001bf0:	4808d0fa 	srli	r4,r9,3
10001bf4:	20c0022c 	andhi	r3,r4,8
10001bf8:	183fe81e 	bne	r3,zero,10001b9c <__adddf3+0x760>
10001bfc:	300cd0fa 	srli	r6,r6,3
10001c00:	4806977a 	slli	r3,r9,29
10001c04:	2005883a 	mov	r2,r4
10001c08:	19a2b03a 	or	r17,r3,r6
10001c0c:	003fe306 	br	10001b9c <__adddf3+0x760>
10001c10:	0011883a 	mov	r8,zero
10001c14:	0005883a 	mov	r2,zero
10001c18:	003e3f06 	br	10001518 <__adddf3+0xdc>
10001c1c:	0401ffc4 	movi	r16,2047
10001c20:	003e2506 	br	100014b8 <__adddf3+0x7c>
10001c24:	0013883a 	mov	r9,zero
10001c28:	003f8406 	br	10001a3c <__adddf3+0x600>
10001c2c:	0005883a 	mov	r2,zero
10001c30:	0007883a 	mov	r3,zero
10001c34:	003e8906 	br	1000165c <__adddf3+0x220>
10001c38:	197ff804 	addi	r5,r3,-32
10001c3c:	01000804 	movi	r4,32
10001c40:	414ad83a 	srl	r5,r8,r5
10001c44:	19002426 	beq	r3,r4,10001cd8 <__adddf3+0x89c>
10001c48:	01001004 	movi	r4,64
10001c4c:	20c7c83a 	sub	r3,r4,r3
10001c50:	40c6983a 	sll	r3,r8,r3
10001c54:	1c46b03a 	or	r3,r3,r17
10001c58:	1806c03a 	cmpne	r3,r3,zero
10001c5c:	28e2b03a 	or	r17,r5,r3
10001c60:	0007883a 	mov	r3,zero
10001c64:	003f2306 	br	100018f4 <__adddf3+0x4b8>
10001c68:	0007883a 	mov	r3,zero
10001c6c:	5811883a 	mov	r8,r11
10001c70:	00bfffc4 	movi	r2,-1
10001c74:	0401ffc4 	movi	r16,2047
10001c78:	003e7806 	br	1000165c <__adddf3+0x220>
10001c7c:	4462b03a 	or	r17,r8,r17
10001c80:	8822c03a 	cmpne	r17,r17,zero
10001c84:	0009883a 	mov	r4,zero
10001c88:	003fa006 	br	10001b0c <__adddf3+0x6d0>
10001c8c:	4811883a 	mov	r8,r9
10001c90:	3023883a 	mov	r17,r6
10001c94:	0401ffc4 	movi	r16,2047
10001c98:	003e0706 	br	100014b8 <__adddf3+0x7c>
10001c9c:	4811883a 	mov	r8,r9
10001ca0:	3023883a 	mov	r17,r6
10001ca4:	003e0406 	br	100014b8 <__adddf3+0x7c>
10001ca8:	21fff804 	addi	r7,r4,-32
10001cac:	01400804 	movi	r5,32
10001cb0:	41ced83a 	srl	r7,r8,r7
10001cb4:	21400a26 	beq	r4,r5,10001ce0 <__adddf3+0x8a4>
10001cb8:	01401004 	movi	r5,64
10001cbc:	2909c83a 	sub	r4,r5,r4
10001cc0:	4108983a 	sll	r4,r8,r4
10001cc4:	2448b03a 	or	r4,r4,r17
10001cc8:	2008c03a 	cmpne	r4,r4,zero
10001ccc:	3922b03a 	or	r17,r7,r4
10001cd0:	0009883a 	mov	r4,zero
10001cd4:	003f8d06 	br	10001b0c <__adddf3+0x6d0>
10001cd8:	0007883a 	mov	r3,zero
10001cdc:	003fdd06 	br	10001c54 <__adddf3+0x818>
10001ce0:	0009883a 	mov	r4,zero
10001ce4:	003ff706 	br	10001cc4 <__adddf3+0x888>

10001ce8 <__divdf3>:
10001ce8:	defff204 	addi	sp,sp,-56
10001cec:	dd400915 	stw	r21,36(sp)
10001cf0:	282ad53a 	srli	r21,r5,20
10001cf4:	dd000815 	stw	r20,32(sp)
10001cf8:	2828d7fa 	srli	r20,r5,31
10001cfc:	dc000415 	stw	r16,16(sp)
10001d00:	04000434 	movhi	r16,16
10001d04:	df000c15 	stw	fp,48(sp)
10001d08:	843fffc4 	addi	r16,r16,-1
10001d0c:	dfc00d15 	stw	ra,52(sp)
10001d10:	ddc00b15 	stw	r23,44(sp)
10001d14:	dd800a15 	stw	r22,40(sp)
10001d18:	dcc00715 	stw	r19,28(sp)
10001d1c:	dc800615 	stw	r18,24(sp)
10001d20:	dc400515 	stw	r17,20(sp)
10001d24:	ad41ffcc 	andi	r21,r21,2047
10001d28:	2c20703a 	and	r16,r5,r16
10001d2c:	a7003fcc 	andi	fp,r20,255
10001d30:	a8006126 	beq	r21,zero,10001eb8 <__divdf3+0x1d0>
10001d34:	0081ffc4 	movi	r2,2047
10001d38:	2025883a 	mov	r18,r4
10001d3c:	a8803726 	beq	r21,r2,10001e1c <__divdf3+0x134>
10001d40:	80800434 	orhi	r2,r16,16
10001d44:	100490fa 	slli	r2,r2,3
10001d48:	2020d77a 	srli	r16,r4,29
10001d4c:	202490fa 	slli	r18,r4,3
10001d50:	ad7f0044 	addi	r21,r21,-1023
10001d54:	80a0b03a 	or	r16,r16,r2
10001d58:	0027883a 	mov	r19,zero
10001d5c:	0013883a 	mov	r9,zero
10001d60:	3804d53a 	srli	r2,r7,20
10001d64:	382cd7fa 	srli	r22,r7,31
10001d68:	04400434 	movhi	r17,16
10001d6c:	8c7fffc4 	addi	r17,r17,-1
10001d70:	1081ffcc 	andi	r2,r2,2047
10001d74:	3011883a 	mov	r8,r6
10001d78:	3c62703a 	and	r17,r7,r17
10001d7c:	b5c03fcc 	andi	r23,r22,255
10001d80:	10006c26 	beq	r2,zero,10001f34 <__divdf3+0x24c>
10001d84:	00c1ffc4 	movi	r3,2047
10001d88:	10c06426 	beq	r2,r3,10001f1c <__divdf3+0x234>
10001d8c:	88c00434 	orhi	r3,r17,16
10001d90:	180690fa 	slli	r3,r3,3
10001d94:	3022d77a 	srli	r17,r6,29
10001d98:	301090fa 	slli	r8,r6,3
10001d9c:	10bf0044 	addi	r2,r2,-1023
10001da0:	88e2b03a 	or	r17,r17,r3
10001da4:	000f883a 	mov	r7,zero
10001da8:	a58cf03a 	xor	r6,r20,r22
10001dac:	3cc8b03a 	or	r4,r7,r19
10001db0:	a8abc83a 	sub	r21,r21,r2
10001db4:	008003c4 	movi	r2,15
10001db8:	3007883a 	mov	r3,r6
10001dbc:	34c03fcc 	andi	r19,r6,255
10001dc0:	11009036 	bltu	r2,r4,10002004 <__divdf3+0x31c>
10001dc4:	200890ba 	slli	r4,r4,2
10001dc8:	00840034 	movhi	r2,4096
10001dcc:	10877704 	addi	r2,r2,7644
10001dd0:	2089883a 	add	r4,r4,r2
10001dd4:	20800017 	ldw	r2,0(r4)
10001dd8:	1000683a 	jmp	r2
10001ddc:	10002004 	addi	zero,r2,128
10001de0:	10001e54 	ori	zero,r2,121
10001de4:	10001ff4 	orhi	zero,r2,127
10001de8:	10001e48 	cmpgei	zero,r2,121
10001dec:	10001ff4 	orhi	zero,r2,127
10001df0:	10001fc8 	cmpgei	zero,r2,127
10001df4:	10001ff4 	orhi	zero,r2,127
10001df8:	10001e48 	cmpgei	zero,r2,121
10001dfc:	10001e54 	ori	zero,r2,121
10001e00:	10001e54 	ori	zero,r2,121
10001e04:	10001fc8 	cmpgei	zero,r2,127
10001e08:	10001e48 	cmpgei	zero,r2,121
10001e0c:	10001e38 	rdprs	zero,r2,120
10001e10:	10001e38 	rdprs	zero,r2,120
10001e14:	10001e38 	rdprs	zero,r2,120
10001e18:	100022e8 	cmpgeui	zero,r2,139
10001e1c:	2404b03a 	or	r2,r4,r16
10001e20:	1000661e 	bne	r2,zero,10001fbc <__divdf3+0x2d4>
10001e24:	04c00204 	movi	r19,8
10001e28:	0021883a 	mov	r16,zero
10001e2c:	0025883a 	mov	r18,zero
10001e30:	02400084 	movi	r9,2
10001e34:	003fca06 	br	10001d60 <__divdf3+0x78>
10001e38:	8023883a 	mov	r17,r16
10001e3c:	9011883a 	mov	r8,r18
10001e40:	e02f883a 	mov	r23,fp
10001e44:	480f883a 	mov	r7,r9
10001e48:	00800084 	movi	r2,2
10001e4c:	3881311e 	bne	r7,r2,10002314 <__divdf3+0x62c>
10001e50:	b827883a 	mov	r19,r23
10001e54:	98c0004c 	andi	r3,r19,1
10001e58:	0081ffc4 	movi	r2,2047
10001e5c:	000b883a 	mov	r5,zero
10001e60:	0025883a 	mov	r18,zero
10001e64:	1004953a 	slli	r2,r2,20
10001e68:	18c03fcc 	andi	r3,r3,255
10001e6c:	04400434 	movhi	r17,16
10001e70:	8c7fffc4 	addi	r17,r17,-1
10001e74:	180697fa 	slli	r3,r3,31
10001e78:	2c4a703a 	and	r5,r5,r17
10001e7c:	288ab03a 	or	r5,r5,r2
10001e80:	28c6b03a 	or	r3,r5,r3
10001e84:	9005883a 	mov	r2,r18
10001e88:	dfc00d17 	ldw	ra,52(sp)
10001e8c:	df000c17 	ldw	fp,48(sp)
10001e90:	ddc00b17 	ldw	r23,44(sp)
10001e94:	dd800a17 	ldw	r22,40(sp)
10001e98:	dd400917 	ldw	r21,36(sp)
10001e9c:	dd000817 	ldw	r20,32(sp)
10001ea0:	dcc00717 	ldw	r19,28(sp)
10001ea4:	dc800617 	ldw	r18,24(sp)
10001ea8:	dc400517 	ldw	r17,20(sp)
10001eac:	dc000417 	ldw	r16,16(sp)
10001eb0:	dec00e04 	addi	sp,sp,56
10001eb4:	f800283a 	ret
10001eb8:	2404b03a 	or	r2,r4,r16
10001ebc:	2027883a 	mov	r19,r4
10001ec0:	10003926 	beq	r2,zero,10001fa8 <__divdf3+0x2c0>
10001ec4:	80012e26 	beq	r16,zero,10002380 <__divdf3+0x698>
10001ec8:	8009883a 	mov	r4,r16
10001ecc:	d9800315 	stw	r6,12(sp)
10001ed0:	d9c00215 	stw	r7,8(sp)
10001ed4:	000307c0 	call	1000307c <__clzsi2>
10001ed8:	d9800317 	ldw	r6,12(sp)
10001edc:	d9c00217 	ldw	r7,8(sp)
10001ee0:	113ffd44 	addi	r4,r2,-11
10001ee4:	00c00704 	movi	r3,28
10001ee8:	19012116 	blt	r3,r4,10002370 <__divdf3+0x688>
10001eec:	00c00744 	movi	r3,29
10001ef0:	147ffe04 	addi	r17,r2,-8
10001ef4:	1907c83a 	sub	r3,r3,r4
10001ef8:	8460983a 	sll	r16,r16,r17
10001efc:	98c6d83a 	srl	r3,r19,r3
10001f00:	9c64983a 	sll	r18,r19,r17
10001f04:	1c20b03a 	or	r16,r3,r16
10001f08:	1080fcc4 	addi	r2,r2,1011
10001f0c:	00abc83a 	sub	r21,zero,r2
10001f10:	0027883a 	mov	r19,zero
10001f14:	0013883a 	mov	r9,zero
10001f18:	003f9106 	br	10001d60 <__divdf3+0x78>
10001f1c:	3446b03a 	or	r3,r6,r17
10001f20:	18001f1e 	bne	r3,zero,10001fa0 <__divdf3+0x2b8>
10001f24:	0023883a 	mov	r17,zero
10001f28:	0011883a 	mov	r8,zero
10001f2c:	01c00084 	movi	r7,2
10001f30:	003f9d06 	br	10001da8 <__divdf3+0xc0>
10001f34:	3446b03a 	or	r3,r6,r17
10001f38:	18001526 	beq	r3,zero,10001f90 <__divdf3+0x2a8>
10001f3c:	88011b26 	beq	r17,zero,100023ac <__divdf3+0x6c4>
10001f40:	8809883a 	mov	r4,r17
10001f44:	d9800315 	stw	r6,12(sp)
10001f48:	da400115 	stw	r9,4(sp)
10001f4c:	000307c0 	call	1000307c <__clzsi2>
10001f50:	d9800317 	ldw	r6,12(sp)
10001f54:	da400117 	ldw	r9,4(sp)
10001f58:	113ffd44 	addi	r4,r2,-11
10001f5c:	00c00704 	movi	r3,28
10001f60:	19010e16 	blt	r3,r4,1000239c <__divdf3+0x6b4>
10001f64:	00c00744 	movi	r3,29
10001f68:	123ffe04 	addi	r8,r2,-8
10001f6c:	1907c83a 	sub	r3,r3,r4
10001f70:	8a22983a 	sll	r17,r17,r8
10001f74:	30c6d83a 	srl	r3,r6,r3
10001f78:	3210983a 	sll	r8,r6,r8
10001f7c:	1c62b03a 	or	r17,r3,r17
10001f80:	1080fcc4 	addi	r2,r2,1011
10001f84:	0085c83a 	sub	r2,zero,r2
10001f88:	000f883a 	mov	r7,zero
10001f8c:	003f8606 	br	10001da8 <__divdf3+0xc0>
10001f90:	0023883a 	mov	r17,zero
10001f94:	0011883a 	mov	r8,zero
10001f98:	01c00044 	movi	r7,1
10001f9c:	003f8206 	br	10001da8 <__divdf3+0xc0>
10001fa0:	01c000c4 	movi	r7,3
10001fa4:	003f8006 	br	10001da8 <__divdf3+0xc0>
10001fa8:	04c00104 	movi	r19,4
10001fac:	0021883a 	mov	r16,zero
10001fb0:	0025883a 	mov	r18,zero
10001fb4:	02400044 	movi	r9,1
10001fb8:	003f6906 	br	10001d60 <__divdf3+0x78>
10001fbc:	04c00304 	movi	r19,12
10001fc0:	024000c4 	movi	r9,3
10001fc4:	003f6606 	br	10001d60 <__divdf3+0x78>
10001fc8:	01400434 	movhi	r5,16
10001fcc:	0007883a 	mov	r3,zero
10001fd0:	297fffc4 	addi	r5,r5,-1
10001fd4:	04bfffc4 	movi	r18,-1
10001fd8:	0081ffc4 	movi	r2,2047
10001fdc:	003fa106 	br	10001e64 <__divdf3+0x17c>
10001fe0:	00c00044 	movi	r3,1
10001fe4:	1887c83a 	sub	r3,r3,r2
10001fe8:	01000e04 	movi	r4,56
10001fec:	20c1210e 	bge	r4,r3,10002474 <__divdf3+0x78c>
10001ff0:	98c0004c 	andi	r3,r19,1
10001ff4:	0005883a 	mov	r2,zero
10001ff8:	000b883a 	mov	r5,zero
10001ffc:	0025883a 	mov	r18,zero
10002000:	003f9806 	br	10001e64 <__divdf3+0x17c>
10002004:	8c00fd36 	bltu	r17,r16,100023fc <__divdf3+0x714>
10002008:	8440fb26 	beq	r16,r17,100023f8 <__divdf3+0x710>
1000200c:	8007883a 	mov	r3,r16
10002010:	ad7fffc4 	addi	r21,r21,-1
10002014:	0021883a 	mov	r16,zero
10002018:	4004d63a 	srli	r2,r8,24
1000201c:	8822923a 	slli	r17,r17,8
10002020:	1809883a 	mov	r4,r3
10002024:	402c923a 	slli	r22,r8,8
10002028:	88b8b03a 	or	fp,r17,r2
1000202c:	e028d43a 	srli	r20,fp,16
10002030:	d8c00015 	stw	r3,0(sp)
10002034:	e5ffffcc 	andi	r23,fp,65535
10002038:	a00b883a 	mov	r5,r20
1000203c:	00031d80 	call	100031d8 <__udivsi3>
10002040:	d8c00017 	ldw	r3,0(sp)
10002044:	a00b883a 	mov	r5,r20
10002048:	d8800315 	stw	r2,12(sp)
1000204c:	1809883a 	mov	r4,r3
10002050:	000323c0 	call	1000323c <__umodsi3>
10002054:	d9800317 	ldw	r6,12(sp)
10002058:	1006943a 	slli	r3,r2,16
1000205c:	9004d43a 	srli	r2,r18,16
10002060:	b9a3383a 	mul	r17,r23,r6
10002064:	10c4b03a 	or	r2,r2,r3
10002068:	1440062e 	bgeu	r2,r17,10002084 <__divdf3+0x39c>
1000206c:	1705883a 	add	r2,r2,fp
10002070:	30ffffc4 	addi	r3,r6,-1
10002074:	1700ee36 	bltu	r2,fp,10002430 <__divdf3+0x748>
10002078:	1440ed2e 	bgeu	r2,r17,10002430 <__divdf3+0x748>
1000207c:	31bfff84 	addi	r6,r6,-2
10002080:	1705883a 	add	r2,r2,fp
10002084:	1463c83a 	sub	r17,r2,r17
10002088:	a00b883a 	mov	r5,r20
1000208c:	8809883a 	mov	r4,r17
10002090:	d9800315 	stw	r6,12(sp)
10002094:	00031d80 	call	100031d8 <__udivsi3>
10002098:	a00b883a 	mov	r5,r20
1000209c:	8809883a 	mov	r4,r17
100020a0:	d8800215 	stw	r2,8(sp)
100020a4:	000323c0 	call	1000323c <__umodsi3>
100020a8:	d9c00217 	ldw	r7,8(sp)
100020ac:	1004943a 	slli	r2,r2,16
100020b0:	94bfffcc 	andi	r18,r18,65535
100020b4:	b9d1383a 	mul	r8,r23,r7
100020b8:	90a4b03a 	or	r18,r18,r2
100020bc:	d9800317 	ldw	r6,12(sp)
100020c0:	9200062e 	bgeu	r18,r8,100020dc <__divdf3+0x3f4>
100020c4:	9725883a 	add	r18,r18,fp
100020c8:	38bfffc4 	addi	r2,r7,-1
100020cc:	9700d636 	bltu	r18,fp,10002428 <__divdf3+0x740>
100020d0:	9200d52e 	bgeu	r18,r8,10002428 <__divdf3+0x740>
100020d4:	39ffff84 	addi	r7,r7,-2
100020d8:	9725883a 	add	r18,r18,fp
100020dc:	3004943a 	slli	r2,r6,16
100020e0:	b012d43a 	srli	r9,r22,16
100020e4:	b1bfffcc 	andi	r6,r22,65535
100020e8:	11e2b03a 	or	r17,r2,r7
100020ec:	8806d43a 	srli	r3,r17,16
100020f0:	893fffcc 	andi	r4,r17,65535
100020f4:	218b383a 	mul	r5,r4,r6
100020f8:	30c5383a 	mul	r2,r6,r3
100020fc:	2249383a 	mul	r4,r4,r9
10002100:	280ed43a 	srli	r7,r5,16
10002104:	9225c83a 	sub	r18,r18,r8
10002108:	2089883a 	add	r4,r4,r2
1000210c:	3909883a 	add	r4,r7,r4
10002110:	1a47383a 	mul	r3,r3,r9
10002114:	2080022e 	bgeu	r4,r2,10002120 <__divdf3+0x438>
10002118:	00800074 	movhi	r2,1
1000211c:	1887883a 	add	r3,r3,r2
10002120:	2004d43a 	srli	r2,r4,16
10002124:	2008943a 	slli	r4,r4,16
10002128:	297fffcc 	andi	r5,r5,65535
1000212c:	10c7883a 	add	r3,r2,r3
10002130:	2149883a 	add	r4,r4,r5
10002134:	90c0a536 	bltu	r18,r3,100023cc <__divdf3+0x6e4>
10002138:	90c0bf26 	beq	r18,r3,10002438 <__divdf3+0x750>
1000213c:	90c7c83a 	sub	r3,r18,r3
10002140:	810fc83a 	sub	r7,r16,r4
10002144:	81e5803a 	cmpltu	r18,r16,r7
10002148:	1ca5c83a 	sub	r18,r3,r18
1000214c:	e480c126 	beq	fp,r18,10002454 <__divdf3+0x76c>
10002150:	a00b883a 	mov	r5,r20
10002154:	9009883a 	mov	r4,r18
10002158:	d9800315 	stw	r6,12(sp)
1000215c:	d9c00215 	stw	r7,8(sp)
10002160:	da400115 	stw	r9,4(sp)
10002164:	00031d80 	call	100031d8 <__udivsi3>
10002168:	a00b883a 	mov	r5,r20
1000216c:	9009883a 	mov	r4,r18
10002170:	d8800015 	stw	r2,0(sp)
10002174:	000323c0 	call	1000323c <__umodsi3>
10002178:	d9c00217 	ldw	r7,8(sp)
1000217c:	da000017 	ldw	r8,0(sp)
10002180:	1006943a 	slli	r3,r2,16
10002184:	3804d43a 	srli	r2,r7,16
10002188:	ba21383a 	mul	r16,r23,r8
1000218c:	d9800317 	ldw	r6,12(sp)
10002190:	10c4b03a 	or	r2,r2,r3
10002194:	da400117 	ldw	r9,4(sp)
10002198:	1400062e 	bgeu	r2,r16,100021b4 <__divdf3+0x4cc>
1000219c:	1705883a 	add	r2,r2,fp
100021a0:	40ffffc4 	addi	r3,r8,-1
100021a4:	1700ad36 	bltu	r2,fp,1000245c <__divdf3+0x774>
100021a8:	1400ac2e 	bgeu	r2,r16,1000245c <__divdf3+0x774>
100021ac:	423fff84 	addi	r8,r8,-2
100021b0:	1705883a 	add	r2,r2,fp
100021b4:	1421c83a 	sub	r16,r2,r16
100021b8:	a00b883a 	mov	r5,r20
100021bc:	8009883a 	mov	r4,r16
100021c0:	d9800315 	stw	r6,12(sp)
100021c4:	d9c00215 	stw	r7,8(sp)
100021c8:	da000015 	stw	r8,0(sp)
100021cc:	da400115 	stw	r9,4(sp)
100021d0:	00031d80 	call	100031d8 <__udivsi3>
100021d4:	8009883a 	mov	r4,r16
100021d8:	a00b883a 	mov	r5,r20
100021dc:	1025883a 	mov	r18,r2
100021e0:	000323c0 	call	1000323c <__umodsi3>
100021e4:	d9c00217 	ldw	r7,8(sp)
100021e8:	1004943a 	slli	r2,r2,16
100021ec:	bcaf383a 	mul	r23,r23,r18
100021f0:	393fffcc 	andi	r4,r7,65535
100021f4:	2088b03a 	or	r4,r4,r2
100021f8:	d9800317 	ldw	r6,12(sp)
100021fc:	da000017 	ldw	r8,0(sp)
10002200:	da400117 	ldw	r9,4(sp)
10002204:	25c0062e 	bgeu	r4,r23,10002220 <__divdf3+0x538>
10002208:	2709883a 	add	r4,r4,fp
1000220c:	90bfffc4 	addi	r2,r18,-1
10002210:	27009436 	bltu	r4,fp,10002464 <__divdf3+0x77c>
10002214:	25c0932e 	bgeu	r4,r23,10002464 <__divdf3+0x77c>
10002218:	94bfff84 	addi	r18,r18,-2
1000221c:	2709883a 	add	r4,r4,fp
10002220:	4004943a 	slli	r2,r8,16
10002224:	25efc83a 	sub	r23,r4,r23
10002228:	1490b03a 	or	r8,r2,r18
1000222c:	4008d43a 	srli	r4,r8,16
10002230:	40ffffcc 	andi	r3,r8,65535
10002234:	30c5383a 	mul	r2,r6,r3
10002238:	1a47383a 	mul	r3,r3,r9
1000223c:	310d383a 	mul	r6,r6,r4
10002240:	100ad43a 	srli	r5,r2,16
10002244:	4913383a 	mul	r9,r9,r4
10002248:	1987883a 	add	r3,r3,r6
1000224c:	28c7883a 	add	r3,r5,r3
10002250:	1980022e 	bgeu	r3,r6,1000225c <__divdf3+0x574>
10002254:	01000074 	movhi	r4,1
10002258:	4913883a 	add	r9,r9,r4
1000225c:	1808d43a 	srli	r4,r3,16
10002260:	1806943a 	slli	r3,r3,16
10002264:	10bfffcc 	andi	r2,r2,65535
10002268:	2253883a 	add	r9,r4,r9
1000226c:	1887883a 	add	r3,r3,r2
10002270:	ba403836 	bltu	r23,r9,10002354 <__divdf3+0x66c>
10002274:	ba403626 	beq	r23,r9,10002350 <__divdf3+0x668>
10002278:	42000054 	ori	r8,r8,1
1000227c:	a880ffc4 	addi	r2,r21,1023
10002280:	00bf570e 	bge	zero,r2,10001fe0 <__divdf3+0x2f8>
10002284:	40c001cc 	andi	r3,r8,7
10002288:	18000726 	beq	r3,zero,100022a8 <__divdf3+0x5c0>
1000228c:	40c003cc 	andi	r3,r8,15
10002290:	01000104 	movi	r4,4
10002294:	19000426 	beq	r3,r4,100022a8 <__divdf3+0x5c0>
10002298:	4107883a 	add	r3,r8,r4
1000229c:	1a11803a 	cmpltu	r8,r3,r8
100022a0:	8a23883a 	add	r17,r17,r8
100022a4:	1811883a 	mov	r8,r3
100022a8:	88c0402c 	andhi	r3,r17,256
100022ac:	18000426 	beq	r3,zero,100022c0 <__divdf3+0x5d8>
100022b0:	00ffc034 	movhi	r3,65280
100022b4:	18ffffc4 	addi	r3,r3,-1
100022b8:	a8810004 	addi	r2,r21,1024
100022bc:	88e2703a 	and	r17,r17,r3
100022c0:	00c1ff84 	movi	r3,2046
100022c4:	18bee316 	blt	r3,r2,10001e54 <__divdf3+0x16c>
100022c8:	8824977a 	slli	r18,r17,29
100022cc:	4010d0fa 	srli	r8,r8,3
100022d0:	8822927a 	slli	r17,r17,9
100022d4:	1081ffcc 	andi	r2,r2,2047
100022d8:	9224b03a 	or	r18,r18,r8
100022dc:	880ad33a 	srli	r5,r17,12
100022e0:	98c0004c 	andi	r3,r19,1
100022e4:	003edf06 	br	10001e64 <__divdf3+0x17c>
100022e8:	8080022c 	andhi	r2,r16,8
100022ec:	10001226 	beq	r2,zero,10002338 <__divdf3+0x650>
100022f0:	8880022c 	andhi	r2,r17,8
100022f4:	1000101e 	bne	r2,zero,10002338 <__divdf3+0x650>
100022f8:	00800434 	movhi	r2,16
100022fc:	89400234 	orhi	r5,r17,8
10002300:	10bfffc4 	addi	r2,r2,-1
10002304:	b007883a 	mov	r3,r22
10002308:	288a703a 	and	r5,r5,r2
1000230c:	4025883a 	mov	r18,r8
10002310:	003f3106 	br	10001fd8 <__divdf3+0x2f0>
10002314:	008000c4 	movi	r2,3
10002318:	3880a626 	beq	r7,r2,100025b4 <__divdf3+0x8cc>
1000231c:	00800044 	movi	r2,1
10002320:	3880521e 	bne	r7,r2,1000246c <__divdf3+0x784>
10002324:	b807883a 	mov	r3,r23
10002328:	0005883a 	mov	r2,zero
1000232c:	000b883a 	mov	r5,zero
10002330:	0025883a 	mov	r18,zero
10002334:	003ecb06 	br	10001e64 <__divdf3+0x17c>
10002338:	00800434 	movhi	r2,16
1000233c:	81400234 	orhi	r5,r16,8
10002340:	10bfffc4 	addi	r2,r2,-1
10002344:	a007883a 	mov	r3,r20
10002348:	288a703a 	and	r5,r5,r2
1000234c:	003f2206 	br	10001fd8 <__divdf3+0x2f0>
10002350:	183fca26 	beq	r3,zero,1000227c <__divdf3+0x594>
10002354:	e5ef883a 	add	r23,fp,r23
10002358:	40bfffc4 	addi	r2,r8,-1
1000235c:	bf00392e 	bgeu	r23,fp,10002444 <__divdf3+0x75c>
10002360:	1011883a 	mov	r8,r2
10002364:	ba7fc41e 	bne	r23,r9,10002278 <__divdf3+0x590>
10002368:	b0ffc31e 	bne	r22,r3,10002278 <__divdf3+0x590>
1000236c:	003fc306 	br	1000227c <__divdf3+0x594>
10002370:	143ff604 	addi	r16,r2,-40
10002374:	9c20983a 	sll	r16,r19,r16
10002378:	0025883a 	mov	r18,zero
1000237c:	003ee206 	br	10001f08 <__divdf3+0x220>
10002380:	d9800315 	stw	r6,12(sp)
10002384:	d9c00215 	stw	r7,8(sp)
10002388:	000307c0 	call	1000307c <__clzsi2>
1000238c:	10800804 	addi	r2,r2,32
10002390:	d9c00217 	ldw	r7,8(sp)
10002394:	d9800317 	ldw	r6,12(sp)
10002398:	003ed106 	br	10001ee0 <__divdf3+0x1f8>
1000239c:	147ff604 	addi	r17,r2,-40
100023a0:	3462983a 	sll	r17,r6,r17
100023a4:	0011883a 	mov	r8,zero
100023a8:	003ef506 	br	10001f80 <__divdf3+0x298>
100023ac:	3009883a 	mov	r4,r6
100023b0:	d9800315 	stw	r6,12(sp)
100023b4:	da400115 	stw	r9,4(sp)
100023b8:	000307c0 	call	1000307c <__clzsi2>
100023bc:	10800804 	addi	r2,r2,32
100023c0:	da400117 	ldw	r9,4(sp)
100023c4:	d9800317 	ldw	r6,12(sp)
100023c8:	003ee306 	br	10001f58 <__divdf3+0x270>
100023cc:	85a1883a 	add	r16,r16,r22
100023d0:	8585803a 	cmpltu	r2,r16,r22
100023d4:	1705883a 	add	r2,r2,fp
100023d8:	14a5883a 	add	r18,r2,r18
100023dc:	88bfffc4 	addi	r2,r17,-1
100023e0:	e4800c2e 	bgeu	fp,r18,10002414 <__divdf3+0x72c>
100023e4:	90c03e36 	bltu	r18,r3,100024e0 <__divdf3+0x7f8>
100023e8:	1c806926 	beq	r3,r18,10002590 <__divdf3+0x8a8>
100023ec:	90c7c83a 	sub	r3,r18,r3
100023f0:	1023883a 	mov	r17,r2
100023f4:	003f5206 	br	10002140 <__divdf3+0x458>
100023f8:	923f0436 	bltu	r18,r8,1000200c <__divdf3+0x324>
100023fc:	800897fa 	slli	r4,r16,31
10002400:	9004d07a 	srli	r2,r18,1
10002404:	8006d07a 	srli	r3,r16,1
10002408:	902097fa 	slli	r16,r18,31
1000240c:	20a4b03a 	or	r18,r4,r2
10002410:	003f0106 	br	10002018 <__divdf3+0x330>
10002414:	e4bff51e 	bne	fp,r18,100023ec <__divdf3+0x704>
10002418:	85bff22e 	bgeu	r16,r22,100023e4 <__divdf3+0x6fc>
1000241c:	e0c7c83a 	sub	r3,fp,r3
10002420:	1023883a 	mov	r17,r2
10002424:	003f4606 	br	10002140 <__divdf3+0x458>
10002428:	100f883a 	mov	r7,r2
1000242c:	003f2b06 	br	100020dc <__divdf3+0x3f4>
10002430:	180d883a 	mov	r6,r3
10002434:	003f1306 	br	10002084 <__divdf3+0x39c>
10002438:	813fe436 	bltu	r16,r4,100023cc <__divdf3+0x6e4>
1000243c:	0007883a 	mov	r3,zero
10002440:	003f3f06 	br	10002140 <__divdf3+0x458>
10002444:	ba402c36 	bltu	r23,r9,100024f8 <__divdf3+0x810>
10002448:	4dc05426 	beq	r9,r23,1000259c <__divdf3+0x8b4>
1000244c:	1011883a 	mov	r8,r2
10002450:	003f8906 	br	10002278 <__divdf3+0x590>
10002454:	023fffc4 	movi	r8,-1
10002458:	003f8806 	br	1000227c <__divdf3+0x594>
1000245c:	1811883a 	mov	r8,r3
10002460:	003f5406 	br	100021b4 <__divdf3+0x4cc>
10002464:	1025883a 	mov	r18,r2
10002468:	003f6d06 	br	10002220 <__divdf3+0x538>
1000246c:	b827883a 	mov	r19,r23
10002470:	003f8206 	br	1000227c <__divdf3+0x594>
10002474:	010007c4 	movi	r4,31
10002478:	20c02616 	blt	r4,r3,10002514 <__divdf3+0x82c>
1000247c:	00800804 	movi	r2,32
10002480:	10c5c83a 	sub	r2,r2,r3
10002484:	888a983a 	sll	r5,r17,r2
10002488:	40c8d83a 	srl	r4,r8,r3
1000248c:	4084983a 	sll	r2,r8,r2
10002490:	88e2d83a 	srl	r17,r17,r3
10002494:	2906b03a 	or	r3,r5,r4
10002498:	1004c03a 	cmpne	r2,r2,zero
1000249c:	1886b03a 	or	r3,r3,r2
100024a0:	188001cc 	andi	r2,r3,7
100024a4:	10000726 	beq	r2,zero,100024c4 <__divdf3+0x7dc>
100024a8:	188003cc 	andi	r2,r3,15
100024ac:	01000104 	movi	r4,4
100024b0:	11000426 	beq	r2,r4,100024c4 <__divdf3+0x7dc>
100024b4:	1805883a 	mov	r2,r3
100024b8:	10c00104 	addi	r3,r2,4
100024bc:	1885803a 	cmpltu	r2,r3,r2
100024c0:	88a3883a 	add	r17,r17,r2
100024c4:	8880202c 	andhi	r2,r17,128
100024c8:	10002726 	beq	r2,zero,10002568 <__divdf3+0x880>
100024cc:	98c0004c 	andi	r3,r19,1
100024d0:	00800044 	movi	r2,1
100024d4:	000b883a 	mov	r5,zero
100024d8:	0025883a 	mov	r18,zero
100024dc:	003e6106 	br	10001e64 <__divdf3+0x17c>
100024e0:	85a1883a 	add	r16,r16,r22
100024e4:	8585803a 	cmpltu	r2,r16,r22
100024e8:	1705883a 	add	r2,r2,fp
100024ec:	14a5883a 	add	r18,r2,r18
100024f0:	8c7fff84 	addi	r17,r17,-2
100024f4:	003f1106 	br	1000213c <__divdf3+0x454>
100024f8:	b589883a 	add	r4,r22,r22
100024fc:	25ad803a 	cmpltu	r22,r4,r22
10002500:	b739883a 	add	fp,r22,fp
10002504:	40bfff84 	addi	r2,r8,-2
10002508:	bf2f883a 	add	r23,r23,fp
1000250c:	202d883a 	mov	r22,r4
10002510:	003f9306 	br	10002360 <__divdf3+0x678>
10002514:	013ff844 	movi	r4,-31
10002518:	2085c83a 	sub	r2,r4,r2
1000251c:	8888d83a 	srl	r4,r17,r2
10002520:	00800804 	movi	r2,32
10002524:	18802126 	beq	r3,r2,100025ac <__divdf3+0x8c4>
10002528:	00801004 	movi	r2,64
1000252c:	10c5c83a 	sub	r2,r2,r3
10002530:	8884983a 	sll	r2,r17,r2
10002534:	1204b03a 	or	r2,r2,r8
10002538:	1004c03a 	cmpne	r2,r2,zero
1000253c:	2084b03a 	or	r2,r4,r2
10002540:	144001cc 	andi	r17,r2,7
10002544:	88000d1e 	bne	r17,zero,1000257c <__divdf3+0x894>
10002548:	000b883a 	mov	r5,zero
1000254c:	1024d0fa 	srli	r18,r2,3
10002550:	98c0004c 	andi	r3,r19,1
10002554:	0005883a 	mov	r2,zero
10002558:	9464b03a 	or	r18,r18,r17
1000255c:	003e4106 	br	10001e64 <__divdf3+0x17c>
10002560:	1007883a 	mov	r3,r2
10002564:	0023883a 	mov	r17,zero
10002568:	880a927a 	slli	r5,r17,9
1000256c:	1805883a 	mov	r2,r3
10002570:	8822977a 	slli	r17,r17,29
10002574:	280ad33a 	srli	r5,r5,12
10002578:	003ff406 	br	1000254c <__divdf3+0x864>
1000257c:	10c003cc 	andi	r3,r2,15
10002580:	01000104 	movi	r4,4
10002584:	193ff626 	beq	r3,r4,10002560 <__divdf3+0x878>
10002588:	0023883a 	mov	r17,zero
1000258c:	003fca06 	br	100024b8 <__divdf3+0x7d0>
10002590:	813fd336 	bltu	r16,r4,100024e0 <__divdf3+0x7f8>
10002594:	1023883a 	mov	r17,r2
10002598:	003fa806 	br	1000243c <__divdf3+0x754>
1000259c:	b0ffd636 	bltu	r22,r3,100024f8 <__divdf3+0x810>
100025a0:	1011883a 	mov	r8,r2
100025a4:	b0ff341e 	bne	r22,r3,10002278 <__divdf3+0x590>
100025a8:	003f3406 	br	1000227c <__divdf3+0x594>
100025ac:	0005883a 	mov	r2,zero
100025b0:	003fe006 	br	10002534 <__divdf3+0x84c>
100025b4:	00800434 	movhi	r2,16
100025b8:	89400234 	orhi	r5,r17,8
100025bc:	10bfffc4 	addi	r2,r2,-1
100025c0:	b807883a 	mov	r3,r23
100025c4:	288a703a 	and	r5,r5,r2
100025c8:	4025883a 	mov	r18,r8
100025cc:	003e8206 	br	10001fd8 <__divdf3+0x2f0>

100025d0 <__muldf3>:
100025d0:	defff304 	addi	sp,sp,-52
100025d4:	2804d53a 	srli	r2,r5,20
100025d8:	dd800915 	stw	r22,36(sp)
100025dc:	282cd7fa 	srli	r22,r5,31
100025e0:	dc000315 	stw	r16,12(sp)
100025e4:	04000434 	movhi	r16,16
100025e8:	dd400815 	stw	r21,32(sp)
100025ec:	dc800515 	stw	r18,20(sp)
100025f0:	843fffc4 	addi	r16,r16,-1
100025f4:	dfc00c15 	stw	ra,48(sp)
100025f8:	df000b15 	stw	fp,44(sp)
100025fc:	ddc00a15 	stw	r23,40(sp)
10002600:	dd000715 	stw	r20,28(sp)
10002604:	dcc00615 	stw	r19,24(sp)
10002608:	dc400415 	stw	r17,16(sp)
1000260c:	1481ffcc 	andi	r18,r2,2047
10002610:	2c20703a 	and	r16,r5,r16
10002614:	b02b883a 	mov	r21,r22
10002618:	b2403fcc 	andi	r9,r22,255
1000261c:	90006026 	beq	r18,zero,100027a0 <__muldf3+0x1d0>
10002620:	0081ffc4 	movi	r2,2047
10002624:	2029883a 	mov	r20,r4
10002628:	90803626 	beq	r18,r2,10002704 <__muldf3+0x134>
1000262c:	80800434 	orhi	r2,r16,16
10002630:	100490fa 	slli	r2,r2,3
10002634:	2020d77a 	srli	r16,r4,29
10002638:	202890fa 	slli	r20,r4,3
1000263c:	94bf0044 	addi	r18,r18,-1023
10002640:	80a0b03a 	or	r16,r16,r2
10002644:	0027883a 	mov	r19,zero
10002648:	0039883a 	mov	fp,zero
1000264c:	3804d53a 	srli	r2,r7,20
10002650:	382ed7fa 	srli	r23,r7,31
10002654:	04400434 	movhi	r17,16
10002658:	8c7fffc4 	addi	r17,r17,-1
1000265c:	1081ffcc 	andi	r2,r2,2047
10002660:	3011883a 	mov	r8,r6
10002664:	3c62703a 	and	r17,r7,r17
10002668:	ba803fcc 	andi	r10,r23,255
1000266c:	10006d26 	beq	r2,zero,10002824 <__muldf3+0x254>
10002670:	00c1ffc4 	movi	r3,2047
10002674:	10c06526 	beq	r2,r3,1000280c <__muldf3+0x23c>
10002678:	88c00434 	orhi	r3,r17,16
1000267c:	180690fa 	slli	r3,r3,3
10002680:	3022d77a 	srli	r17,r6,29
10002684:	301090fa 	slli	r8,r6,3
10002688:	10bf0044 	addi	r2,r2,-1023
1000268c:	88e2b03a 	or	r17,r17,r3
10002690:	000b883a 	mov	r5,zero
10002694:	9085883a 	add	r2,r18,r2
10002698:	2cc8b03a 	or	r4,r5,r19
1000269c:	00c003c4 	movi	r3,15
100026a0:	bdacf03a 	xor	r22,r23,r22
100026a4:	12c00044 	addi	r11,r2,1
100026a8:	19009936 	bltu	r3,r4,10002910 <__muldf3+0x340>
100026ac:	200890ba 	slli	r4,r4,2
100026b0:	00c40034 	movhi	r3,4096
100026b4:	18c9b104 	addi	r3,r3,9924
100026b8:	20c9883a 	add	r4,r4,r3
100026bc:	20c00017 	ldw	r3,0(r4)
100026c0:	1800683a 	jmp	r3
100026c4:	10002910 	cmplti	zero,r2,164
100026c8:	10002724 	muli	zero,r2,156
100026cc:	10002724 	muli	zero,r2,156
100026d0:	10002720 	cmpeqi	zero,r2,156
100026d4:	100028ec 	andhi	zero,r2,163
100026d8:	100028ec 	andhi	zero,r2,163
100026dc:	100028d4 	ori	zero,r2,163
100026e0:	10002720 	cmpeqi	zero,r2,156
100026e4:	100028ec 	andhi	zero,r2,163
100026e8:	100028d4 	ori	zero,r2,163
100026ec:	100028ec 	andhi	zero,r2,163
100026f0:	10002720 	cmpeqi	zero,r2,156
100026f4:	100028fc 	xorhi	zero,r2,163
100026f8:	100028fc 	xorhi	zero,r2,163
100026fc:	100028fc 	xorhi	zero,r2,163
10002700:	10002b18 	cmpnei	zero,r2,172
10002704:	2404b03a 	or	r2,r4,r16
10002708:	10006f1e 	bne	r2,zero,100028c8 <__muldf3+0x2f8>
1000270c:	04c00204 	movi	r19,8
10002710:	0021883a 	mov	r16,zero
10002714:	0029883a 	mov	r20,zero
10002718:	07000084 	movi	fp,2
1000271c:	003fcb06 	br	1000264c <__muldf3+0x7c>
10002720:	502d883a 	mov	r22,r10
10002724:	00800084 	movi	r2,2
10002728:	28805726 	beq	r5,r2,10002888 <__muldf3+0x2b8>
1000272c:	008000c4 	movi	r2,3
10002730:	28816626 	beq	r5,r2,10002ccc <__muldf3+0x6fc>
10002734:	00800044 	movi	r2,1
10002738:	2881411e 	bne	r5,r2,10002c40 <__muldf3+0x670>
1000273c:	b02b883a 	mov	r21,r22
10002740:	0005883a 	mov	r2,zero
10002744:	000b883a 	mov	r5,zero
10002748:	0029883a 	mov	r20,zero
1000274c:	1004953a 	slli	r2,r2,20
10002750:	a8c03fcc 	andi	r3,r21,255
10002754:	04400434 	movhi	r17,16
10002758:	8c7fffc4 	addi	r17,r17,-1
1000275c:	180697fa 	slli	r3,r3,31
10002760:	2c4a703a 	and	r5,r5,r17
10002764:	288ab03a 	or	r5,r5,r2
10002768:	28c6b03a 	or	r3,r5,r3
1000276c:	a005883a 	mov	r2,r20
10002770:	dfc00c17 	ldw	ra,48(sp)
10002774:	df000b17 	ldw	fp,44(sp)
10002778:	ddc00a17 	ldw	r23,40(sp)
1000277c:	dd800917 	ldw	r22,36(sp)
10002780:	dd400817 	ldw	r21,32(sp)
10002784:	dd000717 	ldw	r20,28(sp)
10002788:	dcc00617 	ldw	r19,24(sp)
1000278c:	dc800517 	ldw	r18,20(sp)
10002790:	dc400417 	ldw	r17,16(sp)
10002794:	dc000317 	ldw	r16,12(sp)
10002798:	dec00d04 	addi	sp,sp,52
1000279c:	f800283a 	ret
100027a0:	2404b03a 	or	r2,r4,r16
100027a4:	2027883a 	mov	r19,r4
100027a8:	10004226 	beq	r2,zero,100028b4 <__muldf3+0x2e4>
100027ac:	8000fc26 	beq	r16,zero,10002ba0 <__muldf3+0x5d0>
100027b0:	8009883a 	mov	r4,r16
100027b4:	d9800215 	stw	r6,8(sp)
100027b8:	d9c00015 	stw	r7,0(sp)
100027bc:	da400115 	stw	r9,4(sp)
100027c0:	000307c0 	call	1000307c <__clzsi2>
100027c4:	d9800217 	ldw	r6,8(sp)
100027c8:	d9c00017 	ldw	r7,0(sp)
100027cc:	da400117 	ldw	r9,4(sp)
100027d0:	113ffd44 	addi	r4,r2,-11
100027d4:	00c00704 	movi	r3,28
100027d8:	1900ed16 	blt	r3,r4,10002b90 <__muldf3+0x5c0>
100027dc:	00c00744 	movi	r3,29
100027e0:	147ffe04 	addi	r17,r2,-8
100027e4:	1907c83a 	sub	r3,r3,r4
100027e8:	8460983a 	sll	r16,r16,r17
100027ec:	98c6d83a 	srl	r3,r19,r3
100027f0:	9c68983a 	sll	r20,r19,r17
100027f4:	1c20b03a 	or	r16,r3,r16
100027f8:	1080fcc4 	addi	r2,r2,1011
100027fc:	00a5c83a 	sub	r18,zero,r2
10002800:	0027883a 	mov	r19,zero
10002804:	0039883a 	mov	fp,zero
10002808:	003f9006 	br	1000264c <__muldf3+0x7c>
1000280c:	3446b03a 	or	r3,r6,r17
10002810:	1800261e 	bne	r3,zero,100028ac <__muldf3+0x2dc>
10002814:	0023883a 	mov	r17,zero
10002818:	0011883a 	mov	r8,zero
1000281c:	01400084 	movi	r5,2
10002820:	003f9c06 	br	10002694 <__muldf3+0xc4>
10002824:	3446b03a 	or	r3,r6,r17
10002828:	18001c26 	beq	r3,zero,1000289c <__muldf3+0x2cc>
1000282c:	8800ce26 	beq	r17,zero,10002b68 <__muldf3+0x598>
10002830:	8809883a 	mov	r4,r17
10002834:	d9800215 	stw	r6,8(sp)
10002838:	da400115 	stw	r9,4(sp)
1000283c:	da800015 	stw	r10,0(sp)
10002840:	000307c0 	call	1000307c <__clzsi2>
10002844:	d9800217 	ldw	r6,8(sp)
10002848:	da400117 	ldw	r9,4(sp)
1000284c:	da800017 	ldw	r10,0(sp)
10002850:	113ffd44 	addi	r4,r2,-11
10002854:	00c00704 	movi	r3,28
10002858:	1900bf16 	blt	r3,r4,10002b58 <__muldf3+0x588>
1000285c:	00c00744 	movi	r3,29
10002860:	123ffe04 	addi	r8,r2,-8
10002864:	1907c83a 	sub	r3,r3,r4
10002868:	8a22983a 	sll	r17,r17,r8
1000286c:	30c6d83a 	srl	r3,r6,r3
10002870:	3210983a 	sll	r8,r6,r8
10002874:	1c62b03a 	or	r17,r3,r17
10002878:	1080fcc4 	addi	r2,r2,1011
1000287c:	0085c83a 	sub	r2,zero,r2
10002880:	000b883a 	mov	r5,zero
10002884:	003f8306 	br	10002694 <__muldf3+0xc4>
10002888:	b02b883a 	mov	r21,r22
1000288c:	0081ffc4 	movi	r2,2047
10002890:	000b883a 	mov	r5,zero
10002894:	0029883a 	mov	r20,zero
10002898:	003fac06 	br	1000274c <__muldf3+0x17c>
1000289c:	0023883a 	mov	r17,zero
100028a0:	0011883a 	mov	r8,zero
100028a4:	01400044 	movi	r5,1
100028a8:	003f7a06 	br	10002694 <__muldf3+0xc4>
100028ac:	014000c4 	movi	r5,3
100028b0:	003f7806 	br	10002694 <__muldf3+0xc4>
100028b4:	04c00104 	movi	r19,4
100028b8:	0021883a 	mov	r16,zero
100028bc:	0029883a 	mov	r20,zero
100028c0:	07000044 	movi	fp,1
100028c4:	003f6106 	br	1000264c <__muldf3+0x7c>
100028c8:	04c00304 	movi	r19,12
100028cc:	070000c4 	movi	fp,3
100028d0:	003f5e06 	br	1000264c <__muldf3+0x7c>
100028d4:	01400434 	movhi	r5,16
100028d8:	002b883a 	mov	r21,zero
100028dc:	297fffc4 	addi	r5,r5,-1
100028e0:	053fffc4 	movi	r20,-1
100028e4:	0081ffc4 	movi	r2,2047
100028e8:	003f9806 	br	1000274c <__muldf3+0x17c>
100028ec:	8023883a 	mov	r17,r16
100028f0:	a011883a 	mov	r8,r20
100028f4:	e00b883a 	mov	r5,fp
100028f8:	003f8a06 	br	10002724 <__muldf3+0x154>
100028fc:	8023883a 	mov	r17,r16
10002900:	a011883a 	mov	r8,r20
10002904:	482d883a 	mov	r22,r9
10002908:	e00b883a 	mov	r5,fp
1000290c:	003f8506 	br	10002724 <__muldf3+0x154>
10002910:	a00ad43a 	srli	r5,r20,16
10002914:	401ad43a 	srli	r13,r8,16
10002918:	a53fffcc 	andi	r20,r20,65535
1000291c:	423fffcc 	andi	r8,r8,65535
10002920:	4519383a 	mul	r12,r8,r20
10002924:	4147383a 	mul	r3,r8,r5
10002928:	6d09383a 	mul	r4,r13,r20
1000292c:	600cd43a 	srli	r6,r12,16
10002930:	2b5d383a 	mul	r14,r5,r13
10002934:	20c9883a 	add	r4,r4,r3
10002938:	310d883a 	add	r6,r6,r4
1000293c:	30c0022e 	bgeu	r6,r3,10002948 <__muldf3+0x378>
10002940:	00c00074 	movhi	r3,1
10002944:	70dd883a 	add	r14,r14,r3
10002948:	8826d43a 	srli	r19,r17,16
1000294c:	8bffffcc 	andi	r15,r17,65535
10002950:	7d23383a 	mul	r17,r15,r20
10002954:	7949383a 	mul	r4,r15,r5
10002958:	9d29383a 	mul	r20,r19,r20
1000295c:	8814d43a 	srli	r10,r17,16
10002960:	3012943a 	slli	r9,r6,16
10002964:	a129883a 	add	r20,r20,r4
10002968:	633fffcc 	andi	r12,r12,65535
1000296c:	5515883a 	add	r10,r10,r20
10002970:	3006d43a 	srli	r3,r6,16
10002974:	4b13883a 	add	r9,r9,r12
10002978:	2ccb383a 	mul	r5,r5,r19
1000297c:	5100022e 	bgeu	r10,r4,10002988 <__muldf3+0x3b8>
10002980:	01000074 	movhi	r4,1
10002984:	290b883a 	add	r5,r5,r4
10002988:	802ad43a 	srli	r21,r16,16
1000298c:	843fffcc 	andi	r16,r16,65535
10002990:	440d383a 	mul	r6,r8,r16
10002994:	4565383a 	mul	r18,r8,r21
10002998:	8349383a 	mul	r4,r16,r13
1000299c:	500e943a 	slli	r7,r10,16
100029a0:	3010d43a 	srli	r8,r6,16
100029a4:	5028d43a 	srli	r20,r10,16
100029a8:	2489883a 	add	r4,r4,r18
100029ac:	8abfffcc 	andi	r10,r17,65535
100029b0:	3a95883a 	add	r10,r7,r10
100029b4:	4119883a 	add	r12,r8,r4
100029b8:	a169883a 	add	r20,r20,r5
100029bc:	1a87883a 	add	r3,r3,r10
100029c0:	6d5b383a 	mul	r13,r13,r21
100029c4:	6480022e 	bgeu	r12,r18,100029d0 <__muldf3+0x400>
100029c8:	01000074 	movhi	r4,1
100029cc:	691b883a 	add	r13,r13,r4
100029d0:	7c25383a 	mul	r18,r15,r16
100029d4:	7d4b383a 	mul	r5,r15,r21
100029d8:	84cf383a 	mul	r7,r16,r19
100029dc:	901ed43a 	srli	r15,r18,16
100029e0:	6008d43a 	srli	r4,r12,16
100029e4:	6010943a 	slli	r8,r12,16
100029e8:	394f883a 	add	r7,r7,r5
100029ec:	333fffcc 	andi	r12,r6,65535
100029f0:	79df883a 	add	r15,r15,r7
100029f4:	235b883a 	add	r13,r4,r13
100029f8:	9d63383a 	mul	r17,r19,r21
100029fc:	4309883a 	add	r4,r8,r12
10002a00:	7940022e 	bgeu	r15,r5,10002a0c <__muldf3+0x43c>
10002a04:	01400074 	movhi	r5,1
10002a08:	8963883a 	add	r17,r17,r5
10002a0c:	780a943a 	slli	r5,r15,16
10002a10:	91bfffcc 	andi	r6,r18,65535
10002a14:	70c7883a 	add	r3,r14,r3
10002a18:	298d883a 	add	r6,r5,r6
10002a1c:	1a8f803a 	cmpltu	r7,r3,r10
10002a20:	350b883a 	add	r5,r6,r20
10002a24:	20c7883a 	add	r3,r4,r3
10002a28:	3955883a 	add	r10,r7,r5
10002a2c:	1909803a 	cmpltu	r4,r3,r4
10002a30:	6a91883a 	add	r8,r13,r10
10002a34:	780cd43a 	srli	r6,r15,16
10002a38:	2219883a 	add	r12,r4,r8
10002a3c:	2d0b803a 	cmpltu	r5,r5,r20
10002a40:	51cf803a 	cmpltu	r7,r10,r7
10002a44:	29ceb03a 	or	r7,r5,r7
10002a48:	4351803a 	cmpltu	r8,r8,r13
10002a4c:	610b803a 	cmpltu	r5,r12,r4
10002a50:	4148b03a 	or	r4,r8,r5
10002a54:	398f883a 	add	r7,r7,r6
10002a58:	3909883a 	add	r4,r7,r4
10002a5c:	1810927a 	slli	r8,r3,9
10002a60:	2449883a 	add	r4,r4,r17
10002a64:	2008927a 	slli	r4,r4,9
10002a68:	6022d5fa 	srli	r17,r12,23
10002a6c:	1806d5fa 	srli	r3,r3,23
10002a70:	4252b03a 	or	r9,r8,r9
10002a74:	600a927a 	slli	r5,r12,9
10002a78:	4810c03a 	cmpne	r8,r9,zero
10002a7c:	2462b03a 	or	r17,r4,r17
10002a80:	40c6b03a 	or	r3,r8,r3
10002a84:	8900402c 	andhi	r4,r17,256
10002a88:	1950b03a 	or	r8,r3,r5
10002a8c:	20000726 	beq	r4,zero,10002aac <__muldf3+0x4dc>
10002a90:	4006d07a 	srli	r3,r8,1
10002a94:	880497fa 	slli	r2,r17,31
10002a98:	4200004c 	andi	r8,r8,1
10002a9c:	8822d07a 	srli	r17,r17,1
10002aa0:	1a10b03a 	or	r8,r3,r8
10002aa4:	1210b03a 	or	r8,r2,r8
10002aa8:	5805883a 	mov	r2,r11
10002aac:	1140ffc4 	addi	r5,r2,1023
10002ab0:	0140440e 	bge	zero,r5,10002bc4 <__muldf3+0x5f4>
10002ab4:	40c001cc 	andi	r3,r8,7
10002ab8:	18000726 	beq	r3,zero,10002ad8 <__muldf3+0x508>
10002abc:	40c003cc 	andi	r3,r8,15
10002ac0:	01000104 	movi	r4,4
10002ac4:	19000426 	beq	r3,r4,10002ad8 <__muldf3+0x508>
10002ac8:	4107883a 	add	r3,r8,r4
10002acc:	1a11803a 	cmpltu	r8,r3,r8
10002ad0:	8a23883a 	add	r17,r17,r8
10002ad4:	1811883a 	mov	r8,r3
10002ad8:	88c0402c 	andhi	r3,r17,256
10002adc:	18000426 	beq	r3,zero,10002af0 <__muldf3+0x520>
10002ae0:	11410004 	addi	r5,r2,1024
10002ae4:	00bfc034 	movhi	r2,65280
10002ae8:	10bfffc4 	addi	r2,r2,-1
10002aec:	88a2703a 	and	r17,r17,r2
10002af0:	0081ff84 	movi	r2,2046
10002af4:	117f6416 	blt	r2,r5,10002888 <__muldf3+0x2b8>
10002af8:	8828977a 	slli	r20,r17,29
10002afc:	4010d0fa 	srli	r8,r8,3
10002b00:	8822927a 	slli	r17,r17,9
10002b04:	2881ffcc 	andi	r2,r5,2047
10002b08:	a228b03a 	or	r20,r20,r8
10002b0c:	880ad33a 	srli	r5,r17,12
10002b10:	b02b883a 	mov	r21,r22
10002b14:	003f0d06 	br	1000274c <__muldf3+0x17c>
10002b18:	8080022c 	andhi	r2,r16,8
10002b1c:	10000926 	beq	r2,zero,10002b44 <__muldf3+0x574>
10002b20:	8880022c 	andhi	r2,r17,8
10002b24:	1000071e 	bne	r2,zero,10002b44 <__muldf3+0x574>
10002b28:	00800434 	movhi	r2,16
10002b2c:	89400234 	orhi	r5,r17,8
10002b30:	10bfffc4 	addi	r2,r2,-1
10002b34:	b82b883a 	mov	r21,r23
10002b38:	288a703a 	and	r5,r5,r2
10002b3c:	4029883a 	mov	r20,r8
10002b40:	003f6806 	br	100028e4 <__muldf3+0x314>
10002b44:	00800434 	movhi	r2,16
10002b48:	81400234 	orhi	r5,r16,8
10002b4c:	10bfffc4 	addi	r2,r2,-1
10002b50:	288a703a 	and	r5,r5,r2
10002b54:	003f6306 	br	100028e4 <__muldf3+0x314>
10002b58:	147ff604 	addi	r17,r2,-40
10002b5c:	3462983a 	sll	r17,r6,r17
10002b60:	0011883a 	mov	r8,zero
10002b64:	003f4406 	br	10002878 <__muldf3+0x2a8>
10002b68:	3009883a 	mov	r4,r6
10002b6c:	d9800215 	stw	r6,8(sp)
10002b70:	da400115 	stw	r9,4(sp)
10002b74:	da800015 	stw	r10,0(sp)
10002b78:	000307c0 	call	1000307c <__clzsi2>
10002b7c:	10800804 	addi	r2,r2,32
10002b80:	da800017 	ldw	r10,0(sp)
10002b84:	da400117 	ldw	r9,4(sp)
10002b88:	d9800217 	ldw	r6,8(sp)
10002b8c:	003f3006 	br	10002850 <__muldf3+0x280>
10002b90:	143ff604 	addi	r16,r2,-40
10002b94:	9c20983a 	sll	r16,r19,r16
10002b98:	0029883a 	mov	r20,zero
10002b9c:	003f1606 	br	100027f8 <__muldf3+0x228>
10002ba0:	d9800215 	stw	r6,8(sp)
10002ba4:	d9c00015 	stw	r7,0(sp)
10002ba8:	da400115 	stw	r9,4(sp)
10002bac:	000307c0 	call	1000307c <__clzsi2>
10002bb0:	10800804 	addi	r2,r2,32
10002bb4:	da400117 	ldw	r9,4(sp)
10002bb8:	d9c00017 	ldw	r7,0(sp)
10002bbc:	d9800217 	ldw	r6,8(sp)
10002bc0:	003f0306 	br	100027d0 <__muldf3+0x200>
10002bc4:	00c00044 	movi	r3,1
10002bc8:	1947c83a 	sub	r3,r3,r5
10002bcc:	00800e04 	movi	r2,56
10002bd0:	10feda16 	blt	r2,r3,1000273c <__muldf3+0x16c>
10002bd4:	008007c4 	movi	r2,31
10002bd8:	10c01b16 	blt	r2,r3,10002c48 <__muldf3+0x678>
10002bdc:	00800804 	movi	r2,32
10002be0:	10c5c83a 	sub	r2,r2,r3
10002be4:	888a983a 	sll	r5,r17,r2
10002be8:	40c8d83a 	srl	r4,r8,r3
10002bec:	4084983a 	sll	r2,r8,r2
10002bf0:	88e2d83a 	srl	r17,r17,r3
10002bf4:	2906b03a 	or	r3,r5,r4
10002bf8:	1004c03a 	cmpne	r2,r2,zero
10002bfc:	1886b03a 	or	r3,r3,r2
10002c00:	188001cc 	andi	r2,r3,7
10002c04:	10000726 	beq	r2,zero,10002c24 <__muldf3+0x654>
10002c08:	188003cc 	andi	r2,r3,15
10002c0c:	01000104 	movi	r4,4
10002c10:	11000426 	beq	r2,r4,10002c24 <__muldf3+0x654>
10002c14:	1805883a 	mov	r2,r3
10002c18:	10c00104 	addi	r3,r2,4
10002c1c:	1885803a 	cmpltu	r2,r3,r2
10002c20:	88a3883a 	add	r17,r17,r2
10002c24:	8880202c 	andhi	r2,r17,128
10002c28:	10001c26 	beq	r2,zero,10002c9c <__muldf3+0x6cc>
10002c2c:	b02b883a 	mov	r21,r22
10002c30:	00800044 	movi	r2,1
10002c34:	000b883a 	mov	r5,zero
10002c38:	0029883a 	mov	r20,zero
10002c3c:	003ec306 	br	1000274c <__muldf3+0x17c>
10002c40:	5805883a 	mov	r2,r11
10002c44:	003f9906 	br	10002aac <__muldf3+0x4dc>
10002c48:	00bff844 	movi	r2,-31
10002c4c:	1145c83a 	sub	r2,r2,r5
10002c50:	8888d83a 	srl	r4,r17,r2
10002c54:	00800804 	movi	r2,32
10002c58:	18801a26 	beq	r3,r2,10002cc4 <__muldf3+0x6f4>
10002c5c:	00801004 	movi	r2,64
10002c60:	10c5c83a 	sub	r2,r2,r3
10002c64:	8884983a 	sll	r2,r17,r2
10002c68:	1204b03a 	or	r2,r2,r8
10002c6c:	1004c03a 	cmpne	r2,r2,zero
10002c70:	2084b03a 	or	r2,r4,r2
10002c74:	144001cc 	andi	r17,r2,7
10002c78:	88000d1e 	bne	r17,zero,10002cb0 <__muldf3+0x6e0>
10002c7c:	000b883a 	mov	r5,zero
10002c80:	1028d0fa 	srli	r20,r2,3
10002c84:	b02b883a 	mov	r21,r22
10002c88:	0005883a 	mov	r2,zero
10002c8c:	a468b03a 	or	r20,r20,r17
10002c90:	003eae06 	br	1000274c <__muldf3+0x17c>
10002c94:	1007883a 	mov	r3,r2
10002c98:	0023883a 	mov	r17,zero
10002c9c:	880a927a 	slli	r5,r17,9
10002ca0:	1805883a 	mov	r2,r3
10002ca4:	8822977a 	slli	r17,r17,29
10002ca8:	280ad33a 	srli	r5,r5,12
10002cac:	003ff406 	br	10002c80 <__muldf3+0x6b0>
10002cb0:	10c003cc 	andi	r3,r2,15
10002cb4:	01000104 	movi	r4,4
10002cb8:	193ff626 	beq	r3,r4,10002c94 <__muldf3+0x6c4>
10002cbc:	0023883a 	mov	r17,zero
10002cc0:	003fd506 	br	10002c18 <__muldf3+0x648>
10002cc4:	0005883a 	mov	r2,zero
10002cc8:	003fe706 	br	10002c68 <__muldf3+0x698>
10002ccc:	00800434 	movhi	r2,16
10002cd0:	89400234 	orhi	r5,r17,8
10002cd4:	10bfffc4 	addi	r2,r2,-1
10002cd8:	b02b883a 	mov	r21,r22
10002cdc:	288a703a 	and	r5,r5,r2
10002ce0:	4029883a 	mov	r20,r8
10002ce4:	003eff06 	br	100028e4 <__muldf3+0x314>

10002ce8 <__floatsidf>:
10002ce8:	defffd04 	addi	sp,sp,-12
10002cec:	dfc00215 	stw	ra,8(sp)
10002cf0:	dc400115 	stw	r17,4(sp)
10002cf4:	dc000015 	stw	r16,0(sp)
10002cf8:	20002b26 	beq	r4,zero,10002da8 <__floatsidf+0xc0>
10002cfc:	2023883a 	mov	r17,r4
10002d00:	2020d7fa 	srli	r16,r4,31
10002d04:	20002d16 	blt	r4,zero,10002dbc <__floatsidf+0xd4>
10002d08:	8809883a 	mov	r4,r17
10002d0c:	000307c0 	call	1000307c <__clzsi2>
10002d10:	01410784 	movi	r5,1054
10002d14:	288bc83a 	sub	r5,r5,r2
10002d18:	01010cc4 	movi	r4,1075
10002d1c:	2149c83a 	sub	r4,r4,r5
10002d20:	00c007c4 	movi	r3,31
10002d24:	1900160e 	bge	r3,r4,10002d80 <__floatsidf+0x98>
10002d28:	00c104c4 	movi	r3,1043
10002d2c:	1947c83a 	sub	r3,r3,r5
10002d30:	88c6983a 	sll	r3,r17,r3
10002d34:	00800434 	movhi	r2,16
10002d38:	10bfffc4 	addi	r2,r2,-1
10002d3c:	1886703a 	and	r3,r3,r2
10002d40:	2941ffcc 	andi	r5,r5,2047
10002d44:	800d883a 	mov	r6,r16
10002d48:	0005883a 	mov	r2,zero
10002d4c:	280a953a 	slli	r5,r5,20
10002d50:	31803fcc 	andi	r6,r6,255
10002d54:	01000434 	movhi	r4,16
10002d58:	300c97fa 	slli	r6,r6,31
10002d5c:	213fffc4 	addi	r4,r4,-1
10002d60:	1906703a 	and	r3,r3,r4
10002d64:	1946b03a 	or	r3,r3,r5
10002d68:	1986b03a 	or	r3,r3,r6
10002d6c:	dfc00217 	ldw	ra,8(sp)
10002d70:	dc400117 	ldw	r17,4(sp)
10002d74:	dc000017 	ldw	r16,0(sp)
10002d78:	dec00304 	addi	sp,sp,12
10002d7c:	f800283a 	ret
10002d80:	00c002c4 	movi	r3,11
10002d84:	1887c83a 	sub	r3,r3,r2
10002d88:	88c6d83a 	srl	r3,r17,r3
10002d8c:	8904983a 	sll	r2,r17,r4
10002d90:	01000434 	movhi	r4,16
10002d94:	213fffc4 	addi	r4,r4,-1
10002d98:	2941ffcc 	andi	r5,r5,2047
10002d9c:	1906703a 	and	r3,r3,r4
10002da0:	800d883a 	mov	r6,r16
10002da4:	003fe906 	br	10002d4c <__floatsidf+0x64>
10002da8:	000d883a 	mov	r6,zero
10002dac:	000b883a 	mov	r5,zero
10002db0:	0007883a 	mov	r3,zero
10002db4:	0005883a 	mov	r2,zero
10002db8:	003fe406 	br	10002d4c <__floatsidf+0x64>
10002dbc:	0123c83a 	sub	r17,zero,r4
10002dc0:	003fd106 	br	10002d08 <__floatsidf+0x20>

10002dc4 <__extendsfdf2>:
10002dc4:	200ad5fa 	srli	r5,r4,23
10002dc8:	defffd04 	addi	sp,sp,-12
10002dcc:	dc400115 	stw	r17,4(sp)
10002dd0:	29403fcc 	andi	r5,r5,255
10002dd4:	29800044 	addi	r6,r5,1
10002dd8:	04402034 	movhi	r17,128
10002ddc:	dc000015 	stw	r16,0(sp)
10002de0:	8c7fffc4 	addi	r17,r17,-1
10002de4:	dfc00215 	stw	ra,8(sp)
10002de8:	31803fcc 	andi	r6,r6,255
10002dec:	00800044 	movi	r2,1
10002df0:	8922703a 	and	r17,r17,r4
10002df4:	2020d7fa 	srli	r16,r4,31
10002df8:	1180110e 	bge	r2,r6,10002e40 <__extendsfdf2+0x7c>
10002dfc:	880cd0fa 	srli	r6,r17,3
10002e00:	8822977a 	slli	r17,r17,29
10002e04:	2940e004 	addi	r5,r5,896
10002e08:	2941ffcc 	andi	r5,r5,2047
10002e0c:	2804953a 	slli	r2,r5,20
10002e10:	01400434 	movhi	r5,16
10002e14:	800697fa 	slli	r3,r16,31
10002e18:	297fffc4 	addi	r5,r5,-1
10002e1c:	314a703a 	and	r5,r6,r5
10002e20:	288ab03a 	or	r5,r5,r2
10002e24:	28c6b03a 	or	r3,r5,r3
10002e28:	8805883a 	mov	r2,r17
10002e2c:	dfc00217 	ldw	ra,8(sp)
10002e30:	dc400117 	ldw	r17,4(sp)
10002e34:	dc000017 	ldw	r16,0(sp)
10002e38:	dec00304 	addi	sp,sp,12
10002e3c:	f800283a 	ret
10002e40:	2800111e 	bne	r5,zero,10002e88 <__extendsfdf2+0xc4>
10002e44:	88001c26 	beq	r17,zero,10002eb8 <__extendsfdf2+0xf4>
10002e48:	8809883a 	mov	r4,r17
10002e4c:	000307c0 	call	1000307c <__clzsi2>
10002e50:	00c00284 	movi	r3,10
10002e54:	18801b16 	blt	r3,r2,10002ec4 <__extendsfdf2+0x100>
10002e58:	018002c4 	movi	r6,11
10002e5c:	308dc83a 	sub	r6,r6,r2
10002e60:	11000544 	addi	r4,r2,21
10002e64:	8986d83a 	srl	r3,r17,r6
10002e68:	8922983a 	sll	r17,r17,r4
10002e6c:	0180e244 	movi	r6,905
10002e70:	01400434 	movhi	r5,16
10002e74:	3085c83a 	sub	r2,r6,r2
10002e78:	297fffc4 	addi	r5,r5,-1
10002e7c:	194c703a 	and	r6,r3,r5
10002e80:	1141ffcc 	andi	r5,r2,2047
10002e84:	003fe006 	br	10002e08 <__extendsfdf2+0x44>
10002e88:	88000826 	beq	r17,zero,10002eac <__extendsfdf2+0xe8>
10002e8c:	880cd0fa 	srli	r6,r17,3
10002e90:	00800434 	movhi	r2,16
10002e94:	10bfffc4 	addi	r2,r2,-1
10002e98:	31800234 	orhi	r6,r6,8
10002e9c:	8822977a 	slli	r17,r17,29
10002ea0:	308c703a 	and	r6,r6,r2
10002ea4:	0141ffc4 	movi	r5,2047
10002ea8:	003fd706 	br	10002e08 <__extendsfdf2+0x44>
10002eac:	0141ffc4 	movi	r5,2047
10002eb0:	000d883a 	mov	r6,zero
10002eb4:	003fd406 	br	10002e08 <__extendsfdf2+0x44>
10002eb8:	000b883a 	mov	r5,zero
10002ebc:	000d883a 	mov	r6,zero
10002ec0:	003fd106 	br	10002e08 <__extendsfdf2+0x44>
10002ec4:	11bffd44 	addi	r6,r2,-11
10002ec8:	8986983a 	sll	r3,r17,r6
10002ecc:	0023883a 	mov	r17,zero
10002ed0:	003fe606 	br	10002e6c <__extendsfdf2+0xa8>

10002ed4 <__truncdfsf2>:
10002ed4:	2810d53a 	srli	r8,r5,20
10002ed8:	01c00434 	movhi	r7,16
10002edc:	39ffffc4 	addi	r7,r7,-1
10002ee0:	29ce703a 	and	r7,r5,r7
10002ee4:	4201ffcc 	andi	r8,r8,2047
10002ee8:	380e90fa 	slli	r7,r7,3
10002eec:	200cd77a 	srli	r6,r4,29
10002ef0:	42400044 	addi	r9,r8,1
10002ef4:	4a41ffcc 	andi	r9,r9,2047
10002ef8:	00c00044 	movi	r3,1
10002efc:	280ad7fa 	srli	r5,r5,31
10002f00:	31ceb03a 	or	r7,r6,r7
10002f04:	200490fa 	slli	r2,r4,3
10002f08:	1a40230e 	bge	r3,r9,10002f98 <__truncdfsf2+0xc4>
10002f0c:	40ff2004 	addi	r3,r8,-896
10002f10:	01803f84 	movi	r6,254
10002f14:	30c01516 	blt	r6,r3,10002f6c <__truncdfsf2+0x98>
10002f18:	00c0380e 	bge	zero,r3,10002ffc <__truncdfsf2+0x128>
10002f1c:	200c91ba 	slli	r6,r4,6
10002f20:	380e90fa 	slli	r7,r7,3
10002f24:	1004d77a 	srli	r2,r2,29
10002f28:	300cc03a 	cmpne	r6,r6,zero
10002f2c:	31ccb03a 	or	r6,r6,r7
10002f30:	308cb03a 	or	r6,r6,r2
10002f34:	308001cc 	andi	r2,r6,7
10002f38:	10000426 	beq	r2,zero,10002f4c <__truncdfsf2+0x78>
10002f3c:	308003cc 	andi	r2,r6,15
10002f40:	01000104 	movi	r4,4
10002f44:	11000126 	beq	r2,r4,10002f4c <__truncdfsf2+0x78>
10002f48:	31800104 	addi	r6,r6,4
10002f4c:	3081002c 	andhi	r2,r6,1024
10002f50:	10001626 	beq	r2,zero,10002fac <__truncdfsf2+0xd8>
10002f54:	18c00044 	addi	r3,r3,1
10002f58:	00803fc4 	movi	r2,255
10002f5c:	18800326 	beq	r3,r2,10002f6c <__truncdfsf2+0x98>
10002f60:	300c91ba 	slli	r6,r6,6
10002f64:	300cd27a 	srli	r6,r6,9
10002f68:	00000206 	br	10002f74 <__truncdfsf2+0xa0>
10002f6c:	00ffffc4 	movi	r3,-1
10002f70:	000d883a 	mov	r6,zero
10002f74:	18c03fcc 	andi	r3,r3,255
10002f78:	180895fa 	slli	r4,r3,23
10002f7c:	00c02034 	movhi	r3,128
10002f80:	280a97fa 	slli	r5,r5,31
10002f84:	18ffffc4 	addi	r3,r3,-1
10002f88:	30c6703a 	and	r3,r6,r3
10002f8c:	1906b03a 	or	r3,r3,r4
10002f90:	1944b03a 	or	r2,r3,r5
10002f94:	f800283a 	ret
10002f98:	40000b1e 	bne	r8,zero,10002fc8 <__truncdfsf2+0xf4>
10002f9c:	388cb03a 	or	r6,r7,r2
10002fa0:	0007883a 	mov	r3,zero
10002fa4:	30000426 	beq	r6,zero,10002fb8 <__truncdfsf2+0xe4>
10002fa8:	01800144 	movi	r6,5
10002fac:	00803fc4 	movi	r2,255
10002fb0:	300cd0fa 	srli	r6,r6,3
10002fb4:	18800a26 	beq	r3,r2,10002fe0 <__truncdfsf2+0x10c>
10002fb8:	00802034 	movhi	r2,128
10002fbc:	10bfffc4 	addi	r2,r2,-1
10002fc0:	308c703a 	and	r6,r6,r2
10002fc4:	003feb06 	br	10002f74 <__truncdfsf2+0xa0>
10002fc8:	3888b03a 	or	r4,r7,r2
10002fcc:	203fe726 	beq	r4,zero,10002f6c <__truncdfsf2+0x98>
10002fd0:	380c90fa 	slli	r6,r7,3
10002fd4:	00c03fc4 	movi	r3,255
10002fd8:	31808034 	orhi	r6,r6,512
10002fdc:	003fd506 	br	10002f34 <__truncdfsf2+0x60>
10002fe0:	303fe226 	beq	r6,zero,10002f6c <__truncdfsf2+0x98>
10002fe4:	00802034 	movhi	r2,128
10002fe8:	31801034 	orhi	r6,r6,64
10002fec:	10bfffc4 	addi	r2,r2,-1
10002ff0:	00ffffc4 	movi	r3,-1
10002ff4:	308c703a 	and	r6,r6,r2
10002ff8:	003fde06 	br	10002f74 <__truncdfsf2+0xa0>
10002ffc:	013ffa44 	movi	r4,-23
10003000:	19000e16 	blt	r3,r4,1000303c <__truncdfsf2+0x168>
10003004:	01000784 	movi	r4,30
10003008:	20c9c83a 	sub	r4,r4,r3
1000300c:	018007c4 	movi	r6,31
10003010:	39c02034 	orhi	r7,r7,128
10003014:	31000b16 	blt	r6,r4,10003044 <__truncdfsf2+0x170>
10003018:	423f2084 	addi	r8,r8,-894
1000301c:	120c983a 	sll	r6,r2,r8
10003020:	3a0e983a 	sll	r7,r7,r8
10003024:	1104d83a 	srl	r2,r2,r4
10003028:	300cc03a 	cmpne	r6,r6,zero
1000302c:	31ceb03a 	or	r7,r6,r7
10003030:	388cb03a 	or	r6,r7,r2
10003034:	0007883a 	mov	r3,zero
10003038:	003fbe06 	br	10002f34 <__truncdfsf2+0x60>
1000303c:	0007883a 	mov	r3,zero
10003040:	003fd906 	br	10002fa8 <__truncdfsf2+0xd4>
10003044:	01bfff84 	movi	r6,-2
10003048:	30cdc83a 	sub	r6,r6,r3
1000304c:	00c00804 	movi	r3,32
10003050:	398cd83a 	srl	r6,r7,r6
10003054:	20c00726 	beq	r4,r3,10003074 <__truncdfsf2+0x1a0>
10003058:	423f2884 	addi	r8,r8,-862
1000305c:	3a0e983a 	sll	r7,r7,r8
10003060:	3884b03a 	or	r2,r7,r2
10003064:	1004c03a 	cmpne	r2,r2,zero
10003068:	118cb03a 	or	r6,r2,r6
1000306c:	0007883a 	mov	r3,zero
10003070:	003fb006 	br	10002f34 <__truncdfsf2+0x60>
10003074:	000f883a 	mov	r7,zero
10003078:	003ff906 	br	10003060 <__truncdfsf2+0x18c>

1000307c <__clzsi2>:
1000307c:	00bfffd4 	movui	r2,65535
10003080:	11000536 	bltu	r2,r4,10003098 <__clzsi2+0x1c>
10003084:	00803fc4 	movi	r2,255
10003088:	11000f36 	bltu	r2,r4,100030c8 <__clzsi2+0x4c>
1000308c:	00800804 	movi	r2,32
10003090:	0007883a 	mov	r3,zero
10003094:	00000506 	br	100030ac <__clzsi2+0x30>
10003098:	00804034 	movhi	r2,256
1000309c:	10bfffc4 	addi	r2,r2,-1
100030a0:	11000c2e 	bgeu	r2,r4,100030d4 <__clzsi2+0x58>
100030a4:	00800204 	movi	r2,8
100030a8:	00c00604 	movi	r3,24
100030ac:	20c8d83a 	srl	r4,r4,r3
100030b0:	00c40734 	movhi	r3,4124
100030b4:	18db9904 	addi	r3,r3,28260
100030b8:	1909883a 	add	r4,r3,r4
100030bc:	20c00003 	ldbu	r3,0(r4)
100030c0:	10c5c83a 	sub	r2,r2,r3
100030c4:	f800283a 	ret
100030c8:	00800604 	movi	r2,24
100030cc:	00c00204 	movi	r3,8
100030d0:	003ff606 	br	100030ac <__clzsi2+0x30>
100030d4:	00800404 	movi	r2,16
100030d8:	1007883a 	mov	r3,r2
100030dc:	003ff306 	br	100030ac <__clzsi2+0x30>

100030e0 <__divsi3>:
100030e0:	20001b16 	blt	r4,zero,10003150 <__divsi3+0x70>
100030e4:	000f883a 	mov	r7,zero
100030e8:	28001616 	blt	r5,zero,10003144 <__divsi3+0x64>
100030ec:	200d883a 	mov	r6,r4
100030f0:	29001a2e 	bgeu	r5,r4,1000315c <__divsi3+0x7c>
100030f4:	00800804 	movi	r2,32
100030f8:	00c00044 	movi	r3,1
100030fc:	00000106 	br	10003104 <__divsi3+0x24>
10003100:	10000d26 	beq	r2,zero,10003138 <__divsi3+0x58>
10003104:	294b883a 	add	r5,r5,r5
10003108:	10bfffc4 	addi	r2,r2,-1
1000310c:	18c7883a 	add	r3,r3,r3
10003110:	293ffb36 	bltu	r5,r4,10003100 <__divsi3+0x20>
10003114:	0005883a 	mov	r2,zero
10003118:	18000726 	beq	r3,zero,10003138 <__divsi3+0x58>
1000311c:	0005883a 	mov	r2,zero
10003120:	31400236 	bltu	r6,r5,1000312c <__divsi3+0x4c>
10003124:	314dc83a 	sub	r6,r6,r5
10003128:	10c4b03a 	or	r2,r2,r3
1000312c:	1806d07a 	srli	r3,r3,1
10003130:	280ad07a 	srli	r5,r5,1
10003134:	183ffa1e 	bne	r3,zero,10003120 <__divsi3+0x40>
10003138:	38000126 	beq	r7,zero,10003140 <__divsi3+0x60>
1000313c:	0085c83a 	sub	r2,zero,r2
10003140:	f800283a 	ret
10003144:	014bc83a 	sub	r5,zero,r5
10003148:	39c0005c 	xori	r7,r7,1
1000314c:	003fe706 	br	100030ec <__divsi3+0xc>
10003150:	0109c83a 	sub	r4,zero,r4
10003154:	01c00044 	movi	r7,1
10003158:	003fe306 	br	100030e8 <__divsi3+0x8>
1000315c:	00c00044 	movi	r3,1
10003160:	003fee06 	br	1000311c <__divsi3+0x3c>

10003164 <__modsi3>:
10003164:	20001716 	blt	r4,zero,100031c4 <__modsi3+0x60>
10003168:	000f883a 	mov	r7,zero
1000316c:	2005883a 	mov	r2,r4
10003170:	28001216 	blt	r5,zero,100031bc <__modsi3+0x58>
10003174:	2900162e 	bgeu	r5,r4,100031d0 <__modsi3+0x6c>
10003178:	01800804 	movi	r6,32
1000317c:	00c00044 	movi	r3,1
10003180:	00000106 	br	10003188 <__modsi3+0x24>
10003184:	30000a26 	beq	r6,zero,100031b0 <__modsi3+0x4c>
10003188:	294b883a 	add	r5,r5,r5
1000318c:	31bfffc4 	addi	r6,r6,-1
10003190:	18c7883a 	add	r3,r3,r3
10003194:	293ffb36 	bltu	r5,r4,10003184 <__modsi3+0x20>
10003198:	18000526 	beq	r3,zero,100031b0 <__modsi3+0x4c>
1000319c:	1806d07a 	srli	r3,r3,1
100031a0:	11400136 	bltu	r2,r5,100031a8 <__modsi3+0x44>
100031a4:	1145c83a 	sub	r2,r2,r5
100031a8:	280ad07a 	srli	r5,r5,1
100031ac:	183ffb1e 	bne	r3,zero,1000319c <__modsi3+0x38>
100031b0:	38000126 	beq	r7,zero,100031b8 <__modsi3+0x54>
100031b4:	0085c83a 	sub	r2,zero,r2
100031b8:	f800283a 	ret
100031bc:	014bc83a 	sub	r5,zero,r5
100031c0:	003fec06 	br	10003174 <__modsi3+0x10>
100031c4:	0109c83a 	sub	r4,zero,r4
100031c8:	01c00044 	movi	r7,1
100031cc:	003fe706 	br	1000316c <__modsi3+0x8>
100031d0:	00c00044 	movi	r3,1
100031d4:	003ff106 	br	1000319c <__modsi3+0x38>

100031d8 <__udivsi3>:
100031d8:	200d883a 	mov	r6,r4
100031dc:	2900152e 	bgeu	r5,r4,10003234 <__udivsi3+0x5c>
100031e0:	28001416 	blt	r5,zero,10003234 <__udivsi3+0x5c>
100031e4:	00800804 	movi	r2,32
100031e8:	00c00044 	movi	r3,1
100031ec:	00000206 	br	100031f8 <__udivsi3+0x20>
100031f0:	10000e26 	beq	r2,zero,1000322c <__udivsi3+0x54>
100031f4:	28000516 	blt	r5,zero,1000320c <__udivsi3+0x34>
100031f8:	294b883a 	add	r5,r5,r5
100031fc:	10bfffc4 	addi	r2,r2,-1
10003200:	18c7883a 	add	r3,r3,r3
10003204:	293ffa36 	bltu	r5,r4,100031f0 <__udivsi3+0x18>
10003208:	18000826 	beq	r3,zero,1000322c <__udivsi3+0x54>
1000320c:	0005883a 	mov	r2,zero
10003210:	31400236 	bltu	r6,r5,1000321c <__udivsi3+0x44>
10003214:	314dc83a 	sub	r6,r6,r5
10003218:	10c4b03a 	or	r2,r2,r3
1000321c:	1806d07a 	srli	r3,r3,1
10003220:	280ad07a 	srli	r5,r5,1
10003224:	183ffa1e 	bne	r3,zero,10003210 <__udivsi3+0x38>
10003228:	f800283a 	ret
1000322c:	0005883a 	mov	r2,zero
10003230:	f800283a 	ret
10003234:	00c00044 	movi	r3,1
10003238:	003ff406 	br	1000320c <__udivsi3+0x34>

1000323c <__umodsi3>:
1000323c:	2005883a 	mov	r2,r4
10003240:	2900122e 	bgeu	r5,r4,1000328c <__umodsi3+0x50>
10003244:	28001116 	blt	r5,zero,1000328c <__umodsi3+0x50>
10003248:	01800804 	movi	r6,32
1000324c:	00c00044 	movi	r3,1
10003250:	00000206 	br	1000325c <__umodsi3+0x20>
10003254:	30000c26 	beq	r6,zero,10003288 <__umodsi3+0x4c>
10003258:	28000516 	blt	r5,zero,10003270 <__umodsi3+0x34>
1000325c:	294b883a 	add	r5,r5,r5
10003260:	31bfffc4 	addi	r6,r6,-1
10003264:	18c7883a 	add	r3,r3,r3
10003268:	293ffa36 	bltu	r5,r4,10003254 <__umodsi3+0x18>
1000326c:	18000626 	beq	r3,zero,10003288 <__umodsi3+0x4c>
10003270:	1806d07a 	srli	r3,r3,1
10003274:	11400136 	bltu	r2,r5,1000327c <__umodsi3+0x40>
10003278:	1145c83a 	sub	r2,r2,r5
1000327c:	280ad07a 	srli	r5,r5,1
10003280:	183ffb1e 	bne	r3,zero,10003270 <__umodsi3+0x34>
10003284:	f800283a 	ret
10003288:	f800283a 	ret
1000328c:	00c00044 	movi	r3,1
10003290:	003ff706 	br	10003270 <__umodsi3+0x34>

10003294 <_printf_r>:

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
10003294:	defffd04 	addi	sp,sp,-12
10003298:	dfc00015 	stw	ra,0(sp)
1000329c:	d9800115 	stw	r6,4(sp)
100032a0:	d9c00215 	stw	r7,8(sp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  _FILE_INIT_DEV_WRITE (_stdout_r (ptr));						/* AlteraSpecific */
100032a4:	20c00217 	ldw	r3,8(r4)
100032a8:	01840034 	movhi	r6,4096
100032ac:	318e5804 	addi	r6,r6,14688
100032b0:	19800115 	stw	r6,4(r3)
  va_start (ap, fmt);
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.16.0*/	/* AlteraSpecific */
/*ret = ___vfprintf_internal_r (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.16  */	/* AlteraSpecific */
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.18.0*/	/* AlteraSpecific */
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/* try1 */	/* AlteraSpecific */
  ret = ___vfprintf_internal_r (ptr, _stdout_r (ptr), fmt, ap);		/* try2 */	/* AlteraSpecific */
100032b4:	280d883a 	mov	r6,r5
100032b8:	21400217 	ldw	r5,8(r4)
100032bc:	d9c00104 	addi	r7,sp,4
100032c0:	00034280 	call	10003428 <___vfprintf_internal_r>
  va_end (ap);
  return ret;
}
100032c4:	dfc00017 	ldw	ra,0(sp)
100032c8:	dec00304 	addi	sp,sp,12
100032cc:	f800283a 	ret

100032d0 <printf>:
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
100032d0:	defffc04 	addi	sp,sp,-16
100032d4:	dfc00015 	stw	ra,0(sp)
100032d8:	d9400115 	stw	r5,4(sp)
100032dc:	d9800215 	stw	r6,8(sp)
100032e0:	d9c00315 	stw	r7,12(sp)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  _FILE_INIT_DEV_WRITE (_stdout_r (_REENT));					/* AlteraSpecific. Mirror changes here in iprintf.c */
100032e4:	d0a00117 	ldw	r2,-32764(gp)
100032e8:	01440034 	movhi	r5,4096
100032ec:	294e5804 	addi	r5,r5,14688
100032f0:	10c00217 	ldw	r3,8(r2)
  va_start (ap, fmt);
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.16.0*/	/* AlteraSpecific */
/*ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);	*/ /*1.16  */	/* AlteraSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.18.0*/	/* AlteraSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap); */ /* try1 */	/* AlteraSpecific */
  ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);    /* try2 */	/* AlteraSpecific */
100032f4:	d9800104 	addi	r6,sp,4
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  _FILE_INIT_DEV_WRITE (_stdout_r (_REENT));					/* AlteraSpecific. Mirror changes here in iprintf.c */
100032f8:	19400115 	stw	r5,4(r3)
  va_start (ap, fmt);
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.16.0*/	/* AlteraSpecific */
/*ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);	*/ /*1.16  */	/* AlteraSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.18.0*/	/* AlteraSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap); */ /* try1 */	/* AlteraSpecific */
  ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);    /* try2 */	/* AlteraSpecific */
100032fc:	200b883a 	mov	r5,r4
10003300:	11000217 	ldw	r4,8(r2)
10003304:	000394c0 	call	1000394c <__vfprintf_internal>
  va_end (ap);
  return ret;
}
10003308:	dfc00017 	ldw	ra,0(sp)
1000330c:	dec00404 	addi	sp,sp,16
10003310:	f800283a 	ret

10003314 <_puts_r>:

int
_DEFUN (_puts_r, (ptr, s),
	struct _reent *ptr _AND
	_CONST char * s)
{
10003314:	defffd04 	addi	sp,sp,-12
10003318:	dc000015 	stw	r16,0(sp)
1000331c:	2021883a 	mov	r16,r4
  size_t c = strlen (s);
10003320:	2809883a 	mov	r4,r5

int
_DEFUN (_puts_r, (ptr, s),
	struct _reent *ptr _AND
	_CONST char * s)
{
10003324:	dfc00215 	stw	ra,8(sp)
10003328:	dc400115 	stw	r17,4(sp)
1000332c:	2823883a 	mov	r17,r5
  size_t c = strlen (s);
10003330:	00033a00 	call	100033a0 <strlen>
  _FILE_INIT_DEV_WRITE (_stdout_r (ptr));
10003334:	81400217 	ldw	r5,8(r16)
10003338:	01040034 	movhi	r4,4096
1000333c:	210e5804 	addi	r4,r4,14688
10003340:	29000115 	stw	r4,4(r5)

  if (_stdout_r (ptr)->_sfvwrite (ptr, _stdout_r (ptr), s, c) != EOF)
10003344:	100f883a 	mov	r7,r2
10003348:	880d883a 	mov	r6,r17
1000334c:	8009883a 	mov	r4,r16
10003350:	00039600 	call	10003960 <__sfvwrite_small_dev>
10003354:	00ffffc4 	movi	r3,-1
10003358:	10c00926 	beq	r2,r3,10003380 <_puts_r+0x6c>
    if (_stdout_r (ptr)->_sfvwrite (ptr, _stdout_r (ptr), "\n", 1) != EOF)
1000335c:	81400217 	ldw	r5,8(r16)
10003360:	01840734 	movhi	r6,4124
10003364:	01c00044 	movi	r7,1
10003368:	28800117 	ldw	r2,4(r5)
1000336c:	319bd904 	addi	r6,r6,28516
10003370:	8009883a 	mov	r4,r16
10003374:	103ee83a 	callr	r2
10003378:	10bfffe0 	cmpeqi	r2,r2,-1
1000337c:	0085c83a 	sub	r2,zero,r2
      return 0;
  return EOF;
}
10003380:	dfc00217 	ldw	ra,8(sp)
10003384:	dc400117 	ldw	r17,4(sp)
10003388:	dc000017 	ldw	r16,0(sp)
1000338c:	dec00304 	addi	sp,sp,12
10003390:	f800283a 	ret

10003394 <puts>:

int
_DEFUN(puts, (s),
       char _CONST * s)
{
  return _puts_r (_REENT, s);
10003394:	200b883a 	mov	r5,r4
10003398:	d1200117 	ldw	r4,-32764(gp)
1000339c:	00033141 	jmpi	10003314 <_puts_r>

100033a0 <strlen>:
     precise position of the null.  */
  str = (char *) aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
100033a0:	2005883a 	mov	r2,r4
100033a4:	10c00007 	ldb	r3,0(r2)
100033a8:	18000226 	beq	r3,zero,100033b4 <strlen+0x14>
    str++;
100033ac:	10800044 	addi	r2,r2,1
100033b0:	003ffc06 	br	100033a4 <strlen+0x4>
  return str - start;
}
100033b4:	1105c83a 	sub	r2,r2,r4
100033b8:	f800283a 	ret

100033bc <print_repeat>:
};


static int
print_repeat (struct _reent *data, FILE * fp, char c, int count)
{
100033bc:	defffb04 	addi	sp,sp,-20
100033c0:	dc800315 	stw	r18,12(sp)
100033c4:	dc400215 	stw	r17,8(sp)
100033c8:	dc000115 	stw	r16,4(sp)
100033cc:	dfc00415 	stw	ra,16(sp)
100033d0:	2025883a 	mov	r18,r4
100033d4:	2823883a 	mov	r17,r5
100033d8:	d9800005 	stb	r6,0(sp)
100033dc:	3821883a 	mov	r16,r7
  while (count-- > 0)
100033e0:	04000a0e 	bge	zero,r16,1000340c <print_repeat+0x50>
    if (fp->_sfvwrite (data, fp, &c, 1))
100033e4:	88800117 	ldw	r2,4(r17)
100033e8:	01c00044 	movi	r7,1
100033ec:	d80d883a 	mov	r6,sp
100033f0:	880b883a 	mov	r5,r17
100033f4:	9009883a 	mov	r4,r18
100033f8:	103ee83a 	callr	r2
100033fc:	843fffc4 	addi	r16,r16,-1
10003400:	103ff726 	beq	r2,zero,100033e0 <print_repeat+0x24>
      return EOF;
10003404:	00bfffc4 	movi	r2,-1
10003408:	00000106 	br	10003410 <print_repeat+0x54>

  return 0;
1000340c:	0005883a 	mov	r2,zero
}
10003410:	dfc00417 	ldw	ra,16(sp)
10003414:	dc800317 	ldw	r18,12(sp)
10003418:	dc400217 	ldw	r17,8(sp)
1000341c:	dc000117 	ldw	r16,4(sp)
10003420:	dec00504 	addi	sp,sp,20
10003424:	f800283a 	ret

10003428 <___vfprintf_internal_r>:
_DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
	struct _reent *data _AND
	FILE * fp _AND
	_CONST char *fmt0 _AND
	va_list ap)
{
10003428:	deffe504 	addi	sp,sp,-108
				PRINT_CHAR_REPEATEDLY('0', padCharsNeeded);
			      }
			    else
			      {
				PRINT_CHAR_REPEATEDLY(' ', padCharsNeeded);
				if (sign)  PRINT_CHAR ('-');
1000342c:	d8c00804 	addi	r3,sp,32
_DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
	struct _reent *data _AND
	FILE * fp _AND
	_CONST char *fmt0 _AND
	va_list ap)
{
10003430:	df001915 	stw	fp,100(sp)
10003434:	ddc01815 	stw	r23,96(sp)
10003438:	dd801715 	stw	r22,92(sp)
1000343c:	dd401615 	stw	r21,88(sp)
10003440:	dd001515 	stw	r20,84(sp)
10003444:	dcc01415 	stw	r19,80(sp)
10003448:	dc801315 	stw	r18,76(sp)
1000344c:	dc401215 	stw	r17,72(sp)
10003450:	dc001115 	stw	r16,68(sp)
10003454:	dfc01a15 	stw	ra,104(sp)
10003458:	2027883a 	mov	r19,r4
1000345c:	2839883a 	mov	fp,r5
10003460:	382d883a 	mov	r22,r7
10003464:	d9800f15 	stw	r6,60(sp)
  int fmtWidth = 0;
  int fmtPrecision = 0;
  int fmtBase = 0;
  int fmtSigned = 0;
  int fmtCase = 0;		/* For hex format, if 1, A-F, else a-f. */
  int write_count = 0;
10003468:	0021883a 	mov	r16,zero
  int fmtLong = 0;
  int fmtWidth = 0;
  int fmtPrecision = 0;
  int fmtBase = 0;
  int fmtSigned = 0;
  int fmtCase = 0;		/* For hex format, if 1, A-F, else a-f. */
1000346c:	d8000e15 	stw	zero,56(sp)
  int fmtLeadingZero = 0;	/* init these all to 0 for -W warnings. */
  int fmtLong = 0;
  int fmtWidth = 0;
  int fmtPrecision = 0;
  int fmtBase = 0;
  int fmtSigned = 0;
10003470:	002f883a 	mov	r23,zero
  int state;
  int fmtLeadingZero = 0;	/* init these all to 0 for -W warnings. */
  int fmtLong = 0;
  int fmtWidth = 0;
  int fmtPrecision = 0;
  int fmtBase = 0;
10003474:	002b883a 	mov	r21,zero
  char c;
  int state;
  int fmtLeadingZero = 0;	/* init these all to 0 for -W warnings. */
  int fmtLong = 0;
  int fmtWidth = 0;
  int fmtPrecision = 0;
10003478:	0025883a 	mov	r18,zero
  const char *fmt;
  char c;
  int state;
  int fmtLeadingZero = 0;	/* init these all to 0 for -W warnings. */
  int fmtLong = 0;
  int fmtWidth = 0;
1000347c:	0023883a 	mov	r17,zero
{
  const char *fmt;
  char c;
  int state;
  int fmtLeadingZero = 0;	/* init these all to 0 for -W warnings. */
  int fmtLong = 0;
10003480:	d8000c15 	stw	zero,48(sp)
	va_list ap)
{
  const char *fmt;
  char c;
  int state;
  int fmtLeadingZero = 0;	/* init these all to 0 for -W warnings. */
10003484:	d8000b15 	stw	zero,44(sp)
  int fmtCase = 0;		/* For hex format, if 1, A-F, else a-f. */
  int write_count = 0;


  fmt = fmt0;
  state = expecting_literal_char;
10003488:	0029883a 	mov	r20,zero
				PRINT_CHAR_REPEATEDLY('0', padCharsNeeded);
			      }
			    else
			      {
				PRINT_CHAR_REPEATEDLY(' ', padCharsNeeded);
				if (sign)  PRINT_CHAR ('-');
1000348c:	d8c00915 	stw	r3,36(sp)


  fmt = fmt0;
  state = expecting_literal_char;

  while (0 != (c = *fmt++))
10003490:	d8c00f17 	ldw	r3,60(sp)
10003494:	19000003 	ldbu	r4,0(r3)
10003498:	20803fcc 	andi	r2,r4,255
1000349c:	1080201c 	xori	r2,r2,128
100034a0:	10bfe004 	addi	r2,r2,-128
100034a4:	10011c26 	beq	r2,zero,10003918 <___vfprintf_internal_r+0x4f0>
    {
      switch (state)
100034a8:	00c00044 	movi	r3,1
100034ac:	a0c01426 	beq	r20,r3,10003500 <___vfprintf_internal_r+0xd8>
100034b0:	1d000216 	blt	r3,r20,100034bc <___vfprintf_internal_r+0x94>
100034b4:	a0000626 	beq	r20,zero,100034d0 <___vfprintf_internal_r+0xa8>
100034b8:	00011306 	br	10003908 <___vfprintf_internal_r+0x4e0>
100034bc:	01400084 	movi	r5,2
100034c0:	a1401d26 	beq	r20,r5,10003538 <___vfprintf_internal_r+0x110>
100034c4:	014000c4 	movi	r5,3
100034c8:	a1402926 	beq	r20,r5,10003570 <___vfprintf_internal_r+0x148>
100034cc:	00010e06 	br	10003908 <___vfprintf_internal_r+0x4e0>
	{
	case expecting_literal_char:
	  if (c == '%')
100034d0:	01400944 	movi	r5,37
100034d4:	1140fb26 	beq	r2,r5,100038c4 <___vfprintf_internal_r+0x49c>
	      fmtWidth = -1;			/* For %17s this will be 17.  */
	      fmtPrecision = -1;		/* For %17.6X this will be 6. */
	      state = expecting_flag_char;	/* Remember that we just saw a '%'. */
	    }
	  else
	    PRINT_CHAR (c);
100034d8:	e0800117 	ldw	r2,4(fp)
100034dc:	d9000005 	stb	r4,0(sp)
100034e0:	01c00044 	movi	r7,1
100034e4:	d80d883a 	mov	r6,sp
100034e8:	e00b883a 	mov	r5,fp
100034ec:	9809883a 	mov	r4,r19
100034f0:	103ee83a 	callr	r2
100034f4:	1000d61e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
100034f8:	84000044 	addi	r16,r16,1
100034fc:	00010206 	br	10003908 <___vfprintf_internal_r+0x4e0>
	  break;

	case expecting_flag_char:		/* We just saw a %. */
	  if (c == '0')
10003500:	01400c04 	movi	r5,48
10003504:	1140f826 	beq	r2,r5,100038e8 <___vfprintf_internal_r+0x4c0>
	    {
	      fmtLeadingZero = 1;
	      state = expecting_width_char;
	    }
	  else if (c == '%')			/* We've got a %% in format -- print a single %. */
10003508:	01400944 	movi	r5,37
1000350c:	11400a1e 	bne	r2,r5,10003538 <___vfprintf_internal_r+0x110>
	    {
	      PRINT_CHAR (c);
10003510:	d8800005 	stb	r2,0(sp)
10003514:	e0800117 	ldw	r2,4(fp)
10003518:	a00f883a 	mov	r7,r20
1000351c:	d80d883a 	mov	r6,sp
10003520:	e00b883a 	mov	r5,fp
10003524:	9809883a 	mov	r4,r19
10003528:	103ee83a 	callr	r2
1000352c:	1000c81e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
10003530:	84000044 	addi	r16,r16,1
10003534:	0000f306 	br	10003904 <___vfprintf_internal_r+0x4dc>
	    }
	  break;

	case expecting_width_char:              /* Scan the 17 part of a %17.6X, say. */
	expecting_width:
	  if ('0' <= c && c <= '9')
10003538:	217ff404 	addi	r5,r4,-48
1000353c:	29403fcc 	andi	r5,r5,255
10003540:	00c00244 	movi	r3,9
10003544:	19400736 	bltu	r3,r5,10003564 <___vfprintf_internal_r+0x13c>
	    {
	      c -= '0';

	      if (fmtWidth < 0) fmtWidth  = 0;
10003548:	00bfffc4 	movi	r2,-1
1000354c:	88800226 	beq	r17,r2,10003558 <___vfprintf_internal_r+0x130>
	      else		fmtWidth *= 10;
10003550:	8c4002a4 	muli	r17,r17,10
10003554:	00000106 	br	1000355c <___vfprintf_internal_r+0x134>
	expecting_width:
	  if ('0' <= c && c <= '9')
	    {
	      c -= '0';

	      if (fmtWidth < 0) fmtWidth  = 0;
10003558:	0023883a 	mov	r17,zero
	      else		fmtWidth *= 10;

	      fmtWidth += c;
1000355c:	2c63883a 	add	r17,r5,r17
10003560:	0000e206 	br	100038ec <___vfprintf_internal_r+0x4c4>
	    }
	  else if (c == '.') {
10003564:	01400b84 	movi	r5,46
10003568:	1140e426 	beq	r2,r5,100038fc <___vfprintf_internal_r+0x4d4>
1000356c:	05000084 	movi	r20,2
	    goto expecting_precision;
	  break;

	case expecting_precision_char:		/* Scan the  6 part of a %17.6X, say. */
	expecting_precision:
	  if ('0' <= c && c <= '9')
10003570:	213ff404 	addi	r4,r4,-48
10003574:	21003fcc 	andi	r4,r4,255
10003578:	00c00244 	movi	r3,9
1000357c:	19000736 	bltu	r3,r4,1000359c <___vfprintf_internal_r+0x174>
	    {
	      c -= '0';

	      if (fmtPrecision < 0) fmtPrecision  = 0;
10003580:	00bfffc4 	movi	r2,-1
10003584:	90800226 	beq	r18,r2,10003590 <___vfprintf_internal_r+0x168>
	      else		    fmtPrecision *= 10;
10003588:	948002a4 	muli	r18,r18,10
1000358c:	00000106 	br	10003594 <___vfprintf_internal_r+0x16c>
	expecting_precision:
	  if ('0' <= c && c <= '9')
	    {
	      c -= '0';

	      if (fmtPrecision < 0) fmtPrecision  = 0;
10003590:	0025883a 	mov	r18,zero
	      else		    fmtPrecision *= 10;

	      fmtPrecision += c;
10003594:	24a5883a 	add	r18,r4,r18
10003598:	0000db06 	br	10003908 <___vfprintf_internal_r+0x4e0>
	    }
	  else if (c == 'l') {
1000359c:	00c01b04 	movi	r3,108
100035a0:	10c0d426 	beq	r2,r3,100038f4 <___vfprintf_internal_r+0x4cc>

	      /*
	       * Precision defaults to 1;
	       * "If a precision is given ... the 0 flag is ignored."
               */
	      if (fmtPrecision < 0)  fmtPrecision   = 1;	
100035a4:	013fffc4 	movi	r4,-1
100035a8:	91000226 	beq	r18,r4,100035b4 <___vfprintf_internal_r+0x18c>
	      else		     fmtLeadingZero = 0;
100035ac:	d8000b15 	stw	zero,44(sp)
100035b0:	00000106 	br	100035b8 <___vfprintf_internal_r+0x190>

	      /*
	       * Precision defaults to 1;
	       * "If a precision is given ... the 0 flag is ignored."
               */
	      if (fmtPrecision < 0)  fmtPrecision   = 1;	
100035b4:	04800044 	movi	r18,1
	      else		     fmtLeadingZero = 0;
              	
	      switch (c)
100035b8:	01001a44 	movi	r4,105
100035bc:	11001626 	beq	r2,r4,10003618 <___vfprintf_internal_r+0x1f0>
100035c0:	20800916 	blt	r4,r2,100035e8 <___vfprintf_internal_r+0x1c0>
100035c4:	010018c4 	movi	r4,99
100035c8:	11008a26 	beq	r2,r4,100037f4 <___vfprintf_internal_r+0x3cc>
100035cc:	01001904 	movi	r4,100
100035d0:	11001126 	beq	r2,r4,10003618 <___vfprintf_internal_r+0x1f0>
100035d4:	01001604 	movi	r4,88
100035d8:	1100ca1e 	bne	r2,r4,10003904 <___vfprintf_internal_r+0x4dc>
		  goto doIntegerPrint;

		case 'X':
		  fmtSigned = 0;
		  fmtBase = 16;
		  fmtCase = 1;
100035dc:	00c00044 	movi	r3,1
100035e0:	d8c00e15 	stw	r3,56(sp)
100035e4:	00001406 	br	10003638 <___vfprintf_internal_r+0x210>
	       * "If a precision is given ... the 0 flag is ignored."
               */
	      if (fmtPrecision < 0)  fmtPrecision   = 1;	
	      else		     fmtLeadingZero = 0;
              	
	      switch (c)
100035e8:	01001cc4 	movi	r4,115
100035ec:	11009a26 	beq	r2,r4,10003858 <___vfprintf_internal_r+0x430>
100035f0:	20800416 	blt	r4,r2,10003604 <___vfprintf_internal_r+0x1dc>
100035f4:	01001bc4 	movi	r4,111
100035f8:	1100c21e 	bne	r2,r4,10003904 <___vfprintf_internal_r+0x4dc>
		  fmtSigned = 0;
		  goto doIntegerPrint;

		case 'o':
		  fmtSigned = 0;
		  fmtBase = 8;
100035fc:	05400204 	movi	r21,8
10003600:	00000e06 	br	1000363c <___vfprintf_internal_r+0x214>
	       * "If a precision is given ... the 0 flag is ignored."
               */
	      if (fmtPrecision < 0)  fmtPrecision   = 1;	
	      else		     fmtLeadingZero = 0;
              	
	      switch (c)
10003604:	01001d44 	movi	r4,117
10003608:	11000c26 	beq	r2,r4,1000363c <___vfprintf_internal_r+0x214>
1000360c:	01001e04 	movi	r4,120
10003610:	11000926 	beq	r2,r4,10003638 <___vfprintf_internal_r+0x210>
10003614:	0000bb06 	br	10003904 <___vfprintf_internal_r+0x4dc>
10003618:	b5000104 	addi	r20,r22,4
		    if (fmtLong)
		      if (fmtSigned)
			v = va_arg (ap, long);
		      else
			v = va_arg (ap, unsigned long);
		    else if (fmtSigned)
1000361c:	b8000726 	beq	r23,zero,1000363c <___vfprintf_internal_r+0x214>
		      v = va_arg (ap, int);
10003620:	dd000d15 	stw	r20,52(sp)
10003624:	b5800017 	ldw	r22,0(r22)
		    else
		      v = va_arg (ap, unsigned int);

		    /* Strip sign: */
		    sign = 0;
		    if (fmtSigned && (v & SIGN_BIT))
10003628:	b000080e 	bge	r22,zero,1000364c <___vfprintf_internal_r+0x224>
		      {
			/*
			 * Oddly, this works even for 0x80000000, which negates to itself:
			 * it still prints out correctly as -2147483648:
			 */
			v = -v;
1000362c:	05adc83a 	sub	r22,zero,r22
			sign = 1;
10003630:	02800044 	movi	r10,1
10003634:	00000606 	br	10003650 <___vfprintf_internal_r+0x228>
		  fmtBase = 8;
		  goto doIntegerPrint;

		case 'x':
		  fmtSigned = 0;
		  fmtBase = 16;
10003638:	05400404 	movi	r21,16
		      else
			v = va_arg (ap, unsigned long);
		    else if (fmtSigned)
		      v = va_arg (ap, int);
		    else
		      v = va_arg (ap, unsigned int);
1000363c:	b0c00104 	addi	r3,r22,4
10003640:	d8c00d15 	stw	r3,52(sp)
10003644:	b5800017 	ldw	r22,0(r22)
	      /*
	       * Precision defaults to 1;
	       * "If a precision is given ... the 0 flag is ignored."
               */
	      if (fmtPrecision < 0)  fmtPrecision   = 1;	
	      else		     fmtLeadingZero = 0;
10003648:	002f883a 	mov	r23,zero
		      v = va_arg (ap, int);
		    else
		      v = va_arg (ap, unsigned int);

		    /* Strip sign: */
		    sign = 0;
1000364c:	0015883a 	mov	r10,zero
10003650:	d829883a 	mov	r20,sp
			 * is correct here because spec requires
			 * that when field precision is zero.
			 * When field precision is nonzero, we
			 * will zero-pad later on:
                         */
			while (v) {
10003654:	b0001426 	beq	r22,zero,100036a8 <___vfprintf_internal_r+0x280>
			    /*
			     * Note: Doing a div-and-mul per digit is
			     * faster than a div-and-mod per digit:
			     */
			    int nextv = v / fmtBase;
10003658:	b009883a 	mov	r4,r22
1000365c:	a80b883a 	mov	r5,r21
10003660:	da801015 	stw	r10,64(sp)
10003664:	00031d80 	call	100031d8 <__udivsi3>
			    int digit = v - fmtBase*nextv;
10003668:	1549383a 	mul	r4,r2,r21

			    if (digit <= 9)   digit += '0';
1000366c:	00c00244 	movi	r3,9
10003670:	da801017 	ldw	r10,64(sp)
			    /*
			     * Note: Doing a div-and-mul per digit is
			     * faster than a div-and-mod per digit:
			     */
			    int nextv = v / fmtBase;
			    int digit = v - fmtBase*nextv;
10003674:	b12dc83a 	sub	r22,r22,r4

			    if (digit <= 9)   digit += '0';
10003678:	1d800216 	blt	r3,r22,10003684 <___vfprintf_internal_r+0x25c>
1000367c:	b5800c04 	addi	r22,r22,48
10003680:	00000506 	br	10003698 <___vfprintf_internal_r+0x270>
			    else if (fmtCase) digit += 'A' - 10;
10003684:	d8c00e17 	ldw	r3,56(sp)
10003688:	18000226 	beq	r3,zero,10003694 <___vfprintf_internal_r+0x26c>
1000368c:	b5800dc4 	addi	r22,r22,55
10003690:	00000106 	br	10003698 <___vfprintf_internal_r+0x270>
			    else              digit += 'a' - 10;
10003694:	b58015c4 	addi	r22,r22,87

			    *digitp++ = digit;
10003698:	a5800005 	stb	r22,0(r20)
1000369c:	a5000044 	addi	r20,r20,1

			    v = nextv;
100036a0:	102d883a 	mov	r22,r2
100036a4:	003feb06 	br	10003654 <___vfprintf_internal_r+0x22c>
			}

			int digitCount = digitp - digits;
100036a8:	a6c7c83a 	sub	r3,r20,sp
100036ac:	d8c00a15 	stw	r3,40(sp)
			/*
			 * Print any required leading padding
			 * plus the minus sign (if needed):
			 */
			{
			    int padDigitsNeeded = fmtPrecision - digitCount;
100036b0:	90c5c83a 	sub	r2,r18,r3
			    if (padDigitsNeeded > 0) {
100036b4:	00800a0e 	bge	zero,r2,100036e0 <___vfprintf_internal_r+0x2b8>
100036b8:	a085883a 	add	r2,r20,r2
			        while (padDigitsNeeded > 0  && digitp < &digits[32]) {
				    *digitp++ = '0';
100036bc:	01400c04 	movi	r5,48
			 * plus the minus sign (if needed):
			 */
			{
			    int padDigitsNeeded = fmtPrecision - digitCount;
			    if (padDigitsNeeded > 0) {
			        while (padDigitsNeeded > 0  && digitp < &digits[32]) {
100036c0:	d8c00917 	ldw	r3,36(sp)
100036c4:	a009883a 	mov	r4,r20
100036c8:	a0c0032e 	bgeu	r20,r3,100036d8 <___vfprintf_internal_r+0x2b0>
100036cc:	a5000044 	addi	r20,r20,1
				    *digitp++ = '0';
100036d0:	21400005 	stb	r5,0(r4)
			 * plus the minus sign (if needed):
			 */
			{
			    int padDigitsNeeded = fmtPrecision - digitCount;
			    if (padDigitsNeeded > 0) {
			        while (padDigitsNeeded > 0  && digitp < &digits[32]) {
100036d4:	a0bffa1e 	bne	r20,r2,100036c0 <___vfprintf_internal_r+0x298>
				    *digitp++ = '0';
				    --padDigitsNeeded;
				}
				digitCount = digitp - digits;
100036d8:	a6c7c83a 	sub	r3,r20,sp
100036dc:	d8c00a15 	stw	r3,40(sp)
			    }

			    int padCharsNeeded = fmtWidth - (digitCount + sign);
100036e0:	d8c00a17 	ldw	r3,40(sp)
100036e4:	50d3883a 	add	r9,r10,r3

			    if (fmtLeadingZero)
100036e8:	d8c00b17 	ldw	r3,44(sp)
				    --padDigitsNeeded;
				}
				digitCount = digitp - digits;
			    }

			    int padCharsNeeded = fmtWidth - (digitCount + sign);
100036ec:	8a6dc83a 	sub	r22,r17,r9

			    if (fmtLeadingZero)
100036f0:	18001726 	beq	r3,zero,10003750 <___vfprintf_internal_r+0x328>
			      {
				if (sign)  PRINT_CHAR ('-');
100036f4:	50000a26 	beq	r10,zero,10003720 <___vfprintf_internal_r+0x2f8>
100036f8:	00800b44 	movi	r2,45
100036fc:	d8800805 	stb	r2,32(sp)
10003700:	e0800117 	ldw	r2,4(fp)
10003704:	01c00044 	movi	r7,1
10003708:	d9800804 	addi	r6,sp,32
1000370c:	e00b883a 	mov	r5,fp
10003710:	9809883a 	mov	r4,r19
10003714:	103ee83a 	callr	r2
10003718:	10004d1e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
1000371c:	84000044 	addi	r16,r16,1
				PRINT_CHAR_REPEATEDLY('0', padCharsNeeded);
10003720:	0580070e 	bge	zero,r22,10003740 <___vfprintf_internal_r+0x318>
10003724:	b00f883a 	mov	r7,r22
10003728:	01800c04 	movi	r6,48
1000372c:	e00b883a 	mov	r5,fp
10003730:	9809883a 	mov	r4,r19
10003734:	00033bc0 	call	100033bc <print_repeat>
10003738:	1000451e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
1000373c:	85a1883a 	add	r16,r16,r22
10003740:	d8c00a17 	ldw	r3,40(sp)
10003744:	a013883a 	mov	r9,r20
10003748:	1d2dc83a 	sub	r22,r3,r20
1000374c:	00002206 	br	100037d8 <___vfprintf_internal_r+0x3b0>
			      }
			    else
			      {
				PRINT_CHAR_REPEATEDLY(' ', padCharsNeeded);
10003750:	0580090e 	bge	zero,r22,10003778 <___vfprintf_internal_r+0x350>
10003754:	b00f883a 	mov	r7,r22
10003758:	01800804 	movi	r6,32
1000375c:	e00b883a 	mov	r5,fp
10003760:	9809883a 	mov	r4,r19
10003764:	da801015 	stw	r10,64(sp)
10003768:	00033bc0 	call	100033bc <print_repeat>
1000376c:	da801017 	ldw	r10,64(sp)
10003770:	1000371e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
10003774:	85a1883a 	add	r16,r16,r22
				if (sign)  PRINT_CHAR ('-');
10003778:	503ff126 	beq	r10,zero,10003740 <___vfprintf_internal_r+0x318>
1000377c:	00800b44 	movi	r2,45
10003780:	d8800805 	stb	r2,32(sp)
10003784:	e0800117 	ldw	r2,4(fp)
10003788:	01c00044 	movi	r7,1
1000378c:	d9800804 	addi	r6,sp,32
10003790:	e00b883a 	mov	r5,fp
10003794:	9809883a 	mov	r4,r19
10003798:	103ee83a 	callr	r2
1000379c:	10002c1e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
100037a0:	84000044 	addi	r16,r16,1
100037a4:	003fe606 	br	10003740 <___vfprintf_internal_r+0x318>
			 * We generated them least-significant-digit-first, but
			 * we need to print them most-significant-digit-first,
			 * so we process digits[] in reverse order:
			 */
			while (digitCount --> 0) {
			    PRINT_CHAR( *--digitp );
100037a8:	4a7fffc4 	addi	r9,r9,-1
100037ac:	48800003 	ldbu	r2,0(r9)
100037b0:	01c00044 	movi	r7,1
100037b4:	d9800804 	addi	r6,sp,32
100037b8:	d8800805 	stb	r2,32(sp)
100037bc:	e0800117 	ldw	r2,4(fp)
100037c0:	e00b883a 	mov	r5,fp
100037c4:	da401015 	stw	r9,64(sp)
100037c8:	9809883a 	mov	r4,r19
100037cc:	103ee83a 	callr	r2
100037d0:	da401017 	ldw	r9,64(sp)
100037d4:	10001e1e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
100037d8:	8245c83a 	sub	r2,r16,r9
100037dc:	4d89883a 	add	r4,r9,r22
100037e0:	a085883a 	add	r2,r20,r2
			 *
			 * We generated them least-significant-digit-first, but
			 * we need to print them most-significant-digit-first,
			 * so we process digits[] in reverse order:
			 */
			while (digitCount --> 0) {
100037e4:	013ff016 	blt	zero,r4,100037a8 <___vfprintf_internal_r+0x380>
			}  
		    }
		  }

		  state = expecting_literal_char;
		  break;
100037e8:	1021883a 	mov	r16,r2
100037ec:	dd800d17 	ldw	r22,52(sp)
100037f0:	00004406 	br	10003904 <___vfprintf_internal_r+0x4dc>
		  fmtBase = 16;
		  fmtCase = 1;
		  goto doIntegerPrint;

		case 'c':
		  PRINT_CHAR_REPEATEDLY (' ', fmtWidth - 1);
100037f4:	00800044 	movi	r2,1
100037f8:	1440080e 	bge	r2,r17,1000381c <___vfprintf_internal_r+0x3f4>
100037fc:	8d3fffc4 	addi	r20,r17,-1
10003800:	a00f883a 	mov	r7,r20
10003804:	01800804 	movi	r6,32
10003808:	e00b883a 	mov	r5,fp
1000380c:	9809883a 	mov	r4,r19
10003810:	00033bc0 	call	100033bc <print_repeat>
10003814:	10000e1e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
10003818:	8521883a 	add	r16,r16,r20
		  {
		    char x = va_arg (ap, int);
		    PRINT_CHAR (x);
1000381c:	b0800017 	ldw	r2,0(r22)
10003820:	01c00044 	movi	r7,1
10003824:	d80d883a 	mov	r6,sp
10003828:	d8800005 	stb	r2,0(sp)
1000382c:	e0800117 	ldw	r2,4(fp)
10003830:	e00b883a 	mov	r5,fp
10003834:	9809883a 	mov	r4,r19
		  goto doIntegerPrint;

		case 'c':
		  PRINT_CHAR_REPEATEDLY (' ', fmtWidth - 1);
		  {
		    char x = va_arg (ap, int);
10003838:	b5000104 	addi	r20,r22,4
		    PRINT_CHAR (x);
1000383c:	103ee83a 	callr	r2
10003840:	1000031e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
10003844:	84000044 	addi	r16,r16,1
		  goto doIntegerPrint;

		case 'c':
		  PRINT_CHAR_REPEATEDLY (' ', fmtWidth - 1);
		  {
		    char x = va_arg (ap, int);
10003848:	a02d883a 	mov	r22,r20
1000384c:	00002d06 	br	10003904 <___vfprintf_internal_r+0x4dc>


  return write_count;
  
error:
  return EOF;
10003850:	00bfffc4 	movi	r2,-1
10003854:	00003106 	br	1000391c <___vfprintf_internal_r+0x4f4>
		  }
		  break;

		case 's':
		  {
		    char* s =  va_arg (ap, char*);
10003858:	b5000017 	ldw	r20,0(r22)
1000385c:	b0c00104 	addi	r3,r22,4
10003860:	d8c00a15 	stw	r3,40(sp)
		    int len =  strlen(s); 
10003864:	a009883a 	mov	r4,r20
10003868:	00033a00 	call	100033a0 <strlen>

		    int padBlanksNeeded =  fmtWidth - len;
1000386c:	8893c83a 	sub	r9,r17,r2
		  break;

		case 's':
		  {
		    char* s =  va_arg (ap, char*);
		    int len =  strlen(s); 
10003870:	102d883a 	mov	r22,r2

		    int padBlanksNeeded =  fmtWidth - len;

		    PRINT_CHAR_REPEATEDLY(' ', padBlanksNeeded);
10003874:	0240090e 	bge	zero,r9,1000389c <___vfprintf_internal_r+0x474>
10003878:	480f883a 	mov	r7,r9
1000387c:	01800804 	movi	r6,32
10003880:	e00b883a 	mov	r5,fp
10003884:	9809883a 	mov	r4,r19
10003888:	da401015 	stw	r9,64(sp)
1000388c:	00033bc0 	call	100033bc <print_repeat>
10003890:	da401017 	ldw	r9,64(sp)
10003894:	103fee1e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
10003898:	8261883a 	add	r16,r16,r9

		    PRINT_STRING (s, len);
1000389c:	e0800117 	ldw	r2,4(fp)
100038a0:	b00f883a 	mov	r7,r22
100038a4:	a00d883a 	mov	r6,r20
100038a8:	e00b883a 	mov	r5,fp
100038ac:	9809883a 	mov	r4,r19
100038b0:	103ee83a 	callr	r2
100038b4:	103fe61e 	bne	r2,zero,10003850 <___vfprintf_internal_r+0x428>
100038b8:	85a1883a 	add	r16,r16,r22
		  }
		  break;

		case 's':
		  {
		    char* s =  va_arg (ap, char*);
100038bc:	dd800a17 	ldw	r22,40(sp)
100038c0:	00001006 	br	10003904 <___vfprintf_internal_r+0x4dc>
	  if (c == '%')
	    {
	      fmtLeadingZero = 0;		/* Set to 1 for %08d etc. */
	      fmtLong = 0;			/* Set to 1 for %ld  etc. */
	      fmtBase = 10;			/* Set to 8 for octal, 16 for hex. */
	      fmtSigned = 1;			/* Set to 0 for %o %u %x %X. */
100038c4:	05c00044 	movi	r23,1
	      fmtCase = 0;			/* Set to 1 to produce uppercase hex (%X). */
	      fmtWidth = -1;			/* For %17s this will be 17.  */
	      fmtPrecision = -1;		/* For %17.6X this will be 6. */
100038c8:	04bfffc4 	movi	r18,-1
	    {
	      fmtLeadingZero = 0;		/* Set to 1 for %08d etc. */
	      fmtLong = 0;			/* Set to 1 for %ld  etc. */
	      fmtBase = 10;			/* Set to 8 for octal, 16 for hex. */
	      fmtSigned = 1;			/* Set to 0 for %o %u %x %X. */
	      fmtCase = 0;			/* Set to 1 to produce uppercase hex (%X). */
100038cc:	d8000e15 	stw	zero,56(sp)
	case expecting_literal_char:
	  if (c == '%')
	    {
	      fmtLeadingZero = 0;		/* Set to 1 for %08d etc. */
	      fmtLong = 0;			/* Set to 1 for %ld  etc. */
	      fmtBase = 10;			/* Set to 8 for octal, 16 for hex. */
100038d0:	05400284 	movi	r21,10
	      fmtSigned = 1;			/* Set to 0 for %o %u %x %X. */
	      fmtCase = 0;			/* Set to 1 to produce uppercase hex (%X). */
	      fmtWidth = -1;			/* For %17s this will be 17.  */
100038d4:	9023883a 	mov	r17,r18
	{
	case expecting_literal_char:
	  if (c == '%')
	    {
	      fmtLeadingZero = 0;		/* Set to 1 for %08d etc. */
	      fmtLong = 0;			/* Set to 1 for %ld  etc. */
100038d8:	d8000c15 	stw	zero,48(sp)
      switch (state)
	{
	case expecting_literal_char:
	  if (c == '%')
	    {
	      fmtLeadingZero = 0;		/* Set to 1 for %08d etc. */
100038dc:	d8000b15 	stw	zero,44(sp)
	      fmtBase = 10;			/* Set to 8 for octal, 16 for hex. */
	      fmtSigned = 1;			/* Set to 0 for %o %u %x %X. */
	      fmtCase = 0;			/* Set to 1 to produce uppercase hex (%X). */
	      fmtWidth = -1;			/* For %17s this will be 17.  */
	      fmtPrecision = -1;		/* For %17.6X this will be 6. */
	      state = expecting_flag_char;	/* Remember that we just saw a '%'. */
100038e0:	b829883a 	mov	r20,r23
100038e4:	00000806 	br	10003908 <___vfprintf_internal_r+0x4e0>
	  break;

	case expecting_flag_char:		/* We just saw a %. */
	  if (c == '0')
	    {
	      fmtLeadingZero = 1;
100038e8:	dd000b15 	stw	r20,44(sp)
	      state = expecting_width_char;
100038ec:	05000084 	movi	r20,2
100038f0:	00000506 	br	10003908 <___vfprintf_internal_r+0x4e0>
	      else		    fmtPrecision *= 10;

	      fmtPrecision += c;
	    }
	  else if (c == 'l') {
	    fmtLong = 1;
100038f4:	00c00044 	movi	r3,1
100038f8:	d8c00c15 	stw	r3,48(sp)
	    state = expecting_precision_char; 	
100038fc:	050000c4 	movi	r20,3
10003900:	00000106 	br	10003908 <___vfprintf_internal_r+0x4e0>
		    PRINT_STRING (s, len);
		  }
		  break;
		default: ;
		}
	      state = expecting_literal_char;
10003904:	0029883a 	mov	r20,zero
10003908:	d8c00f17 	ldw	r3,60(sp)
1000390c:	18c00044 	addi	r3,r3,1
10003910:	d8c00f15 	stw	r3,60(sp)
10003914:	003ede06 	br	10003490 <___vfprintf_internal_r+0x68>
10003918:	8005883a 	mov	r2,r16

  return write_count;
  
error:
  return EOF;
}	
1000391c:	dfc01a17 	ldw	ra,104(sp)
10003920:	df001917 	ldw	fp,100(sp)
10003924:	ddc01817 	ldw	r23,96(sp)
10003928:	dd801717 	ldw	r22,92(sp)
1000392c:	dd401617 	ldw	r21,88(sp)
10003930:	dd001517 	ldw	r20,84(sp)
10003934:	dcc01417 	ldw	r19,80(sp)
10003938:	dc801317 	ldw	r18,76(sp)
1000393c:	dc401217 	ldw	r17,72(sp)
10003940:	dc001117 	ldw	r16,68(sp)
10003944:	dec01b04 	addi	sp,sp,108
10003948:	f800283a 	ret

1000394c <__vfprintf_internal>:
	va_list ap)
{
  int result;
  CHECK_STD_INIT (fp);
  _flockfile(fp);
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
1000394c:	300f883a 	mov	r7,r6
10003950:	280d883a 	mov	r6,r5
10003954:	200b883a 	mov	r5,r4
10003958:	d1200117 	ldw	r4,-32764(gp)
1000395c:	00034281 	jmpi	10003428 <___vfprintf_internal_r>

10003960 <__sfvwrite_small_dev>:


int
__sfvwrite_small_dev (struct _reent *data, struct __sFILE_small_file * fp, _CONST char *str, int len)
{
  if (cantwrite (fp))
10003960:	2880000b 	ldhu	r2,0(r5)
10003964:	1080020c 	andi	r2,r2,8
10003968:	10002126 	beq	r2,zero,100039f0 <__sfvwrite_small_dev+0x90>
    return EOF; 
    
  if (fp->_file >= 0)
1000396c:	2880008f 	ldh	r2,2(r5)
#define	COPY(n)	  (void) memmove((void *) fp->_p, (void *) p, (size_t) (n))


int
__sfvwrite_small_dev (struct _reent *data, struct __sFILE_small_file * fp, _CONST char *str, int len)
{
10003970:	defffa04 	addi	sp,sp,-24
10003974:	dc000015 	stw	r16,0(sp)
10003978:	dfc00515 	stw	ra,20(sp)
1000397c:	dd000415 	stw	r20,16(sp)
10003980:	dcc00315 	stw	r19,12(sp)
10003984:	dc800215 	stw	r18,8(sp)
10003988:	dc400115 	stw	r17,4(sp)
1000398c:	2821883a 	mov	r16,r5
  if (cantwrite (fp))
    return EOF; 
    
  if (fp->_file >= 0)
10003990:	10001216 	blt	r2,zero,100039dc <__sfvwrite_small_dev+0x7c>
10003994:	2027883a 	mov	r19,r4
10003998:	3025883a 	mov	r18,r6
1000399c:	3823883a 	mov	r17,r7
      int len_left = len;
            
      while (len_left > 0)
        {
	  int new_write;
	  new_write = _write_r (data, fp->_file, str, MIN (len_left, BUFSIZ));
100039a0:	05010004 	movi	r20,1024
    
  if (fp->_file >= 0)
    {
      int len_left = len;
            
      while (len_left > 0)
100039a4:	04400b0e 	bge	zero,r17,100039d4 <__sfvwrite_small_dev+0x74>
        {
	  int new_write;
	  new_write = _write_r (data, fp->_file, str, MIN (len_left, BUFSIZ));
100039a8:	880f883a 	mov	r7,r17
100039ac:	a440010e 	bge	r20,r17,100039b4 <__sfvwrite_small_dev+0x54>
100039b0:	01c10004 	movi	r7,1024
100039b4:	8140008f 	ldh	r5,2(r16)
100039b8:	900d883a 	mov	r6,r18
100039bc:	9809883a 	mov	r4,r19
100039c0:	0003a180 	call	10003a18 <_write_r>
	  if (new_write <= 0)
100039c4:	0080050e 	bge	zero,r2,100039dc <__sfvwrite_small_dev+0x7c>
	    goto err;
	  len_left = len_left - new_write;
100039c8:	88a3c83a 	sub	r17,r17,r2
	  str += new_write;
100039cc:	90a5883a 	add	r18,r18,r2
100039d0:	003ff406 	br	100039a4 <__sfvwrite_small_dev+0x44>
	}
      
      return 0;
100039d4:	0005883a 	mov	r2,zero
100039d8:	00000706 	br	100039f8 <__sfvwrite_small_dev+0x98>
    }
  /* else, we have an invalid FILE */

err:
  fp->_flags |= __SERR;
100039dc:	8080000b 	ldhu	r2,0(r16)
100039e0:	10801014 	ori	r2,r2,64
100039e4:	8080000d 	sth	r2,0(r16)
  return EOF;
100039e8:	00bfffc4 	movi	r2,-1
100039ec:	00000206 	br	100039f8 <__sfvwrite_small_dev+0x98>

int
__sfvwrite_small_dev (struct _reent *data, struct __sFILE_small_file * fp, _CONST char *str, int len)
{
  if (cantwrite (fp))
    return EOF; 
100039f0:	00bfffc4 	movi	r2,-1
100039f4:	f800283a 	ret
  /* else, we have an invalid FILE */

err:
  fp->_flags |= __SERR;
  return EOF;
}
100039f8:	dfc00517 	ldw	ra,20(sp)
100039fc:	dd000417 	ldw	r20,16(sp)
10003a00:	dcc00317 	ldw	r19,12(sp)
10003a04:	dc800217 	ldw	r18,8(sp)
10003a08:	dc400117 	ldw	r17,4(sp)
10003a0c:	dc000017 	ldw	r16,0(sp)
10003a10:	dec00604 	addi	sp,sp,24
10003a14:	f800283a 	ret

10003a18 <_write_r>:
_DEFUN (_write_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _CONST _PTR buf _AND
     size_t cnt)
{
10003a18:	defffe04 	addi	sp,sp,-8
10003a1c:	dc000015 	stw	r16,0(sp)
10003a20:	2021883a 	mov	r16,r4
10003a24:	2809883a 	mov	r4,r5
10003a28:	300b883a 	mov	r5,r6
  _ssize_t ret;

  errno = 0;
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
10003a2c:	380d883a 	mov	r6,r7
_DEFUN (_write_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _CONST _PTR buf _AND
     size_t cnt)
{
10003a30:	dfc00115 	stw	ra,4(sp)
  _ssize_t ret;

  errno = 0;
10003a34:	d020a415 	stw	zero,-32112(gp)
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
10003a38:	0003ba40 	call	10003ba4 <write>
10003a3c:	00ffffc4 	movi	r3,-1
10003a40:	10c0031e 	bne	r2,r3,10003a50 <_write_r+0x38>
10003a44:	d0e0a417 	ldw	r3,-32112(gp)
10003a48:	18000126 	beq	r3,zero,10003a50 <_write_r+0x38>
    ptr->_errno = errno;
10003a4c:	80c00015 	stw	r3,0(r16)
  return ret;
}
10003a50:	dfc00117 	ldw	ra,4(sp)
10003a54:	dc000017 	ldw	r16,0(sp)
10003a58:	dec00204 	addi	sp,sp,8
10003a5c:	f800283a 	ret

10003a60 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
10003a60:	deffff04 	addi	sp,sp,-4
10003a64:	01040734 	movhi	r4,4124
10003a68:	01440734 	movhi	r5,4124
10003a6c:	dfc00015 	stw	ra,0(sp)
10003a70:	211bf904 	addi	r4,r4,28644
10003a74:	295c8804 	addi	r5,r5,29216

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10003a78:	2140061e 	bne	r4,r5,10003a94 <alt_load+0x34>
10003a7c:	01040034 	movhi	r4,4096
10003a80:	01440034 	movhi	r5,4096
10003a84:	21000804 	addi	r4,r4,32
10003a88:	29400804 	addi	r5,r5,32
10003a8c:	2140121e 	bne	r4,r5,10003ad8 <alt_load+0x78>
10003a90:	00000b06 	br	10003ac0 <alt_load+0x60>
10003a94:	00c40734 	movhi	r3,4124
10003a98:	18dc8804 	addi	r3,r3,29216
10003a9c:	1907c83a 	sub	r3,r3,r4
10003aa0:	0005883a 	mov	r2,zero
  {
    while( to != end )
10003aa4:	10fff526 	beq	r2,r3,10003a7c <alt_load+0x1c>
    {
      *to++ = *from++;
10003aa8:	114f883a 	add	r7,r2,r5
10003aac:	39c00017 	ldw	r7,0(r7)
10003ab0:	110d883a 	add	r6,r2,r4
10003ab4:	10800104 	addi	r2,r2,4
10003ab8:	31c00015 	stw	r7,0(r6)
10003abc:	003ff906 	br	10003aa4 <alt_load+0x44>
10003ac0:	01040034 	movhi	r4,4096
10003ac4:	01440034 	movhi	r5,4096
10003ac8:	21128304 	addi	r4,r4,18956
10003acc:	29528304 	addi	r5,r5,18956

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10003ad0:	2140101e 	bne	r4,r5,10003b14 <alt_load+0xb4>
10003ad4:	00000b06 	br	10003b04 <alt_load+0xa4>
10003ad8:	00c40034 	movhi	r3,4096
10003adc:	18c00804 	addi	r3,r3,32
10003ae0:	1907c83a 	sub	r3,r3,r4
10003ae4:	0005883a 	mov	r2,zero
  {
    while( to != end )
10003ae8:	10fff526 	beq	r2,r3,10003ac0 <alt_load+0x60>
    {
      *to++ = *from++;
10003aec:	114f883a 	add	r7,r2,r5
10003af0:	39c00017 	ldw	r7,0(r7)
10003af4:	110d883a 	add	r6,r2,r4
10003af8:	10800104 	addi	r2,r2,4
10003afc:	31c00015 	stw	r7,0(r6)
10003b00:	003ff906 	br	10003ae8 <alt_load+0x88>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
10003b04:	00048580 	call	10004858 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
10003b08:	dfc00017 	ldw	ra,0(sp)
10003b0c:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
10003b10:	00049581 	jmpi	10004958 <alt_icache_flush_all>
10003b14:	00c40734 	movhi	r3,4124
10003b18:	18dbf904 	addi	r3,r3,28644
10003b1c:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
10003b20:	0005883a 	mov	r2,zero
  {
    while( to != end )
10003b24:	18bff726 	beq	r3,r2,10003b04 <alt_load+0xa4>
    {
      *to++ = *from++;
10003b28:	114f883a 	add	r7,r2,r5
10003b2c:	39c00017 	ldw	r7,0(r7)
10003b30:	110d883a 	add	r6,r2,r4
10003b34:	10800104 	addi	r2,r2,4
10003b38:	31c00015 	stw	r7,0(r6)
10003b3c:	003ff906 	br	10003b24 <alt_load+0xc4>

10003b40 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10003b40:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10003b44:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
10003b48:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
10003b4c:	0003c040 	call	10003c04 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
10003b50:	0003c240 	call	10003c24 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10003b54:	d1a0a517 	ldw	r6,-32108(gp)
10003b58:	d160a617 	ldw	r5,-32104(gp)
10003b5c:	d120a717 	ldw	r4,-32100(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
10003b60:	dfc00017 	ldw	ra,0(sp)
10003b64:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
10003b68:	00002ec1 	jmpi	100002ec <main>

10003b6c <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
10003b6c:	defffe04 	addi	sp,sp,-8
10003b70:	dc000015 	stw	r16,0(sp)
10003b74:	dfc00115 	stw	ra,4(sp)
10003b78:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10003b7c:	00033a00 	call	100033a0 <strlen>
10003b80:	01040734 	movhi	r4,4124
10003b84:	000f883a 	mov	r7,zero
10003b88:	100d883a 	mov	r6,r2
10003b8c:	800b883a 	mov	r5,r16
10003b90:	211c8104 	addi	r4,r4,29188
#else
    return fputs(str, stdout);
#endif
#endif
}
10003b94:	dfc00117 	ldw	ra,4(sp)
10003b98:	dc000017 	ldw	r16,0(sp)
10003b9c:	dec00204 	addi	sp,sp,8
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
10003ba0:	0003de01 	jmpi	10003de0 <altera_avalon_jtag_uart_write>

10003ba4 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
10003ba4:	00800044 	movi	r2,1
10003ba8:	20800226 	beq	r4,r2,10003bb4 <write+0x10>
10003bac:	00800084 	movi	r2,2
10003bb0:	2080041e 	bne	r4,r2,10003bc4 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
10003bb4:	01040734 	movhi	r4,4124
10003bb8:	000f883a 	mov	r7,zero
10003bbc:	211c8104 	addi	r4,r4,29188
10003bc0:	0003de01 	jmpi	10003de0 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
10003bc4:	d0a00817 	ldw	r2,-32736(gp)
10003bc8:	10000926 	beq	r2,zero,10003bf0 <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
10003bcc:	deffff04 	addi	sp,sp,-4
10003bd0:	dfc00015 	stw	ra,0(sp)
10003bd4:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
10003bd8:	00c01444 	movi	r3,81
10003bdc:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
10003be0:	00bfffc4 	movi	r2,-1
10003be4:	dfc00017 	ldw	ra,0(sp)
10003be8:	dec00104 	addi	sp,sp,4
10003bec:	f800283a 	ret
10003bf0:	d0a0a404 	addi	r2,gp,-32112
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
10003bf4:	00c01444 	movi	r3,81
10003bf8:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
10003bfc:	00bfffc4 	movi	r2,-1
10003c00:	f800283a 	ret

10003c04 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
10003c04:	deffff04 	addi	sp,sp,-4
10003c08:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( PROCESSOR, processor);
10003c0c:	00049640 	call	10004964 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
10003c10:	00800044 	movi	r2,1
10003c14:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
10003c18:	dfc00017 	ldw	ra,0(sp)
10003c1c:	dec00104 	addi	sp,sp,4
10003c20:	f800283a 	ret

10003c24 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
10003c24:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG, jtag);
    ALTERA_AVALON_PERFORMANCE_COUNTER_INIT ( PERFORMANCE_COUNTER_0, performance_counter_0);
10003c28:	00800834 	movhi	r2,32
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
10003c2c:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG, jtag);
    ALTERA_AVALON_PERFORMANCE_COUNTER_INIT ( PERFORMANCE_COUNTER_0, performance_counter_0);
10003c30:	108c0004 	addi	r2,r2,12288
10003c34:	00c00044 	movi	r3,1
10003c38:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
    ALTERA_UP_AVALON_VIDEO_CHARACTER_BUFFER_WITH_DMA_INIT ( VIDEO_CHARACTER_BUFFER_WITH_DMA_0, video_character_buffer_with_dma_0);
10003c3c:	00840734 	movhi	r2,4124
10003c40:	109c5704 	addi	r2,r2,29020
10003c44:	10c00a17 	ldw	r3,40(r2)
10003c48:	01401004 	movi	r5,64
10003c4c:	18c00117 	ldw	r3,4(r3)
10003c50:	193fffcc 	andi	r4,r3,65535
10003c54:	1806d43a 	srli	r3,r3,16
10003c58:	11000c15 	stw	r4,48(r2)
10003c5c:	10c00d15 	stw	r3,52(r2)
10003c60:	29000436 	bltu	r5,r4,10003c74 <alt_sys_init+0x50>
10003c64:	01000fc4 	movi	r4,63
10003c68:	11000f15 	stw	r4,60(r2)
10003c6c:	01000184 	movi	r4,6
10003c70:	11001015 	stw	r4,64(r2)
10003c74:	01000804 	movi	r4,32
10003c78:	20c00236 	bltu	r4,r3,10003c84 <alt_sys_init+0x60>
10003c7c:	00c007c4 	movi	r3,31
10003c80:	10c01115 	stw	r3,68(r2)
10003c84:	01040734 	movhi	r4,4124
10003c88:	211c5704 	addi	r4,r4,29020
10003c8c:	0003e680 	call	10003e68 <alt_up_char_buffer_init>

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
10003c90:	01040734 	movhi	r4,4124
10003c94:	d1600404 	addi	r5,gp,-32752
10003c98:	211c5704 	addi	r4,r4,29020
10003c9c:	00048780 	call	10004878 <alt_dev_llist_insert>
    ALTERA_UP_AVALON_VIDEO_PIXEL_BUFFER_DMA_INIT ( DMA_BUFFER, dma_buffer);
10003ca0:	00840734 	movhi	r2,4124
10003ca4:	109c4204 	addi	r2,r2,28936
10003ca8:	10c00a17 	ldw	r3,40(r2)
10003cac:	01c00044 	movi	r7,1
10003cb0:	19000017 	ldw	r4,0(r3)
10003cb4:	11000b15 	stw	r4,44(r2)
10003cb8:	19000117 	ldw	r4,4(r3)
10003cbc:	11000c15 	stw	r4,48(r2)
10003cc0:	19000204 	addi	r4,r3,8
10003cc4:	2140000b 	ldhu	r5,0(r4)
10003cc8:	18c00304 	addi	r3,r3,12
10003ccc:	11400f15 	stw	r5,60(r2)
10003cd0:	21000017 	ldw	r4,0(r4)
10003cd4:	2008d43a 	srli	r4,r4,16
10003cd8:	11001015 	stw	r4,64(r2)
10003cdc:	19000017 	ldw	r4,0(r3)
10003ce0:	2009d07a 	srai	r4,r4,1
10003ce4:	2100004c 	andi	r4,r4,1
10003ce8:	11000d15 	stw	r4,52(r2)
10003cec:	19000017 	ldw	r4,0(r3)
10003cf0:	2009d13a 	srai	r4,r4,4
10003cf4:	210003cc 	andi	r4,r4,15
10003cf8:	11000e15 	stw	r4,56(r2)
10003cfc:	19400017 	ldw	r5,0(r3)
10003d00:	2807d43a 	srai	r3,r5,16
10003d04:	280cd63a 	srli	r6,r5,24
10003d08:	21c0021e 	bne	r4,r7,10003d14 <alt_sys_init+0xf0>
10003d0c:	10001115 	stw	zero,68(r2)
10003d10:	00000506 	br	10003d28 <alt_sys_init+0x104>
10003d14:	01400084 	movi	r5,2
10003d18:	2140021e 	bne	r4,r5,10003d24 <alt_sys_init+0x100>
10003d1c:	11c01115 	stw	r7,68(r2)
10003d20:	00000106 	br	10003d28 <alt_sys_init+0x104>
10003d24:	11401115 	stw	r5,68(r2)
10003d28:	18c03fcc 	andi	r3,r3,255
10003d2c:	01400804 	movi	r5,32
10003d30:	28cfc83a 	sub	r7,r5,r3
10003d34:	013fffc4 	movi	r4,-1
10003d38:	21ced83a 	srl	r7,r4,r7
10003d3c:	298bc83a 	sub	r5,r5,r6
10003d40:	2148d83a 	srl	r4,r4,r5
10003d44:	11c01215 	stw	r7,72(r2)
10003d48:	11c01117 	ldw	r7,68(r2)
10003d4c:	11001415 	stw	r4,80(r2)
10003d50:	01040734 	movhi	r4,4124
10003d54:	38c7883a 	add	r3,r7,r3
10003d58:	d1600404 	addi	r5,gp,-32752
10003d5c:	211c4204 	addi	r4,r4,28936
10003d60:	10c01315 	stw	r3,76(r2)
10003d64:	00048780 	call	10004878 <alt_dev_llist_insert>
    ALTERA_UP_AVALON_VIDEO_RGB_RESAMPLER_INIT ( RGB_RESAMPLER, rgb_resampler);
10003d68:	01040734 	movhi	r4,4124
10003d6c:	211c3104 	addi	r4,r4,28868
10003d70:	20800a17 	ldw	r2,40(r4)
10003d74:	d1600404 	addi	r5,gp,-32752
10003d78:	10c00017 	ldw	r3,0(r2)
10003d7c:	18c003cc 	andi	r3,r3,15
10003d80:	20c00b15 	stw	r3,44(r4)
10003d84:	10c00017 	ldw	r3,0(r2)
10003d88:	1807d13a 	srai	r3,r3,4
10003d8c:	18c0004c 	andi	r3,r3,1
10003d90:	20c00c15 	stw	r3,48(r4)
10003d94:	10c00017 	ldw	r3,0(r2)
10003d98:	1807d17a 	srai	r3,r3,5
10003d9c:	18c0004c 	andi	r3,r3,1
10003da0:	20c00d15 	stw	r3,52(r4)
10003da4:	10c00017 	ldw	r3,0(r2)
10003da8:	1807d43a 	srai	r3,r3,16
10003dac:	18c003cc 	andi	r3,r3,15
10003db0:	20c00e15 	stw	r3,56(r4)
10003db4:	10c00017 	ldw	r3,0(r2)
10003db8:	1807d53a 	srai	r3,r3,20
10003dbc:	18c0004c 	andi	r3,r3,1
10003dc0:	20c00f15 	stw	r3,60(r4)
10003dc4:	10800017 	ldw	r2,0(r2)
10003dc8:	1005d57a 	srai	r2,r2,21
10003dcc:	1080004c 	andi	r2,r2,1
10003dd0:	20801015 	stw	r2,64(r4)
}
10003dd4:	dfc00017 	ldw	ra,0(sp)
10003dd8:	dec00104 	addi	sp,sp,4
10003ddc:	00048781 	jmpi	10004878 <alt_dev_llist_insert>

10003de0 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
10003de0:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
10003de4:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
10003de8:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10003dec:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
10003df0:	2980072e 	bgeu	r5,r6,10003e10 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
10003df4:	38c00037 	ldwio	r3,0(r7)
10003df8:	18ffffec 	andhi	r3,r3,65535
10003dfc:	183ffc26 	beq	r3,zero,10003df0 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
10003e00:	28c00007 	ldb	r3,0(r5)
10003e04:	20c00035 	stwio	r3,0(r4)
10003e08:	29400044 	addi	r5,r5,1
10003e0c:	003ff806 	br	10003df0 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
10003e10:	f800283a 	ret

10003e14 <perf_get_section_time>:
{
  alt_u32 lo;
  alt_u32 hi;
  alt_u64 result = 0;

  PERF_STOP_MEASURING(hw_base_address);
10003e14:	20000035 	stwio	zero,0(r4)
  lo = IORD(hw_base_address, ( which_section*4   ));
10003e18:	280a913a 	slli	r5,r5,4
10003e1c:	2145883a 	add	r2,r4,r5
10003e20:	10800037 	ldwio	r2,0(r2)
  hi = IORD(hw_base_address, ((which_section*4)+1));
10003e24:	29400104 	addi	r5,r5,4
10003e28:	2149883a 	add	r4,r4,r5
10003e2c:	20c00037 	ldwio	r3,0(r4)

  result = ((alt_u64)(((alt_u64) hi) << ((alt_u64)32))) | 
           ((alt_u64)(((alt_u64) lo)                 ))  ;
  return result;
}
10003e30:	f800283a 	ret

10003e34 <perf_get_total_time>:

alt_u64 perf_get_total_time   (void* hw_base_address)
{
  return perf_get_section_time (hw_base_address, 0);
10003e34:	000b883a 	mov	r5,zero
10003e38:	0003e141 	jmpi	10003e14 <perf_get_section_time>

10003e3c <perf_get_num_starts>:
}

alt_u32 perf_get_num_starts   (void* hw_base_address, int which_section)
{
  return IORD(hw_base_address, ((which_section*4)+2));
10003e3c:	280a913a 	slli	r5,r5,4
10003e40:	29400204 	addi	r5,r5,8
10003e44:	2149883a 	add	r4,r4,r5
}
10003e48:	20800037 	ldwio	r2,0(r4)
10003e4c:	f800283a 	ret

10003e50 <alt_get_performance_counter_base>:
#ifdef PERFORMANCE_COUNTER_0_BASE
    return (void*)PERFORMANCE_COUNTER_0_BASE;
#else
    return (void*)0;
#endif
}
10003e50:	00800834 	movhi	r2,32
10003e54:	108c0004 	addi	r2,r2,12288
10003e58:	f800283a 	ret

10003e5c <alt_get_cpu_freq>:
 */
alt_u32 
alt_get_cpu_freq()
{
    return ALT_CPU_FREQ;
}
10003e5c:	0080bef4 	movhi	r2,763
10003e60:	10bc2004 	addi	r2,r2,-3968
10003e64:	f800283a 	ret

10003e68 <alt_up_char_buffer_init>:
#include <priv/alt_file.h>

#include "altera_up_avalon_video_character_buffer_with_dma.h"
#include "altera_up_avalon_video_character_buffer_with_dma_regs.h"

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
10003e68:	defffe04 	addi	sp,sp,-8
10003e6c:	dc000015 	stw	r16,0(sp)
	char * name;
	name = (char *) char_buffer->dev.name;
10003e70:	24000217 	ldw	r16,8(r4)
#include <priv/alt_file.h>

#include "altera_up_avalon_video_character_buffer_with_dma.h"
#include "altera_up_avalon_video_character_buffer_with_dma_regs.h"

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
10003e74:	dfc00115 	stw	ra,4(sp)
	char * name;
	name = (char *) char_buffer->dev.name;

	for ( ; (*name) != '\0'; name++) {
10003e78:	80800007 	ldb	r2,0(r16)
10003e7c:	10000926 	beq	r2,zero,10003ea4 <alt_up_char_buffer_init+0x3c>
		if (strcmp(name, "_avalon_char_buffer_slave") == 0) {
10003e80:	01440734 	movhi	r5,4124
10003e84:	295bef04 	addi	r5,r5,28604
10003e88:	8009883a 	mov	r4,r16
10003e8c:	00049d40 	call	100049d4 <strcmp>
10003e90:	1000021e 	bne	r2,zero,10003e9c <alt_up_char_buffer_init+0x34>
			(*name) = '\0';
10003e94:	80000005 	stb	zero,0(r16)
			break;
10003e98:	00000206 	br	10003ea4 <alt_up_char_buffer_init+0x3c>

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
	char * name;
	name = (char *) char_buffer->dev.name;

	for ( ; (*name) != '\0'; name++) {
10003e9c:	84000044 	addi	r16,r16,1
10003ea0:	003ff506 	br	10003e78 <alt_up_char_buffer_init+0x10>
			break;
		}
	}
	
	return;
}
10003ea4:	dfc00117 	ldw	ra,4(sp)
10003ea8:	dc000017 	ldw	r16,0(sp)
10003eac:	dec00204 	addi	sp,sp,8
10003eb0:	f800283a 	ret

10003eb4 <alt_up_char_buffer_open_dev>:
alt_up_char_buffer_dev* alt_up_char_buffer_open_dev(const char* name) {
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_char_buffer_dev *dev = (alt_up_char_buffer_dev *)alt_find_dev(name, &alt_dev_list);
10003eb4:	d1600404 	addi	r5,gp,-32752
10003eb8:	00048e41 	jmpi	100048e4 <alt_find_dev>

10003ebc <alt_up_char_buffer_draw>:
}

int alt_up_char_buffer_draw(alt_up_char_buffer_dev *char_buffer, unsigned char ch, 
	unsigned int x, unsigned int y) {
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
10003ebc:	20800c17 	ldw	r2,48(r4)
10003ec0:	3080102e 	bgeu	r6,r2,10003f04 <alt_up_char_buffer_draw+0x48>
10003ec4:	20800d17 	ldw	r2,52(r4)
10003ec8:	38800e2e 	bgeu	r7,r2,10003f04 <alt_up_char_buffer_draw+0x48>
		return -1;
	
	unsigned int addr = 0;
	addr |= ((x & char_buffer->x_coord_mask) << char_buffer->x_coord_offset);
	addr |= ((y & char_buffer->y_coord_mask) << char_buffer->y_coord_offset);
	IOWR_8DIRECT(char_buffer->buffer_base, addr, ch);
10003ecc:	20800f17 	ldw	r2,60(r4)
10003ed0:	3084703a 	and	r2,r6,r2
10003ed4:	21800e17 	ldw	r6,56(r4)
10003ed8:	1186983a 	sll	r3,r2,r6
10003edc:	20801117 	ldw	r2,68(r4)
10003ee0:	21801017 	ldw	r6,64(r4)
10003ee4:	388e703a 	and	r7,r7,r2
10003ee8:	398e983a 	sll	r7,r7,r6
10003eec:	20800b17 	ldw	r2,44(r4)
10003ef0:	19ccb03a 	or	r6,r3,r7
10003ef4:	308d883a 	add	r6,r6,r2
10003ef8:	31400025 	stbio	r5,0(r6)

	return 0;
10003efc:	0005883a 	mov	r2,zero
10003f00:	f800283a 	ret

int alt_up_char_buffer_draw(alt_up_char_buffer_dev *char_buffer, unsigned char ch, 
	unsigned int x, unsigned int y) {
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
		return -1;
10003f04:	00bfffc4 	movi	r2,-1
	addr |= ((x & char_buffer->x_coord_mask) << char_buffer->x_coord_offset);
	addr |= ((y & char_buffer->y_coord_mask) << char_buffer->y_coord_offset);
	IOWR_8DIRECT(char_buffer->buffer_base, addr, ch);

	return 0;
}
10003f08:	f800283a 	ret

10003f0c <alt_up_char_buffer_string>:

int alt_up_char_buffer_string(alt_up_char_buffer_dev *char_buffer, const char *ptr, 
	unsigned int x, unsigned int y) {
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
10003f0c:	20800c17 	ldw	r2,48(r4)
10003f10:	30800236 	bltu	r6,r2,10003f1c <alt_up_char_buffer_string+0x10>
		return -1;
10003f14:	00bfffc4 	movi	r2,-1
10003f18:	f800283a 	ret
}

int alt_up_char_buffer_string(alt_up_char_buffer_dev *char_buffer, const char *ptr, 
	unsigned int x, unsigned int y) {
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
10003f1c:	20800d17 	ldw	r2,52(r4)
10003f20:	38bffc2e 	bgeu	r7,r2,10003f14 <alt_up_char_buffer_string+0x8>
		return -1;
	
	unsigned int offset = 0;
	offset = (y << char_buffer->y_coord_offset) + x;
10003f24:	20801017 	ldw	r2,64(r4)
10003f28:	388e983a 	sll	r7,r7,r2
10003f2c:	398f883a 	add	r7,r7,r6
10003f30:	394fc83a 	sub	r7,r7,r5

	while ( *ptr )
	{
		IOWR_8DIRECT(char_buffer->buffer_base, offset, *ptr);
		++ptr;
		if (++x >= char_buffer->x_resolution)
10003f34:	314dc83a 	sub	r6,r6,r5
		return -1;
	
	unsigned int offset = 0;
	offset = (y << char_buffer->y_coord_offset) + x;

	while ( *ptr )
10003f38:	28c00003 	ldbu	r3,0(r5)
10003f3c:	29d3883a 	add	r9,r5,r7
10003f40:	1a003fcc 	andi	r8,r3,255
10003f44:	4200201c 	xori	r8,r8,128
10003f48:	423fe004 	addi	r8,r8,-128
10003f4c:	40000826 	beq	r8,zero,10003f70 <alt_up_char_buffer_string+0x64>
	{
		IOWR_8DIRECT(char_buffer->buffer_base, offset, *ptr);
10003f50:	20800b17 	ldw	r2,44(r4)
10003f54:	4885883a 	add	r2,r9,r2
10003f58:	10c00025 	stbio	r3,0(r2)
		++ptr;
		if (++x >= char_buffer->x_resolution)
10003f5c:	20800c17 	ldw	r2,48(r4)
	offset = (y << char_buffer->y_coord_offset) + x;

	while ( *ptr )
	{
		IOWR_8DIRECT(char_buffer->buffer_base, offset, *ptr);
		++ptr;
10003f60:	29400044 	addi	r5,r5,1
		if (++x >= char_buffer->x_resolution)
10003f64:	2987883a 	add	r3,r5,r6
10003f68:	18bff336 	bltu	r3,r2,10003f38 <alt_up_char_buffer_string+0x2c>
10003f6c:	003fe906 	br	10003f14 <alt_up_char_buffer_string+0x8>
			return -1;
		++offset;
	}
	return 0;
10003f70:	0005883a 	mov	r2,zero
}
10003f74:	f800283a 	ret

10003f78 <alt_up_char_buffer_clear>:

int alt_up_char_buffer_clear(alt_up_char_buffer_dev *char_buffer) {
	IOWR_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base, 1);
10003f78:	20800a17 	ldw	r2,40(r4)
10003f7c:	00c00044 	movi	r3,1
10003f80:	10c000a5 	stbio	r3,2(r2)
	while ((IORD_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base) & ALT_UP_CHAR_BUFFER_CLR_SCRN_MSK) >> ALT_UP_CHAR_BUFFER_CLR_SCRN_OFST);
10003f84:	20800a17 	ldw	r2,40(r4)
10003f88:	108000a3 	ldbuio	r2,2(r2)
10003f8c:	1080004c 	andi	r2,r2,1
10003f90:	103ffc1e 	bne	r2,zero,10003f84 <alt_up_char_buffer_clear+0xc>
	return 0;
}
10003f94:	f800283a 	ret

10003f98 <alt_up_pixel_buffer_dma_open_dev>:
alt_up_pixel_buffer_dma_dev* alt_up_pixel_buffer_dma_open_dev(const char* name) {
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_pixel_buffer_dma_dev *dev = (alt_up_pixel_buffer_dma_dev*)alt_find_dev(name, &alt_dev_list);
10003f98:	d1600404 	addi	r5,gp,-32752
10003f9c:	00048e41 	jmpi	100048e4 <alt_find_dev>

10003fa0 <alt_up_pixel_buffer_dma_draw>:
int alt_up_pixel_buffer_dma_draw(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int color, unsigned int x, unsigned int y)
/* This function draws a pixel to the back buffer.
 */
{
	// boundary check
	if (x >= pixel_buffer->x_resolution || y >= pixel_buffer->y_resolution )
10003fa0:	20800f17 	ldw	r2,60(r4)
10003fa4:	3080222e 	bgeu	r6,r2,10004030 <alt_up_pixel_buffer_dma_draw+0x90>
10003fa8:	20c01017 	ldw	r3,64(r4)
10003fac:	38c0202e 	bgeu	r7,r3,10004030 <alt_up_pixel_buffer_dma_draw+0x90>
		return -1;

	unsigned int addr = 0;
	/* Check the mode VGA Pixel Buffer is using. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
10003fb0:	22800d17 	ldw	r10,52(r4)
10003fb4:	22001217 	ldw	r8,72(r4)
10003fb8:	22401117 	ldw	r9,68(r4)
10003fbc:	20c01417 	ldw	r3,80(r4)
10003fc0:	5000071e 	bne	r10,zero,10003fe0 <alt_up_pixel_buffer_dma_draw+0x40>
		/* For X-Y addressing mode, the address format is | unused | Y | X |. So shift bits for coordinates X and Y into their respective locations. */
		addr += ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
		addr += ((y & pixel_buffer->y_coord_mask) << pixel_buffer->y_coord_offset);
10003fc4:	3210703a 	and	r8,r6,r8
10003fc8:	21801317 	ldw	r6,76(r4)
10003fcc:	38c6703a 	and	r3,r7,r3
10003fd0:	4250983a 	sll	r8,r8,r9
10003fd4:	1986983a 	sll	r3,r3,r6
10003fd8:	40cd883a 	add	r6,r8,r3
10003fdc:	00000506 	br	10003ff4 <alt_up_pixel_buffer_dma_draw+0x54>
	} else {
		/* In a consecutive addressing mode, the pixels are stored in consecutive memory locations. So the address of a pixel at (x,y) can be computed as
		 * (y*x_resolution + x).*/
		addr += ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
		addr += (((y & pixel_buffer->y_coord_mask) * pixel_buffer->x_resolution) << pixel_buffer->x_coord_offset);
10003fe0:	38c6703a 	and	r3,r7,r3
10003fe4:	1885383a 	mul	r2,r3,r2
10003fe8:	3210703a 	and	r8,r6,r8
10003fec:	4085883a 	add	r2,r8,r2
10003ff0:	124c983a 	sll	r6,r2,r9
	}
	/* Now, depending on the color depth, write the pixel color to the specified memory location. */
	if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
10003ff4:	20c00e17 	ldw	r3,56(r4)
10003ff8:	20800c17 	ldw	r2,48(r4)
10003ffc:	01000044 	movi	r4,1
10004000:	1900031e 	bne	r3,r4,10004010 <alt_up_pixel_buffer_dma_draw+0x70>
		IOWR_8DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
10004004:	308d883a 	add	r6,r6,r2
10004008:	31400025 	stbio	r5,0(r6)
1000400c:	00000606 	br	10004028 <alt_up_pixel_buffer_dma_draw+0x88>
	} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
10004010:	01000084 	movi	r4,2
		IOWR_16DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
10004014:	308d883a 	add	r6,r6,r2
		addr += (((y & pixel_buffer->y_coord_mask) * pixel_buffer->x_resolution) << pixel_buffer->x_coord_offset);
	}
	/* Now, depending on the color depth, write the pixel color to the specified memory location. */
	if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
		IOWR_8DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
	} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
10004018:	1900021e 	bne	r3,r4,10004024 <alt_up_pixel_buffer_dma_draw+0x84>
		IOWR_16DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
1000401c:	3140002d 	sthio	r5,0(r6)
10004020:	00000106 	br	10004028 <alt_up_pixel_buffer_dma_draw+0x88>
	} else {
		IOWR_32DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
10004024:	31400035 	stwio	r5,0(r6)
	}

	return 0;
10004028:	0005883a 	mov	r2,zero
1000402c:	f800283a 	ret
/* This function draws a pixel to the back buffer.
 */
{
	// boundary check
	if (x >= pixel_buffer->x_resolution || y >= pixel_buffer->y_resolution )
		return -1;
10004030:	00bfffc4 	movi	r2,-1
	} else {
		IOWR_32DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
	}

	return 0;
}
10004034:	f800283a 	ret

10004038 <alt_up_pixel_buffer_dma_change_back_buffer_address>:

int alt_up_pixel_buffer_dma_change_back_buffer_address(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int new_address)
/* This function changes the memory address for the back buffer. */
{
	IOWR_32DIRECT(pixel_buffer->base, 4, new_address);
10004038:	20800a17 	ldw	r2,40(r4)
1000403c:	11400135 	stwio	r5,4(r2)
	pixel_buffer->back_buffer_start_address = IORD_32DIRECT(pixel_buffer->base, 4);
10004040:	20800a17 	ldw	r2,40(r4)
10004044:	10800137 	ldwio	r2,4(r2)
10004048:	20800c15 	stw	r2,48(r4)
	return 0;
}
1000404c:	0005883a 	mov	r2,zero
10004050:	f800283a 	ret

10004054 <alt_up_pixel_buffer_dma_swap_buffers>:

int alt_up_pixel_buffer_dma_swap_buffers(alt_up_pixel_buffer_dma_dev *pixel_buffer)
/* This function swaps the front and back buffers. At the next refresh cycle the back buffer will be drawn on the screen
 * and will become the front buffer. */
{
	register unsigned int temp = pixel_buffer->back_buffer_start_address;
10004054:	20800c17 	ldw	r2,48(r4)
	IOWR_32DIRECT(pixel_buffer->base, 0, 1);
10004058:	20c00a17 	ldw	r3,40(r4)
1000405c:	01400044 	movi	r5,1
10004060:	19400035 	stwio	r5,0(r3)
	pixel_buffer->back_buffer_start_address = pixel_buffer->buffer_start_address;
10004064:	20c00b17 	ldw	r3,44(r4)
	pixel_buffer->buffer_start_address = temp;
10004068:	20800b15 	stw	r2,44(r4)
	return 0;
}
1000406c:	0005883a 	mov	r2,zero
/* This function swaps the front and back buffers. At the next refresh cycle the back buffer will be drawn on the screen
 * and will become the front buffer. */
{
	register unsigned int temp = pixel_buffer->back_buffer_start_address;
	IOWR_32DIRECT(pixel_buffer->base, 0, 1);
	pixel_buffer->back_buffer_start_address = pixel_buffer->buffer_start_address;
10004070:	20c00c15 	stw	r3,48(r4)
	pixel_buffer->buffer_start_address = temp;
	return 0;
}
10004074:	f800283a 	ret

10004078 <alt_up_pixel_buffer_dma_check_swap_buffers_status>:
/* This function checks if the buffer swap has occured. Since the buffer swap only happens after an entire screen is drawn,
 * it is important to wait for this function to return 0 before proceeding to draw on either buffer. When both front and the back buffers
 * have the same address calling the alt_up_pixel_buffer_dma_swap_buffers(...) function and then waiting for this function to return 0, causes your program to
 * wait for the screen to refresh. */
{
	return (IORD_32DIRECT(pixel_buffer->base, 12) & 0x1);
10004078:	20800a17 	ldw	r2,40(r4)
1000407c:	10800337 	ldwio	r2,12(r2)
}
10004080:	1080004c 	andi	r2,r2,1
10004084:	f800283a 	ret

10004088 <alt_up_pixel_buffer_dma_clear_screen>:
{
	register unsigned int addr;
	register unsigned int limit_x, limit_y;
	
	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
10004088:	00800044 	movi	r2,1
1000408c:	2880021e 	bne	r5,r2,10004098 <alt_up_pixel_buffer_dma_clear_screen+0x10>
		addr = pixel_buffer->back_buffer_start_address;
10004090:	20c00c17 	ldw	r3,48(r4)
10004094:	00000106 	br	1000409c <alt_up_pixel_buffer_dma_clear_screen+0x14>
	else
		addr = pixel_buffer->buffer_start_address;
10004098:	20c00b17 	ldw	r3,44(r4)
	limit_x = pixel_buffer->x_resolution;
1000409c:	20800f17 	ldw	r2,60(r4)
	/* In 16 and 32-bit color modes we use twice or four times more memory for the display buffer.*/
	if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
100040a0:	21800e17 	ldw	r6,56(r4)
100040a4:	01400084 	movi	r5,2
100040a8:	1085883a 	add	r2,r2,r2
100040ac:	31400126 	beq	r6,r5,100040b4 <alt_up_pixel_buffer_dma_clear_screen+0x2c>
		limit_x = limit_x << 1;
	} else {
		limit_x = limit_x << 2;
100040b0:	1085883a 	add	r2,r2,r2
	}	
	limit_y = pixel_buffer->y_resolution;

	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
100040b4:	21800d17 	ldw	r6,52(r4)
	if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
		limit_x = limit_x << 1;
	} else {
		limit_x = limit_x << 2;
	}	
	limit_y = pixel_buffer->y_resolution;
100040b8:	21401017 	ldw	r5,64(r4)

	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
100040bc:	30000e1e 	bne	r6,zero,100040f8 <alt_up_pixel_buffer_dma_clear_screen+0x70>
		{
			for (x = 0; x < limit_x; x = x + 4)
			{
				IOWR_32DIRECT(addr, x, 0);
			}
			addr = addr + (1 << offset_y);
100040c0:	21c01317 	ldw	r7,76(r4)
100040c4:	01000044 	movi	r4,1
100040c8:	21ce983a 	sll	r7,r4,r7
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
100040cc:	31400926 	beq	r6,r5,100040f4 <alt_up_pixel_buffer_dma_clear_screen+0x6c>
100040d0:	1809883a 	mov	r4,r3
		{
			for (x = 0; x < limit_x; x = x + 4)
100040d4:	20d1c83a 	sub	r8,r4,r3
100040d8:	4080032e 	bgeu	r8,r2,100040e8 <alt_up_pixel_buffer_dma_clear_screen+0x60>
			{
				IOWR_32DIRECT(addr, x, 0);
100040dc:	20000035 	stwio	zero,0(r4)
100040e0:	21000104 	addi	r4,r4,4
100040e4:	003ffb06 	br	100040d4 <alt_up_pixel_buffer_dma_clear_screen+0x4c>
			}
			addr = addr + (1 << offset_y);
100040e8:	19c7883a 	add	r3,r3,r7
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
100040ec:	31800044 	addi	r6,r6,1
100040f0:	003ff606 	br	100040cc <alt_up_pixel_buffer_dma_clear_screen+0x44>
100040f4:	f800283a 	ret
			addr = addr + (1 << offset_y);
		}
	} else {
		/* Clear the screen when the VGA is set up in a linear addressing mode. */
		register int x;
		limit_y = limit_x*limit_y;	
100040f8:	1145383a 	mul	r2,r2,r5

		for (x = 0; x < limit_y; x = x + 4)
100040fc:	1809883a 	mov	r4,r3
10004100:	20cbc83a 	sub	r5,r4,r3
10004104:	2880032e 	bgeu	r5,r2,10004114 <alt_up_pixel_buffer_dma_clear_screen+0x8c>
		{
			IOWR_32DIRECT(addr, x, 0);
10004108:	20000035 	stwio	zero,0(r4)
1000410c:	21000104 	addi	r4,r4,4
10004110:	003ffb06 	br	10004100 <alt_up_pixel_buffer_dma_clear_screen+0x78>
10004114:	f800283a 	ret

10004118 <alt_up_pixel_buffer_dma_draw_box>:
	}
}

void alt_up_pixel_buffer_dma_draw_box(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a filled box. */
{
10004118:	d8800017 	ldw	r2,0(sp)
1000411c:	db000117 	ldw	r12,4(sp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
10004120:	22400f17 	ldw	r9,60(r4)
	register unsigned int limit_y = pixel_buffer->y_resolution;
	register unsigned int temp;
	register unsigned int l_x = x0;
10004124:	2815883a 	mov	r10,r5
	register unsigned int r_x = x1;
	register unsigned int t_y = y0;
10004128:	3011883a 	mov	r8,r6
	register unsigned int b_y = y1;
1000412c:	1017883a 	mov	r11,r2
	register unsigned int local_color = color;
	
	/* Check coordinates */
	if (l_x > r_x)
10004130:	3940022e 	bgeu	r7,r5,1000413c <alt_up_pixel_buffer_dma_draw_box+0x24>
10004134:	3815883a 	mov	r10,r7
10004138:	280f883a 	mov	r7,r5
	{
		temp = l_x;
		l_x = r_x;
		r_x = temp;
	}
	if (t_y > b_y)
1000413c:	1180022e 	bgeu	r2,r6,10004148 <alt_up_pixel_buffer_dma_draw_box+0x30>
10004140:	1011883a 	mov	r8,r2
10004144:	3017883a 	mov	r11,r6
	{
		temp = t_y;
		t_y = b_y;
		b_y = temp;
	}
	if ((l_x >= limit_x) || (t_y >= limit_y) || (r_x < 0) || (b_y < 0))
10004148:	5240642e 	bgeu	r10,r9,100042dc <alt_up_pixel_buffer_dma_draw_box+0x1c4>
void alt_up_pixel_buffer_dma_draw_box(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a filled box. */
{
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
	register unsigned int limit_y = pixel_buffer->y_resolution;
1000414c:	20801017 	ldw	r2,64(r4)
	{
		temp = t_y;
		t_y = b_y;
		b_y = temp;
	}
	if ((l_x >= limit_x) || (t_y >= limit_y) || (r_x < 0) || (b_y < 0))
10004150:	4080622e 	bgeu	r8,r2,100042dc <alt_up_pixel_buffer_dma_draw_box+0x1c4>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
10004154:	3a400136 	bltu	r7,r9,1000415c <alt_up_pixel_buffer_dma_draw_box+0x44>
	{
		r_x = limit_x - 1;
10004158:	49ffffc4 	addi	r7,r9,-1
	}
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
1000415c:	58800136 	bltu	r11,r2,10004164 <alt_up_pixel_buffer_dma_draw_box+0x4c>
	{
		b_y = limit_y - 1;
10004160:	12ffffc4 	addi	r11,r2,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
10004164:	d8800217 	ldw	r2,8(sp)
10004168:	01400044 	movi	r5,1
1000416c:	1140021e 	bne	r2,r5,10004178 <alt_up_pixel_buffer_dma_draw_box+0x60>
		addr = pixel_buffer->back_buffer_start_address;
10004170:	20c00c17 	ldw	r3,48(r4)
10004174:	00000106 	br	1000417c <alt_up_pixel_buffer_dma_draw_box+0x64>
	else
		addr = pixel_buffer->buffer_start_address;
10004178:	20c00b17 	ldw	r3,44(r4)

	/* Draw the box using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
1000417c:	20800d17 	ldw	r2,52(r4)
10004180:	21800e17 	ldw	r6,56(r4)
10004184:	1000291e 	bne	r2,zero,1000422c <alt_up_pixel_buffer_dma_draw_box+0x114>
		/* Draw a box of a given color on the screen using the XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
10004188:	21001317 	ldw	r4,76(r4)
		addr = addr + (t_y << offset_y);
1000418c:	4104983a 	sll	r2,r8,r4
10004190:	10c5883a 	add	r2,r2,r3
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
10004194:	31400b1e 	bne	r6,r5,100041c4 <alt_up_pixel_buffer_dma_draw_box+0xac>
			{
				for (x = l_x; x <= r_x; x++)
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
10004198:	290a983a 	sll	r5,r5,r4
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
1000419c:	5a004f36 	bltu	r11,r8,100042dc <alt_up_pixel_buffer_dma_draw_box+0x1c4>
100041a0:	5007883a 	mov	r3,r10
			{
				for (x = l_x; x <= r_x; x++)
100041a4:	38c00436 	bltu	r7,r3,100041b8 <alt_up_pixel_buffer_dma_draw_box+0xa0>
				{
					IOWR_8DIRECT(addr, x, local_color);
100041a8:	10c9883a 	add	r4,r2,r3
100041ac:	23000025 	stbio	r12,0(r4)
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
100041b0:	18c00044 	addi	r3,r3,1
100041b4:	003ffb06 	br	100041a4 <alt_up_pixel_buffer_dma_draw_box+0x8c>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
100041b8:	1145883a 	add	r2,r2,r5
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
100041bc:	42000044 	addi	r8,r8,1
100041c0:	003ff606 	br	1000419c <alt_up_pixel_buffer_dma_draw_box+0x84>
100041c4:	00c00044 	movi	r3,1
100041c8:	190a983a 	sll	r5,r3,r4
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
100041cc:	00c00084 	movi	r3,2
100041d0:	30c00d1e 	bne	r6,r3,10004208 <alt_up_pixel_buffer_dma_draw_box+0xf0>
			for (y = t_y; y <= b_y; y++)
100041d4:	5a004136 	bltu	r11,r8,100042dc <alt_up_pixel_buffer_dma_draw_box+0x1c4>
100041d8:	5007883a 	mov	r3,r10
			{
				for (x = l_x; x <= r_x; x++)
100041dc:	38c00536 	bltu	r7,r3,100041f4 <alt_up_pixel_buffer_dma_draw_box+0xdc>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
100041e0:	18c9883a 	add	r4,r3,r3
100041e4:	2089883a 	add	r4,r4,r2
100041e8:	2300002d 	sthio	r12,0(r4)
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
100041ec:	18c00044 	addi	r3,r3,1
100041f0:	003ffa06 	br	100041dc <alt_up_pixel_buffer_dma_draw_box+0xc4>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + (1 << offset_y);
100041f4:	1145883a 	add	r2,r2,r5
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
100041f8:	42000044 	addi	r8,r8,1
100041fc:	003ff506 	br	100041d4 <alt_up_pixel_buffer_dma_draw_box+0xbc>
			{
				for (x = l_x; x <= r_x; x++)
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + (1 << offset_y);
10004200:	1145883a 	add	r2,r2,r5
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
10004204:	42000044 	addi	r8,r8,1
10004208:	5a003436 	bltu	r11,r8,100042dc <alt_up_pixel_buffer_dma_draw_box+0x1c4>
1000420c:	5009883a 	mov	r4,r10
			{
				for (x = l_x; x <= r_x; x++)
10004210:	393ffb36 	bltu	r7,r4,10004200 <alt_up_pixel_buffer_dma_draw_box+0xe8>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
10004214:	2107883a 	add	r3,r4,r4
10004218:	18c7883a 	add	r3,r3,r3
1000421c:	1887883a 	add	r3,r3,r2
10004220:	1b000035 	stwio	r12,0(r3)
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
10004224:	21000044 	addi	r4,r4,1
10004228:	003ff906 	br	10004210 <alt_up_pixel_buffer_dma_draw_box+0xf8>
	} else {
		/* Draw a box of a given color on the screen using the linear addressing mode. */
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
1000422c:	31400c1e 	bne	r6,r5,10004260 <alt_up_pixel_buffer_dma_draw_box+0x148>
			addr = addr + t_y * limit_x;
10004230:	4245383a 	mul	r2,r8,r9
10004234:	10c5883a 	add	r2,r2,r3
			for (y = t_y; y <= b_y; y++)
10004238:	5a002836 	bltu	r11,r8,100042dc <alt_up_pixel_buffer_dma_draw_box+0x1c4>
1000423c:	5007883a 	mov	r3,r10
			{
				for (x = l_x; x <= r_x; x++)
10004240:	38c00436 	bltu	r7,r3,10004254 <alt_up_pixel_buffer_dma_draw_box+0x13c>
				{
					IOWR_8DIRECT(addr, x, local_color);
10004244:	10c9883a 	add	r4,r2,r3
10004248:	23000025 	stbio	r12,0(r4)
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
1000424c:	18c00044 	addi	r3,r3,1
10004250:	003ffb06 	br	10004240 <alt_up_pixel_buffer_dma_draw_box+0x128>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
10004254:	1245883a 	add	r2,r2,r9
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
10004258:	42000044 	addi	r8,r8,1
1000425c:	003ff606 	br	10004238 <alt_up_pixel_buffer_dma_draw_box+0x120>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
10004260:	00800084 	movi	r2,2
10004264:	4a53883a 	add	r9,r9,r9
10004268:	30800d1e 	bne	r6,r2,100042a0 <alt_up_pixel_buffer_dma_draw_box+0x188>
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
1000426c:	4245383a 	mul	r2,r8,r9
10004270:	10c5883a 	add	r2,r2,r3
			for (y = t_y; y <= b_y; y++)
10004274:	5a001936 	bltu	r11,r8,100042dc <alt_up_pixel_buffer_dma_draw_box+0x1c4>
10004278:	5007883a 	mov	r3,r10
			{
				for (x = l_x; x <= r_x; x++)
1000427c:	38c00536 	bltu	r7,r3,10004294 <alt_up_pixel_buffer_dma_draw_box+0x17c>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
10004280:	18c9883a 	add	r4,r3,r3
10004284:	2089883a 	add	r4,r4,r2
10004288:	2300002d 	sthio	r12,0(r4)
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
1000428c:	18c00044 	addi	r3,r3,1
10004290:	003ffa06 	br	1000427c <alt_up_pixel_buffer_dma_draw_box+0x164>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + limit_x;
10004294:	1245883a 	add	r2,r2,r9
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
10004298:	42000044 	addi	r8,r8,1
1000429c:	003ff506 	br	10004274 <alt_up_pixel_buffer_dma_draw_box+0x15c>
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
100042a0:	4a53883a 	add	r9,r9,r9
			addr = addr + t_y * limit_x;
100042a4:	4245383a 	mul	r2,r8,r9
100042a8:	10c5883a 	add	r2,r2,r3
			for (y = t_y; y <= b_y; y++)
100042ac:	5a000b36 	bltu	r11,r8,100042dc <alt_up_pixel_buffer_dma_draw_box+0x1c4>
100042b0:	5009883a 	mov	r4,r10
			{
				for (x = l_x; x <= r_x; x++)
100042b4:	39000636 	bltu	r7,r4,100042d0 <alt_up_pixel_buffer_dma_draw_box+0x1b8>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
100042b8:	2107883a 	add	r3,r4,r4
100042bc:	18c7883a 	add	r3,r3,r3
100042c0:	1887883a 	add	r3,r3,r2
100042c4:	1b000035 	stwio	r12,0(r3)
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
100042c8:	21000044 	addi	r4,r4,1
100042cc:	003ff906 	br	100042b4 <alt_up_pixel_buffer_dma_draw_box+0x19c>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + limit_x;
100042d0:	1245883a 	add	r2,r2,r9
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
100042d4:	42000044 	addi	r8,r8,1
100042d8:	003ff406 	br	100042ac <alt_up_pixel_buffer_dma_draw_box+0x194>
100042dc:	f800283a 	ret

100042e0 <alt_up_pixel_buffer_dma_draw_hline>:
	}
}

void alt_up_pixel_buffer_dma_draw_hline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int x1, int y, int color, int backbuffer)
/* This method draws a horizontal line. This method is faster than using the line method because we know the direction of the line. */
{
100042e0:	da400017 	ldw	r9,0(sp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
100042e4:	22000f17 	ldw	r8,60(r4)
	register unsigned int limit_y = pixel_buffer->y_resolution;
	register unsigned int temp;
	register unsigned int l_x = x0;
100042e8:	2805883a 	mov	r2,r5
	register unsigned int r_x = x1;
	register unsigned int line_y = y;
	register unsigned int local_color = color;
	
	/* Check coordinates */
	if (l_x > r_x)
100042ec:	3140022e 	bgeu	r6,r5,100042f8 <alt_up_pixel_buffer_dma_draw_hline+0x18>
100042f0:	3005883a 	mov	r2,r6
100042f4:	280d883a 	mov	r6,r5
	{
		temp = l_x;
		l_x = r_x;
		r_x = temp;
	}
	if ((l_x >= limit_x) || (line_y >= limit_y) || (r_x < 0) || (line_y < 0))
100042f8:	1200472e 	bgeu	r2,r8,10004418 <alt_up_pixel_buffer_dma_draw_hline+0x138>
100042fc:	20c01017 	ldw	r3,64(r4)
10004300:	38c0452e 	bgeu	r7,r3,10004418 <alt_up_pixel_buffer_dma_draw_hline+0x138>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
10004304:	32000136 	bltu	r6,r8,1000430c <alt_up_pixel_buffer_dma_draw_hline+0x2c>
	{
		r_x = limit_x - 1;
10004308:	41bfffc4 	addi	r6,r8,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
1000430c:	d8c00117 	ldw	r3,4(sp)
10004310:	02800044 	movi	r10,1
10004314:	1a80021e 	bne	r3,r10,10004320 <alt_up_pixel_buffer_dma_draw_hline+0x40>
		addr = pixel_buffer->back_buffer_start_address;
10004318:	20c00c17 	ldw	r3,48(r4)
1000431c:	00000106 	br	10004324 <alt_up_pixel_buffer_dma_draw_hline+0x44>
	else
		addr = pixel_buffer->buffer_start_address;
10004320:	20c00b17 	ldw	r3,44(r4)

	/* Draw a horizontal line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
10004324:	22c00d17 	ldw	r11,52(r4)
10004328:	21400e17 	ldw	r5,56(r4)
1000432c:	58001b1e 	bne	r11,zero,1000439c <alt_up_pixel_buffer_dma_draw_hline+0xbc>
		/* Draw a horizontal line of a given color on the screen using the XY addressing mode. */
		register unsigned int x;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
		addr = addr + (line_y << offset_y);
10004330:	21001317 	ldw	r4,76(r4)
10004334:	390e983a 	sll	r7,r7,r4
10004338:	38c7883a 	add	r3,r7,r3
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
1000433c:	2a80061e 	bne	r5,r10,10004358 <alt_up_pixel_buffer_dma_draw_hline+0x78>
			for (x = l_x; x <= r_x; x++)
10004340:	30800436 	bltu	r6,r2,10004354 <alt_up_pixel_buffer_dma_draw_hline+0x74>
			{
				IOWR_8DIRECT(addr, x, local_color);
10004344:	10c9883a 	add	r4,r2,r3
10004348:	22400025 	stbio	r9,0(r4)
		addr = addr + (line_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
1000434c:	10800044 	addi	r2,r2,1
10004350:	003ffb06 	br	10004340 <alt_up_pixel_buffer_dma_draw_hline+0x60>
10004354:	f800283a 	ret
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
10004358:	01000084 	movi	r4,2
1000435c:	2900071e 	bne	r5,r4,1000437c <alt_up_pixel_buffer_dma_draw_hline+0x9c>
			for (x = l_x; x <= r_x; x++)
10004360:	30800536 	bltu	r6,r2,10004378 <alt_up_pixel_buffer_dma_draw_hline+0x98>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
10004364:	1089883a 	add	r4,r2,r2
10004368:	20c9883a 	add	r4,r4,r3
1000436c:	2240002d 	sthio	r9,0(r4)
			for (x = l_x; x <= r_x; x++)
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
10004370:	10800044 	addi	r2,r2,1
10004374:	003ffa06 	br	10004360 <alt_up_pixel_buffer_dma_draw_hline+0x80>
10004378:	f800283a 	ret
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
1000437c:	30800636 	bltu	r6,r2,10004398 <alt_up_pixel_buffer_dma_draw_hline+0xb8>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
10004380:	1089883a 	add	r4,r2,r2
10004384:	2109883a 	add	r4,r4,r4
10004388:	20c9883a 	add	r4,r4,r3
1000438c:	22400035 	stwio	r9,0(r4)
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
10004390:	10800044 	addi	r2,r2,1
10004394:	003ff906 	br	1000437c <alt_up_pixel_buffer_dma_draw_hline+0x9c>
10004398:	f800283a 	ret
	} else {
		/* Draw a horizontal line of a given color on the screen using the linear addressing mode. */
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
1000439c:	2a80081e 	bne	r5,r10,100043c0 <alt_up_pixel_buffer_dma_draw_hline+0xe0>
			addr = addr + line_y * limit_x;
100043a0:	41cf383a 	mul	r7,r8,r7
100043a4:	38c7883a 	add	r3,r7,r3
			for (x = l_x; x <= r_x; x++)
100043a8:	30800436 	bltu	r6,r2,100043bc <alt_up_pixel_buffer_dma_draw_hline+0xdc>
			{
				IOWR_8DIRECT(addr, x, local_color);
100043ac:	10c9883a 	add	r4,r2,r3
100043b0:	22400025 	stbio	r9,0(r4)
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
100043b4:	10800044 	addi	r2,r2,1
100043b8:	003ffb06 	br	100043a8 <alt_up_pixel_buffer_dma_draw_hline+0xc8>
100043bc:	f800283a 	ret
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
100043c0:	01000084 	movi	r4,2
100043c4:	4211883a 	add	r8,r8,r8
100043c8:	2900091e 	bne	r5,r4,100043f0 <alt_up_pixel_buffer_dma_draw_hline+0x110>
			limit_x = limit_x << 1;
			addr = addr + line_y * limit_x;
100043cc:	41cf383a 	mul	r7,r8,r7
100043d0:	38c7883a 	add	r3,r7,r3
			for (x = l_x; x <= r_x; x++)
100043d4:	30800536 	bltu	r6,r2,100043ec <alt_up_pixel_buffer_dma_draw_hline+0x10c>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
100043d8:	1089883a 	add	r4,r2,r2
100043dc:	20c9883a 	add	r4,r4,r3
100043e0:	2240002d 	sthio	r9,0(r4)
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
100043e4:	10800044 	addi	r2,r2,1
100043e8:	003ffa06 	br	100043d4 <alt_up_pixel_buffer_dma_draw_hline+0xf4>
100043ec:	f800283a 	ret
			}
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + line_y * limit_x;
100043f0:	4211883a 	add	r8,r8,r8
100043f4:	41cf383a 	mul	r7,r8,r7
100043f8:	38c7883a 	add	r3,r7,r3
			for (x = l_x; x <= r_x; x++)
100043fc:	30800636 	bltu	r6,r2,10004418 <alt_up_pixel_buffer_dma_draw_hline+0x138>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
10004400:	1089883a 	add	r4,r2,r2
10004404:	2109883a 	add	r4,r4,r4
10004408:	20c9883a 	add	r4,r4,r3
1000440c:	22400035 	stwio	r9,0(r4)
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
10004410:	10800044 	addi	r2,r2,1
10004414:	003ff906 	br	100043fc <alt_up_pixel_buffer_dma_draw_hline+0x11c>
10004418:	f800283a 	ret

1000441c <alt_up_pixel_buffer_dma_draw_vline>:


void alt_up_pixel_buffer_dma_draw_vline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x, int y0, int y1, int color, int backbuffer)
/* This method draws a vertical line. This method is faster than using the line method because we know the direction of the line. */

{
1000441c:	da800017 	ldw	r10,0(sp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
10004420:	22400f17 	ldw	r9,60(r4)
	register unsigned int limit_y = pixel_buffer->y_resolution;
	register unsigned int temp;
	register unsigned int line_x = x;
	register unsigned int t_y = y0;
10004424:	3011883a 	mov	r8,r6
	register unsigned int b_y = y1;
	register unsigned int local_color = color;
	
	/* Check coordinates */
	if (t_y > b_y)
10004428:	3980022e 	bgeu	r7,r6,10004434 <alt_up_pixel_buffer_dma_draw_vline+0x18>
1000442c:	3811883a 	mov	r8,r7
10004430:	300f883a 	mov	r7,r6
	{
		temp = t_y;
		t_y = b_y;
		b_y = temp;
	}
	if ((line_x >= limit_x) || (t_y >= limit_y) || (line_x < 0) || (b_y < 0))
10004434:	2a404f2e 	bgeu	r5,r9,10004574 <alt_up_pixel_buffer_dma_draw_vline+0x158>
/* This method draws a vertical line. This method is faster than using the line method because we know the direction of the line. */

{
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
	register unsigned int limit_y = pixel_buffer->y_resolution;
10004438:	20801017 	ldw	r2,64(r4)
	{
		temp = t_y;
		t_y = b_y;
		b_y = temp;
	}
	if ((line_x >= limit_x) || (t_y >= limit_y) || (line_x < 0) || (b_y < 0))
1000443c:	40804d2e 	bgeu	r8,r2,10004574 <alt_up_pixel_buffer_dma_draw_vline+0x158>
	/* Clip the box and draw only within the confines of the screen. */
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
10004440:	38800136 	bltu	r7,r2,10004448 <alt_up_pixel_buffer_dma_draw_vline+0x2c>
	{
		b_y = limit_y - 1;
10004444:	11ffffc4 	addi	r7,r2,-1
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
10004448:	d8800117 	ldw	r2,4(sp)
1000444c:	01800044 	movi	r6,1
10004450:	1180021e 	bne	r2,r6,1000445c <alt_up_pixel_buffer_dma_draw_vline+0x40>
		addr = pixel_buffer->back_buffer_start_address;
10004454:	20800c17 	ldw	r2,48(r4)
10004458:	00000106 	br	10004460 <alt_up_pixel_buffer_dma_draw_vline+0x44>
	else
		addr = pixel_buffer->buffer_start_address;
1000445c:	20800b17 	ldw	r2,44(r4)

	/* Draw the vertical line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
10004460:	20c00d17 	ldw	r3,52(r4)
10004464:	22c00e17 	ldw	r11,56(r4)
10004468:	1800211e 	bne	r3,zero,100044f0 <alt_up_pixel_buffer_dma_draw_vline+0xd4>
		/* Draw a vertical line of a given color on the screen using the XY addressing mode. */
		register unsigned int y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
1000446c:	21001317 	ldw	r4,76(r4)
		addr = addr + (t_y << offset_y);
10004470:	4106983a 	sll	r3,r8,r4
10004474:	1887883a 	add	r3,r3,r2
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
10004478:	5980081e 	bne	r11,r6,1000449c <alt_up_pixel_buffer_dma_draw_vline+0x80>
			for (y = t_y; y <= b_y; y++)
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
1000447c:	310c983a 	sll	r6,r6,r4
10004480:	28c5883a 	add	r2,r5,r3
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
10004484:	3a000436 	bltu	r7,r8,10004498 <alt_up_pixel_buffer_dma_draw_vline+0x7c>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
10004488:	12800025 	stbio	r10,0(r2)
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
1000448c:	42000044 	addi	r8,r8,1
10004490:	1185883a 	add	r2,r2,r6
10004494:	003ffb06 	br	10004484 <alt_up_pixel_buffer_dma_draw_vline+0x68>
10004498:	f800283a 	ret
1000449c:	00800044 	movi	r2,1
100044a0:	110c983a 	sll	r6,r2,r4
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
100044a4:	01000084 	movi	r4,2
100044a8:	2945883a 	add	r2,r5,r5
100044ac:	59000326 	beq	r11,r4,100044bc <alt_up_pixel_buffer_dma_draw_vline+0xa0>
100044b0:	1085883a 	add	r2,r2,r2
100044b4:	10c5883a 	add	r2,r2,r3
100044b8:	00000706 	br	100044d8 <alt_up_pixel_buffer_dma_draw_vline+0xbc>
100044bc:	10c5883a 	add	r2,r2,r3
			for (y = t_y; y <= b_y; y++)
100044c0:	3a000436 	bltu	r7,r8,100044d4 <alt_up_pixel_buffer_dma_draw_vline+0xb8>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
100044c4:	1280002d 	sthio	r10,0(r2)
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
100044c8:	42000044 	addi	r8,r8,1
100044cc:	1185883a 	add	r2,r2,r6
100044d0:	003ffb06 	br	100044c0 <alt_up_pixel_buffer_dma_draw_vline+0xa4>
100044d4:	f800283a 	ret
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
100044d8:	3a000436 	bltu	r7,r8,100044ec <alt_up_pixel_buffer_dma_draw_vline+0xd0>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
100044dc:	12800035 	stwio	r10,0(r2)
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
100044e0:	42000044 	addi	r8,r8,1
100044e4:	1185883a 	add	r2,r2,r6
100044e8:	003ffb06 	br	100044d8 <alt_up_pixel_buffer_dma_draw_vline+0xbc>
100044ec:	f800283a 	ret
	} else {
		/* Draw a vertical line of a given color on the screen using the linear addressing mode. */
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
100044f0:	5980091e 	bne	r11,r6,10004518 <alt_up_pixel_buffer_dma_draw_vline+0xfc>
100044f4:	4247383a 	mul	r3,r8,r9
100044f8:	194b883a 	add	r5,r3,r5
100044fc:	2885883a 	add	r2,r5,r2
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
10004500:	3a000436 	bltu	r7,r8,10004514 <alt_up_pixel_buffer_dma_draw_vline+0xf8>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
10004504:	12800025 	stbio	r10,0(r2)
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
10004508:	42000044 	addi	r8,r8,1
1000450c:	1245883a 	add	r2,r2,r9
10004510:	003ffb06 	br	10004500 <alt_up_pixel_buffer_dma_draw_vline+0xe4>
10004514:	f800283a 	ret
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
10004518:	00c00084 	movi	r3,2
1000451c:	294b883a 	add	r5,r5,r5
10004520:	4a53883a 	add	r9,r9,r9
10004524:	58c0091e 	bne	r11,r3,1000454c <alt_up_pixel_buffer_dma_draw_vline+0x130>
10004528:	4247383a 	mul	r3,r8,r9
1000452c:	194b883a 	add	r5,r3,r5
10004530:	2885883a 	add	r2,r5,r2
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
10004534:	3a000436 	bltu	r7,r8,10004548 <alt_up_pixel_buffer_dma_draw_vline+0x12c>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
10004538:	1280002d 	sthio	r10,0(r2)
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
1000453c:	42000044 	addi	r8,r8,1
10004540:	1245883a 	add	r2,r2,r9
10004544:	003ffb06 	br	10004534 <alt_up_pixel_buffer_dma_draw_vline+0x118>
10004548:	f800283a 	ret
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
1000454c:	4a53883a 	add	r9,r9,r9
10004550:	4247383a 	mul	r3,r8,r9
10004554:	294b883a 	add	r5,r5,r5
10004558:	194b883a 	add	r5,r3,r5
1000455c:	2885883a 	add	r2,r5,r2
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
10004560:	3a000436 	bltu	r7,r8,10004574 <alt_up_pixel_buffer_dma_draw_vline+0x158>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
10004564:	12800035 	stwio	r10,0(r2)
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
10004568:	42000044 	addi	r8,r8,1
1000456c:	1245883a 	add	r2,r2,r9
10004570:	003ffb06 	br	10004560 <alt_up_pixel_buffer_dma_draw_vline+0x144>
10004574:	f800283a 	ret

10004578 <alt_up_pixel_buffer_dma_draw_rectangle>:
		}
	}
}

void alt_up_pixel_buffer_dma_draw_rectangle(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
{
10004578:	defff604 	addi	sp,sp,-40
1000457c:	dc400315 	stw	r17,12(sp)
10004580:	dc000215 	stw	r16,8(sp)
10004584:	dc400c17 	ldw	r17,48(sp)
10004588:	dc000b17 	ldw	r16,44(sp)
1000458c:	dd400715 	stw	r21,28(sp)
10004590:	dcc00515 	stw	r19,20(sp)
10004594:	dd400a17 	ldw	r21,40(sp)
10004598:	3827883a 	mov	r19,r7
1000459c:	dd000615 	stw	r20,24(sp)
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y0, color, backbuffer);
100045a0:	300f883a 	mov	r7,r6
		}
	}
}

void alt_up_pixel_buffer_dma_draw_rectangle(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
{
100045a4:	3029883a 	mov	r20,r6
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y0, color, backbuffer);
100045a8:	dc400115 	stw	r17,4(sp)
100045ac:	980d883a 	mov	r6,r19
100045b0:	dc000015 	stw	r16,0(sp)
		}
	}
}

void alt_up_pixel_buffer_dma_draw_rectangle(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
{
100045b4:	dfc00915 	stw	ra,36(sp)
100045b8:	dd800815 	stw	r22,32(sp)
100045bc:	dc800415 	stw	r18,16(sp)
100045c0:	282d883a 	mov	r22,r5
100045c4:	2025883a 	mov	r18,r4
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y0, color, backbuffer);
100045c8:	00042e00 	call	100042e0 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y1, color, backbuffer);
100045cc:	a80f883a 	mov	r7,r21
100045d0:	980d883a 	mov	r6,r19
100045d4:	b00b883a 	mov	r5,r22
100045d8:	9009883a 	mov	r4,r18
100045dc:	dc400115 	stw	r17,4(sp)
100045e0:	dc000015 	stw	r16,0(sp)
100045e4:	00042e00 	call	100042e0 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x0, y0, y1, color, backbuffer);
100045e8:	a80f883a 	mov	r7,r21
100045ec:	a00d883a 	mov	r6,r20
100045f0:	b00b883a 	mov	r5,r22
100045f4:	9009883a 	mov	r4,r18
100045f8:	dc400115 	stw	r17,4(sp)
100045fc:	dc000015 	stw	r16,0(sp)
10004600:	000441c0 	call	1000441c <alt_up_pixel_buffer_dma_draw_vline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x1, y0, y1, color, backbuffer);
10004604:	a80f883a 	mov	r7,r21
10004608:	a00d883a 	mov	r6,r20
1000460c:	980b883a 	mov	r5,r19
10004610:	9009883a 	mov	r4,r18
10004614:	dc400b15 	stw	r17,44(sp)
10004618:	dc000a15 	stw	r16,40(sp)
}
1000461c:	dfc00917 	ldw	ra,36(sp)
10004620:	dd800817 	ldw	r22,32(sp)
10004624:	dd400717 	ldw	r21,28(sp)
10004628:	dd000617 	ldw	r20,24(sp)
1000462c:	dcc00517 	ldw	r19,20(sp)
10004630:	dc800417 	ldw	r18,16(sp)
10004634:	dc400317 	ldw	r17,12(sp)
10004638:	dc000217 	ldw	r16,8(sp)
1000463c:	dec00a04 	addi	sp,sp,40
void alt_up_pixel_buffer_dma_draw_rectangle(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
{
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y0, color, backbuffer);
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y1, color, backbuffer);
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x0, y0, y1, color, backbuffer);
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x1, y0, y1, color, backbuffer);
10004640:	000441c1 	jmpi	1000441c <alt_up_pixel_buffer_dma_draw_vline>

10004644 <helper_plot_pixel>:
}

void helper_plot_pixel(register unsigned int buffer_start, register int line_size, register int x, register int y, register int color, register int mode)
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
10004644:	d8c00117 	ldw	r3,4(sp)
10004648:	d8800017 	ldw	r2,0(sp)
1000464c:	29cb383a 	mul	r5,r5,r7
	if (mode == 0)
10004650:	1800041e 	bne	r3,zero,10004664 <helper_plot_pixel+0x20>
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
10004654:	298d883a 	add	r6,r5,r6
10004658:	310d883a 	add	r6,r6,r4
1000465c:	30800025 	stbio	r2,0(r6)
10004660:	f800283a 	ret
	else if (mode == 1)
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
10004664:	298d883a 	add	r6,r5,r6
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
	if (mode == 0)
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
	else if (mode == 1)
10004668:	01c00044 	movi	r7,1
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
1000466c:	318d883a 	add	r6,r6,r6
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
	if (mode == 0)
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
	else if (mode == 1)
10004670:	19c0031e 	bne	r3,r7,10004680 <helper_plot_pixel+0x3c>
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
10004674:	310d883a 	add	r6,r6,r4
10004678:	3080002d 	sthio	r2,0(r6)
1000467c:	f800283a 	ret
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
10004680:	318d883a 	add	r6,r6,r6
10004684:	310d883a 	add	r6,r6,r4
10004688:	30800035 	stwio	r2,0(r6)
1000468c:	f800283a 	ret

10004690 <alt_up_pixel_buffer_dma_draw_line>:
}

void alt_up_pixel_buffer_dma_draw_line(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a line between points (x0, y0) and (x1, y1). The function does not check if it draws a pixel within screen boundaries.
 * users should ensure that the line is drawn within the screen boundaries. */
{
10004690:	defff304 	addi	sp,sp,-52
10004694:	d8800d17 	ldw	r2,52(sp)
10004698:	dcc00615 	stw	r19,24(sp)
1000469c:	dc800515 	stw	r18,20(sp)
100046a0:	dc400415 	stw	r17,16(sp)
100046a4:	dfc00c15 	stw	ra,48(sp)
100046a8:	df000b15 	stw	fp,44(sp)
100046ac:	ddc00a15 	stw	r23,40(sp)
100046b0:	dd800915 	stw	r22,36(sp)
100046b4:	dd400815 	stw	r21,32(sp)
100046b8:	dd000715 	stw	r20,28(sp)
100046bc:	dc000315 	stw	r16,12(sp)
	register int x_0 = x0;
	register int y_0 = y0;
	register int x_1 = x1;
	register int y_1 = y1;
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
100046c0:	1187c83a 	sub	r3,r2,r6
}

void alt_up_pixel_buffer_dma_draw_line(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a line between points (x0, y0) and (x1, y1). The function does not check if it draws a pixel within screen boundaries.
 * users should ensure that the line is drawn within the screen boundaries. */
{
100046c4:	2823883a 	mov	r17,r5
100046c8:	3025883a 	mov	r18,r6
100046cc:	3827883a 	mov	r19,r7
	register int x_0 = x0;
	register int y_0 = y0;
	register int x_1 = x1;
	register int y_1 = y1;
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
100046d0:	1800010e 	bge	r3,zero,100046d8 <alt_up_pixel_buffer_dma_draw_line+0x48>
100046d4:	00c7c83a 	sub	r3,zero,r3
100046d8:	9c4bc83a 	sub	r5,r19,r17
100046dc:	2800010e 	bge	r5,zero,100046e4 <alt_up_pixel_buffer_dma_draw_line+0x54>
100046e0:	014bc83a 	sub	r5,zero,r5
	register int deltax, deltay, error, ystep, x, y;
	register int color_mode =	(pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) ? 0 :
100046e4:	25000e17 	ldw	r20,56(r4)
100046e8:	05800044 	movi	r22,1
100046ec:	a5800426 	beq	r20,r22,10004700 <alt_up_pixel_buffer_dma_draw_line+0x70>
								(pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) ? 1 : 2;
100046f0:	a50000a0 	cmpeqi	r20,r20,2
100046f4:	01800084 	movi	r6,2
100046f8:	3529c83a 	sub	r20,r6,r20
100046fc:	00000106 	br	10004704 <alt_up_pixel_buffer_dma_draw_line+0x74>
	register int y_0 = y0;
	register int x_1 = x1;
	register int y_1 = y1;
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
	register int deltax, deltay, error, ystep, x, y;
	register int color_mode =	(pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) ? 0 :
10004700:	0029883a 	mov	r20,zero
								(pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) ? 1 : 2;
	register int line_color = color;
	register unsigned int buffer_start;
	register int line_size = (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) ? (1 << (pixel_buffer->y_coord_offset-color_mode)) : pixel_buffer->x_resolution;
10004704:	21800d17 	ldw	r6,52(r4)
10004708:	3000041e 	bne	r6,zero,1000471c <alt_up_pixel_buffer_dma_draw_line+0x8c>
1000470c:	21801317 	ldw	r6,76(r4)
10004710:	350dc83a 	sub	r6,r6,r20
10004714:	b1ac983a 	sll	r22,r22,r6
10004718:	00000106 	br	10004720 <alt_up_pixel_buffer_dma_draw_line+0x90>
1000471c:	25800f17 	ldw	r22,60(r4)

	if (backbuffer == 1)
10004720:	d9c00f17 	ldw	r7,60(sp)
10004724:	01800044 	movi	r6,1
10004728:	3980021e 	bne	r7,r6,10004734 <alt_up_pixel_buffer_dma_draw_line+0xa4>
		buffer_start = pixel_buffer->back_buffer_start_address;
1000472c:	22000c17 	ldw	r8,48(r4)
10004730:	00000106 	br	10004738 <alt_up_pixel_buffer_dma_draw_line+0xa8>
	else
		buffer_start = pixel_buffer->buffer_start_address;
10004734:	22000b17 	ldw	r8,44(r4)

	/* Preprocessing inputs */
	if (steep > 0) {
10004738:	28c0060e 	bge	r5,r3,10004754 <alt_up_pixel_buffer_dma_draw_line+0xc4>
1000473c:	9809883a 	mov	r4,r19
		error = x_0;
		x_0 = y_0;
		y_0 = error;
		// Swap x_1 and y_1
		error = x_1;
		x_1 = y_1;
10004740:	1027883a 	mov	r19,r2
		y_1 = error;
10004744:	2005883a 	mov	r2,r4
10004748:	8809883a 	mov	r4,r17

	/* Preprocessing inputs */
	if (steep > 0) {
		// Swap x_0 and y_0
		error = x_0;
		x_0 = y_0;
1000474c:	9023883a 	mov	r17,r18
		y_0 = error;
10004750:	2025883a 	mov	r18,r4
		// Swap x_1 and y_1
		error = x_1;
		x_1 = y_1;
		y_1 = error;
	}
	if (x_0 > x_1) {
10004754:	9c40060e 	bge	r19,r17,10004770 <alt_up_pixel_buffer_dma_draw_line+0xe0>
10004758:	9009883a 	mov	r4,r18
		error = x_0;
		x_0 = x_1;
		x_1 = error;
		// Swap y_0 and y_1
		error = y_0;
		y_0 = y_1;
1000475c:	1025883a 	mov	r18,r2
		y_1 = error;
10004760:	2005883a 	mov	r2,r4
		// Swap x_1 and y_1
		error = x_1;
		x_1 = y_1;
		y_1 = error;
	}
	if (x_0 > x_1) {
10004764:	8809883a 	mov	r4,r17
10004768:	9823883a 	mov	r17,r19
1000476c:	2027883a 	mov	r19,r4
		y_1 = error;
	}

	/* Setup local variables */
	deltax = x_1 - x_0;
	deltay = ABS(y_1 - y_0);
10004770:	14afc83a 	sub	r23,r2,r18
		y_0 = y_1;
		y_1 = error;
	}

	/* Setup local variables */
	deltax = x_1 - x_0;
10004774:	9c79c83a 	sub	fp,r19,r17
	deltay = ABS(y_1 - y_0);
10004778:	b800010e 	bge	r23,zero,10004780 <alt_up_pixel_buffer_dma_draw_line+0xf0>
1000477c:	05efc83a 	sub	r23,zero,r23
	error = -(deltax / 2); 
10004780:	e020d7fa 	srli	r16,fp,31
10004784:	8721883a 	add	r16,r16,fp
10004788:	8021d07a 	srai	r16,r16,1
1000478c:	0421c83a 	sub	r16,zero,r16
	y = y_0;
	if (y_0 < y_1)
10004790:	90800216 	blt	r18,r2,1000479c <alt_up_pixel_buffer_dma_draw_line+0x10c>
		ystep = 1;
	else
		ystep = -1;
10004794:	057fffc4 	movi	r21,-1
10004798:	00000106 	br	100047a0 <alt_up_pixel_buffer_dma_draw_line+0x110>
	deltax = x_1 - x_0;
	deltay = ABS(y_1 - y_0);
	error = -(deltax / 2); 
	y = y_0;
	if (y_0 < y_1)
		ystep = 1;
1000479c:	05400044 	movi	r21,1
	else
		ystep = -1;

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
100047a0:	28c0200e 	bge	r5,r3,10004824 <alt_up_pixel_buffer_dma_draw_line+0x194>
	{
		for (x=x_0; x <= x_1; x++) {
100047a4:	9c402016 	blt	r19,r17,10004828 <alt_up_pixel_buffer_dma_draw_line+0x198>
			helper_plot_pixel(buffer_start, line_size, y, x, line_color, color_mode);
100047a8:	d8800e17 	ldw	r2,56(sp)
100047ac:	4009883a 	mov	r4,r8
100047b0:	dd000115 	stw	r20,4(sp)
100047b4:	d8800015 	stw	r2,0(sp)
100047b8:	880f883a 	mov	r7,r17
100047bc:	900d883a 	mov	r6,r18
100047c0:	b00b883a 	mov	r5,r22
100047c4:	da000215 	stw	r8,8(sp)
			error = error + deltay;
100047c8:	85e1883a 	add	r16,r16,r23
	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
	{
		for (x=x_0; x <= x_1; x++) {
			helper_plot_pixel(buffer_start, line_size, y, x, line_color, color_mode);
100047cc:	00046440 	call	10004644 <helper_plot_pixel>
			error = error + deltay;
			if (error > 0) {
100047d0:	da000217 	ldw	r8,8(sp)
100047d4:	0400020e 	bge	zero,r16,100047e0 <alt_up_pixel_buffer_dma_draw_line+0x150>
				y = y + ystep;
100047d8:	9565883a 	add	r18,r18,r21
				error = error - deltax;
100047dc:	8721c83a 	sub	r16,r16,fp

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
	{
		for (x=x_0; x <= x_1; x++) {
100047e0:	8c400044 	addi	r17,r17,1
100047e4:	003fef06 	br	100047a4 <alt_up_pixel_buffer_dma_draw_line+0x114>
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
			helper_plot_pixel(buffer_start, line_size, x, y, line_color, color_mode);
100047e8:	d8800e17 	ldw	r2,56(sp)
100047ec:	4009883a 	mov	r4,r8
100047f0:	dd000115 	stw	r20,4(sp)
100047f4:	d8800015 	stw	r2,0(sp)
100047f8:	900f883a 	mov	r7,r18
100047fc:	880d883a 	mov	r6,r17
10004800:	b00b883a 	mov	r5,r22
10004804:	da000215 	stw	r8,8(sp)
			error = error + deltay;
10004808:	85e1883a 	add	r16,r16,r23
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
			helper_plot_pixel(buffer_start, line_size, x, y, line_color, color_mode);
1000480c:	00046440 	call	10004644 <helper_plot_pixel>
			error = error + deltay;
			if (error > 0) {
10004810:	da000217 	ldw	r8,8(sp)
10004814:	0400020e 	bge	zero,r16,10004820 <alt_up_pixel_buffer_dma_draw_line+0x190>
				y = y + ystep;
10004818:	9565883a 	add	r18,r18,r21
				error = error - deltax;
1000481c:	8721c83a 	sub	r16,r16,fp
			}
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
10004820:	8c400044 	addi	r17,r17,1
10004824:	9c7ff00e 	bge	r19,r17,100047e8 <alt_up_pixel_buffer_dma_draw_line+0x158>
				y = y + ystep;
				error = error - deltax;
			}
		}
	}
}
10004828:	dfc00c17 	ldw	ra,48(sp)
1000482c:	df000b17 	ldw	fp,44(sp)
10004830:	ddc00a17 	ldw	r23,40(sp)
10004834:	dd800917 	ldw	r22,36(sp)
10004838:	dd400817 	ldw	r21,32(sp)
1000483c:	dd000717 	ldw	r20,28(sp)
10004840:	dcc00617 	ldw	r19,24(sp)
10004844:	dc800517 	ldw	r18,20(sp)
10004848:	dc400417 	ldw	r17,16(sp)
1000484c:	dc000317 	ldw	r16,12(sp)
10004850:	dec00d04 	addi	sp,sp,52
10004854:	f800283a 	ret

10004858 <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10004858:	0005883a 	mov	r2,zero
1000485c:	00c40004 	movi	r3,4096
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
10004860:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
10004864:	10800804 	addi	r2,r2,32
10004868:	10fffd1e 	bne	r2,r3,10004860 <alt_dcache_flush_all+0x8>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
1000486c:	f800283a 	ret

10004870 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
10004870:	3005883a 	mov	r2,r6
10004874:	f800283a 	ret

10004878 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
10004878:	20000226 	beq	r4,zero,10004884 <alt_dev_llist_insert+0xc>
1000487c:	20800217 	ldw	r2,8(r4)
10004880:	1000101e 	bne	r2,zero,100048c4 <alt_dev_llist_insert+0x4c>
10004884:	d0a00817 	ldw	r2,-32736(gp)
10004888:	10000926 	beq	r2,zero,100048b0 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
1000488c:	deffff04 	addi	sp,sp,-4
10004890:	dfc00015 	stw	ra,0(sp)
10004894:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
10004898:	00c00584 	movi	r3,22
1000489c:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
100048a0:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
100048a4:	dfc00017 	ldw	ra,0(sp)
100048a8:	dec00104 	addi	sp,sp,4
100048ac:	f800283a 	ret
100048b0:	d0a0a404 	addi	r2,gp,-32112
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
100048b4:	00c00584 	movi	r3,22
100048b8:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
100048bc:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
100048c0:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
100048c4:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
100048c8:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
100048cc:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
100048d0:	28800017 	ldw	r2,0(r5)
100048d4:	11000115 	stw	r4,4(r2)
  list->next           = entry;
100048d8:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
100048dc:	0005883a 	mov	r2,zero
100048e0:	f800283a 	ret

100048e4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
100048e4:	defffb04 	addi	sp,sp,-20
100048e8:	dcc00315 	stw	r19,12(sp)
100048ec:	dc800215 	stw	r18,8(sp)
100048f0:	dc400115 	stw	r17,4(sp)
100048f4:	dc000015 	stw	r16,0(sp)
100048f8:	dfc00415 	stw	ra,16(sp)
100048fc:	2027883a 	mov	r19,r4
10004900:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
10004904:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
10004908:	00033a00 	call	100033a0 <strlen>
1000490c:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
10004910:	84400726 	beq	r16,r17,10004930 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
10004914:	81000217 	ldw	r4,8(r16)
10004918:	900d883a 	mov	r6,r18
1000491c:	980b883a 	mov	r5,r19
10004920:	00049a40 	call	100049a4 <memcmp>
10004924:	10000426 	beq	r2,zero,10004938 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
10004928:	84000017 	ldw	r16,0(r16)
1000492c:	003ff806 	br	10004910 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
10004930:	0005883a 	mov	r2,zero
10004934:	00000106 	br	1000493c <alt_find_dev+0x58>
10004938:	8005883a 	mov	r2,r16
}
1000493c:	dfc00417 	ldw	ra,16(sp)
10004940:	dcc00317 	ldw	r19,12(sp)
10004944:	dc800217 	ldw	r18,8(sp)
10004948:	dc400117 	ldw	r17,4(sp)
1000494c:	dc000017 	ldw	r16,0(sp)
10004950:	dec00504 	addi	sp,sp,20
10004954:	f800283a 	ret

10004958 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
10004958:	01440004 	movi	r5,4096
1000495c:	0009883a 	mov	r4,zero
10004960:	000496c1 	jmpi	1000496c <alt_icache_flush>

10004964 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
10004964:	000170fa 	wrctl	ienable,zero
10004968:	f800283a 	ret

1000496c <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
1000496c:	00840004 	movi	r2,4096
10004970:	1140012e 	bgeu	r2,r5,10004978 <alt_icache_flush+0xc>
10004974:	100b883a 	mov	r5,r2
10004978:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
1000497c:	2005883a 	mov	r2,r4
10004980:	1140032e 	bgeu	r2,r5,10004990 <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
10004984:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
10004988:	10800804 	addi	r2,r2,32
1000498c:	003ffc06 	br	10004980 <alt_icache_flush+0x14>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
10004990:	210007cc 	andi	r4,r4,31
10004994:	20000126 	beq	r4,zero,1000499c <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
10004998:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
1000499c:	0000203a 	flushp
100049a0:	f800283a 	ret

100049a4 <memcmp>:
int
_DEFUN (memcmp, (m1, m2, n),
	_CONST _PTR m1 _AND
	_CONST _PTR m2 _AND
	size_t n)
{
100049a4:	218d883a 	add	r6,r4,r6
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  unsigned char *s1 = (unsigned char *) m1;
  unsigned char *s2 = (unsigned char *) m2;

  while (n--)
100049a8:	21800826 	beq	r4,r6,100049cc <memcmp+0x28>
    {
      if (*s1 != *s2)
100049ac:	20800003 	ldbu	r2,0(r4)
100049b0:	28c00003 	ldbu	r3,0(r5)
100049b4:	10c00226 	beq	r2,r3,100049c0 <memcmp+0x1c>
	{
	  return *s1 - *s2;
100049b8:	10c5c83a 	sub	r2,r2,r3
100049bc:	f800283a 	ret
	}
      s1++;
100049c0:	21000044 	addi	r4,r4,1
      s2++;
100049c4:	29400044 	addi	r5,r5,1
100049c8:	003ff706 	br	100049a8 <memcmp+0x4>
    }
  return 0;
100049cc:	0005883a 	mov	r2,zero
      s2++;
    }

  return 0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
100049d0:	f800283a 	ret

100049d4 <strcmp>:
_DEFUN (strcmp, (s1, s2),
	_CONST char *s1 _AND
	_CONST char *s2)
{ 
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  while (*s1 != '\0' && *s1 == *s2)
100049d4:	20800003 	ldbu	r2,0(r4)
100049d8:	10c03fcc 	andi	r3,r2,255
100049dc:	18c0201c 	xori	r3,r3,128
100049e0:	18ffe004 	addi	r3,r3,-128
100049e4:	18000526 	beq	r3,zero,100049fc <strcmp+0x28>
100049e8:	29800007 	ldb	r6,0(r5)
100049ec:	1980031e 	bne	r3,r6,100049fc <strcmp+0x28>
    {
      s1++;
100049f0:	21000044 	addi	r4,r4,1
      s2++;
100049f4:	29400044 	addi	r5,r5,1
100049f8:	003ff606 	br	100049d4 <strcmp>
    }

  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
100049fc:	28c00003 	ldbu	r3,0(r5)
10004a00:	10803fcc 	andi	r2,r2,255
      s1++;
      s2++;
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
#endif /* not PREFER_SIZE_OVER_SPEED */
}
10004a04:	10c5c83a 	sub	r2,r2,r3
10004a08:	f800283a 	ret
